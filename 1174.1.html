<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="author" content="高宮 安仁, 鈴木 一哉, 松井 暢之, 村木 暢哉, 山崎 泰宏">
<title>TremaでOpenFlowプログラミング</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif,serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
.antialiased,body{-webkit-font-smoothing:antialiased}
img{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:Consolas,"Liberation Mono",Courier,monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
    h1{font-size:2.75em}
    h2{font-size:2.3125em}
    h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
    h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:Consolas,"Liberation Mono",Courier,monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{display:inline-block;color:rgba(0,0,0,.8);font-size:.75em;line-height:1.4;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:-.15em .15em 0 .15em;padding:.2em .6em .2em .5em;vertical-align:middle;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;list-style-type:none}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
    body.toc2{padding-left:15em;padding-right:0}
    #toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
    #toc.toc2 #toctitle{margin-top:0;font-size:1.2em}
    #toc.toc2>ul{font-size:.9em;margin-bottom:0}
    #toc.toc2 ul ul{margin-left:0;padding-left:1em}
    #toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
    body.toc2.toc-right{padding-left:0;padding-right:15em}
    body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
    #toc.toc2{width:20em}
    #toc.toc2 #toctitle{font-size:1.375em}
    #toc.toc2>ul{font-size:.95em}
    #toc.toc2 ul ul{padding-left:1.25em}
    body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.05em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.spread{width:100%}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-check-square-o:first-child,ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1{padding-right:.75em;font-weight:bold}
td.hdlist1,td.hdlist2{vertical-align:top}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none}
span.footnote,span.footnoteref{vertical-align:super;font-size:.875em}
span.footnote a,span.footnoteref a{text-decoration:none}
span.footnote a:active,span.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em;line-height:1.3;font-size:.875em;margin-left:1.2em;text-indent:-1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
h1,h2{letter-spacing:-.01em}
dt,th.tableblock,td.content{text-rendering:optimizeLegibility}
p,td.content{letter-spacing:-.01em}
p strong,td.content strong{letter-spacing:-.005em}
p,blockquote,dt,td.content{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
    *{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
    a{color:inherit!important;text-decoration:underline!important}
    a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
    a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after,a[href^="mailto:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
    abbr[title]:after{content:" (" attr(title) ")"}
    pre,blockquote,tr,img{page-break-inside:avoid}
    thead{display:table-header-group}
    img{max-width:100%!important}
    p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
    h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
    #toc,.sidebarblock,.exampleblock>.content{background:none!important}
    #toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
    .sect1{padding-bottom:0!important}
    .sect1+.sect1{border:0!important}
    #header>h1:first-child{margin-top:1.25rem}
    body.book #header{text-align:center}
    body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
    body.book #header .details{border:0!important;display:block;padding:0!important}
    body.book #header .details span:first-child{margin-left:0!important}
    body.book #header .details br{display:block}
    body.book #header .details br+span:before{content:none!important}
    body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
    body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
    .listingblock code[data-lang]:before{display:block}
    #footer{background:none!important;padding:0 .9375em}
    #footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
    .hide-on-print{display:none!important}
    .print-only{display:block!important}
    .hide-for-print{display:none!important}
    .show-for-print{display:inherit!important}}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>TremaでOpenFlowプログラミング</h1>
<div class="details">
<span id="author" class="author">高宮 安仁</span><br>
<span id="email" class="email"><a href="mailto:yasuhito@gmail.com">yasuhito@gmail.com</a></span><br>
<span id="author2" class="author">鈴木 一哉</span><br>
<span id="author3" class="author">松井 暢之</span><br>
<span id="author4" class="author">村木 暢哉</span><br>
<span id="author5" class="author">山崎 泰宏</span><br>
<span id="revnumber">version 0.46.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_はじめに">はじめに</a>
<ul class="sectlevel2">
<li><a href="#_書籍版">書籍版</a></li>
<li><a href="#_フリー版">フリー版</a></li>
<li><a href="#_執筆に参加する">執筆に参加する</a></li>
<li><a href="#_ライセンス">ライセンス</a></li>
</ul>
</li>
<li><a href="#how_does_openflow_work">1. OpenFlow の仕組み</a>
<ul class="sectlevel2">
<li><a href="#_ソフトウェアで楽をする">1.1. ソフトウェアで楽をする</a></li>
<li><a href="#_ネットワークもソフトウェア制御">1.2. ネットワークもソフトウェア制御</a></li>
<li><a href="#_openflow_の動作モデル">1.3. OpenFlow の動作モデル</a></li>
<li><a href="#_openflow_のうれしさ">1.4. OpenFlow のうれしさ</a></li>
<li><a href="#_openflowで気をつけること">1.5. OpenFlowで気をつけること</a></li>
<li><a href="#_まとめ">1.6. まとめ</a></li>
</ul>
</li>
<li><a href="#openflow_spec">2. OpenFlow の仕様</a>
<ul class="sectlevel2">
<li><a href="#_説明する範囲とバージョン">2.1. 説明する範囲とバージョン</a></li>
<li><a href="#_スイッチとコントローラ間のやりとり">2.2. スイッチとコントローラ間のやりとり</a></li>
<li><a href="#_フローエントリの中身">2.3. フローエントリの中身</a></li>
<li><a href="#_マルチプルテーブル">2.4. マルチプルテーブル</a></li>
<li><a href="#_まとめ_2">2.5. まとめ</a></li>
</ul>
</li>
<li><a href="#hello_trema">3. Hello, Trema!</a>
<ul class="sectlevel2">
<li><a href="#_作ってわかるopenflow">3.1. 作ってわかるOpenFlow</a></li>
<li><a href="#_tremaとは">3.2. Tremaとは</a></li>
<li><a href="#_trema実行環境のセットアップ">3.3. Trema実行環境のセットアップ</a></li>
<li><a href="#_hello_trema">3.4. Hello, Trema!</a></li>
<li><a href="#_trema_コマンド">3.5. trema コマンド</a></li>
<li><a href="#_即席ruby入門">3.6. 即席Ruby入門</a></li>
<li><a href="#_まとめ_3">3.7. まとめ</a></li>
<li><a href="#_参考文献">3.8. 参考文献</a></li>
</ul>
</li>
<li><a href="#switch_monitor">4. スイッチ監視ツール</a>
<ul class="sectlevel2">
<li><a href="#_ネットワークを集中管理しよう">4.1. ネットワークを集中管理しよう</a></li>
<li><a href="#_インストール">4.2. インストール</a></li>
<li><a href="#_実行してみよう">4.3. 実行してみよう</a></li>
<li><a href="#_ソースコード解説">4.4. ソースコード解説</a></li>
<li><a href="#_まとめ_4">4.5. まとめ</a></li>
</ul>
</li>
<li><a href="#cbench">5. マイクロベンチマークCbench</a>
<ul class="sectlevel2">
<li><a href="#_cbenchベンチマークとは">5.1. Cbenchベンチマークとは</a></li>
<li><a href="#_インストール_2">5.2. インストール</a></li>
<li><a href="#_実行してみよう_2">5.3. 実行してみよう</a></li>
<li><a href="#_ソースコード解説_2">5.4. ソースコード解説</a></li>
<li><a href="#_マルチスレッド化する">5.5. マルチスレッド化する</a></li>
<li><a href="#_無理やり高速化する">5.6. 無理やり高速化する</a></li>
<li><a href="#_まとめ_5">5.7. まとめ</a></li>
</ul>
</li>
<li><a href="#patch_panel">6. インテリジェントなパッチパネル</a>
<ul class="sectlevel2">
<li><a href="#_便利なインテリジェント_パッチパネル">6.1. 便利なインテリジェント・パッチパネル</a></li>
<li><a href="#_openflow版インテリジェント_パッチパネル">6.2. OpenFlow版インテリジェント・パッチパネル</a></li>
<li><a href="#_実行してみよう_3">6.3. 実行してみよう</a></li>
<li><a href="#_ソースコード解説_3">6.4. ソースコード解説</a></li>
<li><a href="#_まとめ_6">6.5. まとめ</a></li>
</ul>
</li>
<li><a href="#learning_switch">7. すべての基本、ラーニングスイッチ</a>
<ul class="sectlevel2">
<li><a href="#_ラーニングスイッチとは何か">7.1. ラーニングスイッチとは何か</a></li>
<li><a href="#_イーサネットスイッチの仕組み">7.2. イーサネットスイッチの仕組み</a></li>
<li><a href="#_openflow版イーサネットスイッチ_ラーニングスイッチ_の仕組み">7.3. OpenFlow版イーサネットスイッチ(ラーニングスイッチ)の仕組み</a></li>
<li><a href="#_実行してみよう_4">7.4. 実行してみよう</a></li>
<li><a href="#_ラーニングスイッチのソースコード">7.5. ラーニングスイッチのソースコード</a></li>
<li><a href="#_まとめ_7">7.6. まとめ</a></li>
</ul>
</li>
<li><a href="#learning_switch13">8. OpenFlow1.3版ラーニングスイッチ</a>
<ul class="sectlevel2">
<li><a href="#_openflow1_0版ラーニングスイッチの問題点">8.1. OpenFlow1.0版ラーニングスイッチの問題点</a></li>
<li><a href="#_マルチプルテーブル_2">8.2. マルチプルテーブル</a></li>
<li><a href="#_openflow1_3_での_packet_in">8.3. OpenFlow1.3 での Packet In</a></li>
<li><a href="#_openflow1_3版ラーニングスイッチの仕組み">8.4. OpenFlow1.3版ラーニングスイッチの仕組み</a></li>
<li><a href="#_ソースコード解説_4">8.5. ソースコード解説</a></li>
<li><a href="#_まとめ_8">8.6. まとめ</a></li>
</ul>
</li>
<li><a href="#tdd">9. Trema でテスト駆動開発</a>
<ul class="sectlevel2">
<li><a href="#_仕様書としてのテストコード">9.1. 仕様書としてのテストコード</a></li>
<li><a href="#_リピータハブの動き">9.2. リピータハブの動き</a></li>
<li><a href="#_どこまでテストするか">9.3. どこまでテストするか？</a></li>
<li><a href="#_テストに使うツール">9.4. テストに使うツール</a></li>
<li><a href="#_パケット受信をテストする">9.5. パケット受信をテストする</a></li>
<li><a href="#_リファクタリング">9.6. リファクタリング</a></li>
<li><a href="#_まとめ_9">9.7. まとめ</a></li>
<li><a href="#_参考文献_2">9.8. 参考文献</a></li>
</ul>
</li>
<li><a href="#one_way_bridge">10. 生活ネットワークをOpenFlowに移行する</a>
<ul class="sectlevel2">
<li><a href="#_どんどん規模を広げていこう">10.1. どんどん規模を広げていこう</a></li>
<li><a href="#_大ケガしないためのヘルメット">10.2. 大ケガしないためのヘルメット</a></li>
<li><a href="#_私たちの失敗談">10.3. 私たちの失敗談</a></li>
<li><a href="#_openflowへの移行パターン">10.4. OpenFlowへの移行パターン</a></li>
<li><a href="#_逆流防止フィルタ">10.5. 逆流防止フィルタ</a></li>
<li><a href="#_まとめ_10">10.6. まとめ</a></li>
</ul>
</li>
<li><a href="#firewall">11. ファイアウォール</a>
<ul class="sectlevel2">
<li><a href="#_透過型ファイアウォール">11.1. 透過型ファイアウォール</a></li>
<li><a href="#_blockrfc1918コントローラ">11.2. BlockRFC1918コントローラ</a></li>
<li><a href="#_blockrfc1918のソースコード">11.3. BlockRFC1918のソースコード</a></li>
<li><a href="#_passdelegatedコントローラ">11.4. PassDelegatedコントローラ</a></li>
<li><a href="#_passdelegatedのソースコード">11.5. PassDelegatedのソースコード</a></li>
<li><a href="#_まとめ_11">11.6. まとめ</a></li>
</ul>
</li>
<li><a href="#router_part1">12. ルータ (前編)</a>
<ul class="sectlevel2">
<li><a href="#_ルータとスイッチの違い">12.1. ルータとスイッチの違い</a></li>
<li><a href="#_イーサネットだけならルータは不要">12.2. イーサネットだけならルータは不要？</a></li>
<li><a href="#_ルータの動作">12.3. ルータの動作</a></li>
<li><a href="#_ソースコード解説_5">12.4. ソースコード解説</a></li>
<li><a href="#_まとめ_12">12.5. まとめ</a></li>
</ul>
</li>
<li><a href="#router_part2">13. ルータ (後編)</a>
<ul class="sectlevel2">
<li><a href="#_宛先ホストをまとめる">13.1. 宛先ホストをまとめる</a></li>
<li><a href="#_ネットワーク宛てのエントリをまとめる">13.2. ネットワーク宛てのエントリをまとめる</a></li>
<li><a href="#_routingtable_のソースコード">13.3. RoutingTable のソースコード</a></li>
<li><a href="#_実行してみよう_8">13.4. 実行してみよう</a></li>
<li><a href="#_まとめ_13">13.5. まとめ</a></li>
</ul>
</li>
<li><a href="#router13">14. ルータ (マルチプルテーブル編)</a>
<ul class="sectlevel2">
<li><a href="#_マルチプルテーブル版ルータのテーブル構成">14.1. マルチプルテーブル版ルータのテーブル構成</a></li>
<li><a href="#_マルチプルテーブル版ルータの動作例">14.2. マルチプルテーブル版ルータの動作例</a></li>
<li><a href="#_実行してみよう_9">14.3. 実行してみよう</a></li>
<li><a href="#_まとめ_14">14.4. まとめ</a></li>
</ul>
</li>
<li><a href="#topology">15. ネットワークトポロジを検出する</a>
<ul class="sectlevel2">
<li><a href="#_美しい大規模ネットワーク">15.1. 美しい大規模ネットワーク</a></li>
<li><a href="#_トポロジ検出の仕組み">15.2. トポロジ検出の仕組み</a></li>
<li><a href="#_実行してみよう_10">15.3. 実行してみよう</a></li>
<li><a href="#_トポロジコントローラのソースコード">15.4. トポロジコントローラのソースコード</a></li>
<li><a href="#_まとめ_15">15.5. まとめ</a></li>
</ul>
</li>
<li><a href="#routing_switch">16. たくさんのスイッチを制御する</a>
<ul class="sectlevel2">
<li><a href="#_複数のスイッチを制御する">16.1. 複数のスイッチを制御する</a></li>
<li><a href="#_最短パスを計算する">16.2. 最短パスを計算する</a></li>
<li><a href="#_実行してみよう_11">16.3. 実行してみよう</a></li>
<li><a href="#_ルーティングスイッチのソースコード">16.4. ルーティングスイッチのソースコード</a></li>
<li><a href="#_openflow_を使う利点">16.5. OpenFlow を使う利点</a></li>
<li><a href="#_まとめ_16">16.6. まとめ</a></li>
</ul>
</li>
<li><a href="#sliceable_switch">17. ネットワークを仮想化する</a>
<ul class="sectlevel2">
<li><a href="#_ネットワークをスライスに分ける">17.1. ネットワークをスライスに分ける</a></li>
<li><a href="#_スライスの実現方法">17.2. スライスの実現方法</a></li>
<li><a href="#_インストール_3">17.3. インストール</a></li>
<li><a href="#_rest_api_を使う">17.4. REST API を使う</a></li>
<li><a href="#_rest_api_一覧">17.5. REST API 一覧</a></li>
<li><a href="#_スライス機能付きスイッチの実装">17.6. スライス機能付きスイッチの実装</a></li>
<li><a href="#_スライス機能付きスイッチのソースコード">17.7. スライス機能付きスイッチのソースコード</a></li>
<li><a href="#_まとめ_17">17.8. まとめ</a></li>
</ul>
</li>
<li><a href="#openvnet">18. OpenVNetで本格的な仮想ネットワーク</a>
<ul class="sectlevel2">
<li><a href="#_openvnetとは">18.1. OpenVNetとは</a></li>
<li><a href="#_エッジ仮想化の利点">18.2. エッジ仮想化の利点</a></li>
<li><a href="#_openvnetの全体アーキテクチャ">18.3. OpenVNetの全体アーキテクチャ</a></li>
<li><a href="#_openvnetの主な機能">18.4. OpenVNetの主な機能</a></li>
<li><a href="#_使ってみる">18.5. 使ってみる</a></li>
<li><a href="#_openvnetを応用した実用例">18.6. OpenVNetを応用した実用例</a></li>
<li><a href="#_まとめ_18">18.7. まとめ</a></li>
</ul>
</li>
<li><a href="#_copyright_and_license">Appendix A: Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_はじめに">はじめに</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/trema/trema">Trema</a>を使ったOpenFlowプログラミングを解説するフリー書籍です。対応スイッチの多いOpenFlowバージョン1.3.xを対象にしています。プログラミング言語はRubyバージョン2.0以降です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ブラウザで読む: <a href="https://yasuhito.github.com/trema-book/" class="bare">https://yasuhito.github.com/trema-book/</a></p>
</li>
<li>
<p>PDFで読む: (準備中)</p>
</li>
<li>
<p>GitHubのプロジェクトページ: <a href="https://github.com/yasuhito/trema-book" class="bare">https://github.com/yasuhito/trema-book</a></p>
</li>
<li>
<p>Twitterのハッシュタグ: <a href="https://twitter.com/hashtag/Trema%E6%9C%AC">#Trema本</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_書籍版">書籍版</h3>
<div class="paragraph">
<p>各種書店で入手可能です。もちろん、プロによる組版なので高品質です。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.github.com/yasuhito/trema-book/develop/images/cover.png" alt="本のカバー">
</div>
</div>
<div class="paragraph">
<p>正誤表など技術評論社のサポートページは <a href="https://gihyo.jp/book/2016/978-4-7741-7983-4">こちら</a>です</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.amazon.co.jp/o/ASIN/4774179833/">Amazonで購入</a></p>
</li>
<li>
<p><a href="http://www.yodobashi.com/-増補改訂版-クラウド時代のネットワーク技術-OpenFlow実践入門-Software-Design-plus-単行本/pd/100000009002526970/">ヨドバシ.comで購入</a></p>
</li>
<li>
<p><a href="http://7net.omni7.jp/detail_isbn/978-4-7741-7983-4">7netショッピングで購入</a></p>
</li>
<li>
<p><a href="http://honto.jp/netstore/pd-book_27703803.html">hontoで購入</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_フリー版">フリー版</h3>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://travis-ci.org/yasuhito/trema-book"><img src="https://travis-ci.org/yasuhito/trema-book.svg?branch=develop" alt="Build Status"></a></span>
<span class="image"><a class="image" href="https://gemnasium.com/yasuhito/trema-book"><img src="http://img.shields.io/gemnasium/yasuhito/trema-book.svg?style=flat" alt="Dependency Status"></a></span></p>
</div>
<div class="paragraph">
<p>次のようにしてソースから本をビルドできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>git clone git@github.com:yasuhito/trema-book.git
cd trema-book
bundle install
bundle exec rake</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_執筆に参加する">執筆に参加する</h3>
<div class="paragraph">
<p>誰でもいろいろな形でTrema本の執筆に参加できます。</p>
</div>
<div class="paragraph">
<p>本に関する雑談は <a href="https://gitter.im/yasuhito/trema-book">Gitterのチャット</a>でどうぞ。</p>
</div>
<div class="paragraph">
<p>もし誤字脱字を見つけたら、GitHubでイシューを切ってもらうか、ソースコードを直接修正してPull Requestを出してもらえると助かります。もちろん、内容についてのコメントや追加内容も歓迎します。</p>
</div>
<div class="paragraph">
<p>原稿の書式は <a href="http://asciidoc.org/">Asciidoc</a>です。詳しい書き方についてはAsciidocのコンパイラである <a href="http://asciidoctor.org/docs/user-manual/">Asciidoctorのユーザマニュアル</a>を参照してください。</p>
</div>
<div class="paragraph">
<p>貢献していただいた方は書籍版の「謝辞」にもれなくお名前が載ります。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.github.com/yasuhito/trema-book/develop/images/acknowledgements.jpg" alt="謝辞">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ライセンス">ライセンス</h3>
<div class="paragraph">
<p>This book is released under the GNU General Public License version 3.0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.gnu.org/licenses/gpl-3.0.html" class="bare">http://www.gnu.org/licenses/gpl-3.0.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how_does_openflow_work">1. OpenFlow の仕組み</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>ネットワークを OpenFlow で構築すると、どんな利点があるのでしょうか。その答えは、<strong>ソフトウェアによる自動化</strong>です。まずは身近な自動化の例を見ていきましょう。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/how_does_openflow_work/incredible_machine.png" alt="incredible machine">
</div>
</div>
<div class="sect2">
<h3 id="_ソフトウェアで楽をする">1.1. ソフトウェアで楽をする</h3>
<div class="quoteblock">
<blockquote>
無精 (Laziness): エネルギーの総支出を減らすために、多大な努力をするように、あなたをかりたてる性質。こうして労力を省くために書いたプログラムは他人も使うようになり、そのプログラムに関する質問にいちいち答えずに済ますためにドキュメントを書くようになる。それゆえ、プログラマにとってもっとも重要な素質である。またそれゆえ、この本が存在するのである。
</blockquote>
<div class="attribution">
&#8212; Larry Wall<br>
<cite>『プログラミング Perl』(オーム社)</cite>
</div>
</div>
<div class="paragraph">
<p>優れたプログラマが持つハッカー気質の 1 つに<strong>無精</strong>があります。「大好きなコンピュータの前から一時も離れずに、どうやってジャンクフードにありつこう。そうだ、ソフトウェアを書けばできるじゃないか!」普通の人からするとただの横着に見えるかもしれません。しかし、ハッカーにとってはいつでも大きな問題なのです。</p>
</div>
<div class="paragraph">
<p>ソフトウェアによる横着は、ハッカーがもっとも創造性を発揮する分野の 1 つです。時間のかかる面倒な仕事も、ハッカーにかかれば気の利いたスクリプトひとつで自動化してしまいます。ハッカーによる次の 3 つの伝説的な逸話は、いずれもただ横着のためだけに高い技術力を駆使したといういい例です。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ピザ注文コマンド</dt>
<dd>
<p>ハッカーの巣窟として有名な MIT の AI ラボにはかつて、コンピュータからオンラインでピザを注文できる UNIX コマンドが存在しました<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>。ハックしていて腹が減ったらコマンドを叩いてピザを取る。なんとも横着です。</p>
</dd>
<dt class="hdlist1">自販機のリモート監視</dt>
<dd>
<p>コンピュータサイエンスの名門、カーネギーメロン大学にはコーク・マシンという変わったコーラ自販機がかつてあり、UNIX コマンド一発でコーラの冷え具合を確認できるようになっていました<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>。わざわざ遠くの自販機まで行ったのにぬるいコーラをつかまされた、なんてことが起きないようにするための工夫です。</p>
</dd>
<dt class="hdlist1">コーヒーポットプロトコル</dt>
<dd>
<p>RFC (Request For Comment) 2324 のコーヒーポットプロトコルは、遠隔地にあるコーヒーポットのコーヒーの量を監視したり、コーヒーを自動的にいれたりするための半分冗談の HTTP メッセージを定義しています<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup>。いわゆるジョーク RFC にもかかわらず、本当に実装してしまった人もいたそうですから驚きです。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>こうした<strong>ソフトウェアで楽をする</strong>ハックの中でも、もっとも大規模な例が最新鋭のデータセンターです。クラウドサービスの裏で動く巨大なデータセンターは、大部分の管理作業をソフトウェアによって極限まで自動化しています。このおかげで、極めて少人数のエンジニアによる運用を可能にしています。</p>
</div>
<div class="paragraph">
<p>このように、ピザの注文やコーラ自販機、コーヒーポットといったお遊びから、データセンターのように一筋縄ではいかない相手まで、ソフトウェアを書けばその大部分を自動化できます。そして何より、<strong>ソフトウェアでモノを思いどおりにコントロールする</strong>のは楽しく、かつ実際に役立ちます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>こうした最新鋭データセンターでのネットワーク管理自動化の仕組みは、<a href="#routing_switch">16 章「たくさんのスイッチを制御する」</a>および<a href="#sliceable_switch">17 章「ネットワークを仮想化する」</a>で詳しく解説します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ネットワークもソフトウェア制御">1.2. ネットワークもソフトウェア制御</h3>
<div class="paragraph">
<p>ネットワークをソフトウェア制御する技術の 1 つが OpenFlow です。より正確に言えば、OpenFlow とはネットワークスイッチの動作を制御するための標準プロトコルの 1 つです。OpenFlow を使えばスイッチ 1 つひとつの動作をソフトウェアから自由に書き換えられるので、究極的にはネットワーク全体の動作をソースコードとして記述できます。これを <strong>Software Defined Networking</strong> (ソフトウェアで定義されるネットワーク。以下 <strong>SDN</strong> と略す) と呼び、OpenFlow は SDN を実現する代表的な技術として注目を集めています。</p>
</div>
<div class="paragraph">
<p>OpenFlow の登場によって、これからはネットワークインフラもプログラミングの対象になります。「いまだに手で管理してるの? そんなのソフトウェアで自動化しようぜ!」ハッカーのこんな声が聞こえてきそうです。たしかに、今までネットワーク管理と言えば専門のオペレータによる手作業がメインでした。横着できる部分はまだまだたくさんあるはずです。</p>
</div>
<div class="paragraph">
<p>OpenFlow を使えば、次のような究極の自動化も夢ではなくなります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>スイッチの障害やネットワーク構成の変化など、あらゆる情報を自動収集するネットワーク</p>
</li>
<li>
<p>ユーザ／サーバ／スイッチの追加や削除に応じて、自動的に構成を変更するネットワーク</p>
</li>
<li>
<p>追加投資をしなくても、既存のインフラを目一杯まで使ってスケールするネットワーク</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本書はこれらすべてのトピックを扱います。自宅や職場のような中小規模ネットワークからデータセンターのような超大規模ネットワークまで、実例を交じえながら「OpenFlow ってどんなもので、具体的に何に使えるのだろう?」という素朴な疑問に答えていきます。そして実際に動かしながら理解できるように、各章では実用的なソースコードを解説しています。</p>
</div>
<div class="paragraph">
<p>本書を読み進めるにあたって、ネットワークやプログラミングの深い知識は不要です。基本から 1 つひとつ説明しますので、ネットワークの専門家はもちろん、プログラマやシステムエンジニア、そして営業職や管理職などなど OpenFlow に興味を持つ方であれば誰でもすんなり理解できるように構成してあります。</p>
</div>
<div class="paragraph">
<p>ではさっそく、OpenFlow で構築したネットワークがどう動くかを見て行きましょう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_openflow_の動作モデル">1.3. OpenFlow の動作モデル</h3>
<div class="paragraph">
<p>OpenFlow の仕組みを理解するために、ちょっとした<strong>たとえ話</strong>から始めます。みなさんもきっと利用したことがある、電話のカスタマーサポートサービスを思い浮かべてください。そう、テレビとかパソコンの調子が悪くなったときに、フリーダイヤルで相談するアレです。でもそれって、OpenFlow とどう関係するのでしょう?</p>
</div>
<div class="paragraph">
<p>実は OpenFlow の基本的な仕組みはカスタマーサポートにとてもよく似ているのです。これからお話しするストーリーがわかれば、OpenFlow の 95% を理解できたも同然です。</p>
</div>
<div class="paragraph">
<p>それでは、このストーリーの主人公の友太郎 (ゆうたろう) 君と、カスタマーサポートセンターで働く青井さん、そして上司の宮坂部長の 3 人に登場してもらいましょう。</p>
</div>
<div class="sect3">
<h4 id="_ストーリー_1_エアコンが壊れた">1.3.1. ストーリー 1: エアコンが壊れた</h4>
<div class="paragraph">
<p>今年もエアコンの活躍する季節がやってきました。</p>
</div>
<div class="paragraph">
<p>ところが友太郎君のエアコンはどうにも調子がよくありません。取扱説明書に載っていたカスタマーサポートに電話し、自動音声に従ってしばし自分で直そうとしてみたものの、いっこうに解決しません。</p>
</div>
<div class="paragraph">
<p>結局、自動音声はあきらめて電話サポートに相談することにしました。</p>
</div>
<div class="paragraph">
<p>「はい、こちらカスタマーサポートセンターです。担当はわたくし青井がうけたまわります。ご要件は何でしょうか？」</p>
</div>
<div class="paragraph">
<p>青井さんはヨーヨーダイン・エアコン社で働く電話オペレータです。青井さんの普段のオペレータ業務は、主に次の 2 つです (<a href="#yoyodyne_support">図1-1</a>)。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>お客さんから不具合の症状を聞き出す</p>
</li>
<li>
<p>症状の内容に応じてそれぞれの担当技術サポートに電話をつなぐ</p>
</li>
</ol>
</div>
<div id="yoyodyne_support" class="imageblock">
<div class="content">
<img src="images/how_does_openflow_work/yoyodyne_support.png" alt="yoyodyne support">
</div>
<div class="title">図 1-1: 電話オペレータはお客さんからの問い合わせを適切な技術サポートへ転送</div>
</div>
<div class="paragraph">
<p>友太郎君は聞きます。</p>
</div>
<div class="paragraph">
<p>「なんだかリモコンの調子が悪いんです。温度表示がずっと点滅してるんですけど、どうしたら直りますか？」</p>
</div>
<div class="paragraph">
<p>青井さんは手元の対応マニュアルを開きます (<a href="#operator_manual">表 1-1</a>)。対応マニュアルには 3 つの項目があり、お客さんからの「問い合わせ内容」、電話オペレータの「対応方法」、そしてお客さんからの「問い合わせ件数」を調べられるようになっています。</p>
</div>
<table id="operator_manual" class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. 表 1-1: 電話オペレータ用対応マニュアル</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">問い合わせ内容</th>
<th class="tableblock halign-left valign-top">対応方法</th>
<th class="tableblock halign-left valign-top">問い合わせ件数</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>リモコンの不調</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>周辺機器担当の技術サポートに転送</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>8 件</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">エアコン本体の不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">エアコン担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">室外機の不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周辺機器担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">いたずら電話</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">電話を切る</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 件</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>青井さんはちょうどマニュアルの先頭に、探していた「リモコンの不調」の項目を見つけました。</p>
</div>
<div class="paragraph">
<p>「ご不便をおかけしました。リモコン担当の技術サポートにただいまお繋ぎいたします」</p>
</div>
<div class="paragraph">
<p>電話の転送を終えると、青井さんはリモコン不調の問い合わせ件数を 8 件から 9 件にアップデートしました (<a href="#operator_manual_update">表 1-2</a>)。</p>
</div>
<table id="operator_manual_update" class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. 表 1-2: 対応マニュアルの「問い合わせ件数」をアップデートする</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">問い合わせ内容</th>
<th class="tableblock halign-left valign-top">対応方法</th>
<th class="tableblock halign-left valign-top">問い合わせ件数</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リモコンの不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周辺機器担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>9 件</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">エアコン本体の不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">エアコン担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">室外機の不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周辺機器担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">いたずら電話</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">電話を切る</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 件</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>このように問い合わせ件数を控えておくことで、どんな故障が多いかを上司にフィードバックできます。たとえばリモコンに関する問い合わせが多ければ、上司は次の製品開発で「リモコンを改良せよ」という指示を飛ばせます。あるいは、周辺機器担当の技術サポートメンバーをもっと増やそうという判断もできます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_openflow_に置き換えると">1.3.2. OpenFlow に置き換えると</h4>
<div class="paragraph">
<p>OpenFlow の世界では、パケットを送信するホストがお客さんの友太郎君、パケットを転送する OpenFlow スイッチが電話オペレータの青井さんに対応します (<a href="#openflow_host_switch">図 1-2</a>)。ホストがパケットを送ると、OpenFlow スイッチはパケットの中身に応じてパケットを適切に処理します。これはちょうど、青井さんが友太郎君からの問い合わせ内容に応じ、適切な技術サポートに電話を転送するのと同じです。</p>
</div>
<div id="openflow_host_switch" class="imageblock">
<div class="content">
<img src="images/how_does_openflow_work/openflow_host_switch.png" alt="openflow host switch">
</div>
<div class="title">図 1-2: OpenFlow ではホストがお客さん、スイッチが電話オペレータ、そしてフローテーブルがマニュアルに対応</div>
</div>
<div class="paragraph">
<p>OpenFlow スイッチは、動作が<strong>マニュアル化</strong>されています。カスタマーサポートの例では、青井さんはマニュアルから対応方法を調べました。いっぽう OpenFlow スイッチでは、スイッチ内の<strong>フローテーブル</strong>からパケットの処理方法を調べます。フローテーブルとは一種のデータベースで、パケットごとの処理方法が入っています。青井さんの業務がすべてマニュアル化されているのと同じく、OpenFlowスイッチの動作はすべてこのフローテーブルの内容によって決まります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_フローテーブルとフローエントリ">1.3.3. フローテーブルとフローエントリ</h4>
<div class="paragraph">
<p>フローテーブルには、「こういうパケットが届いたら、こう処理する」というルールがいくつか入っています。このルールを<strong>フローエントリ</strong>と呼びます。フローエントリはちょうど「リモコンの故障に関する問い合わせがきたら、リモコン担当の技術サポートに電話を転送する」といったマニュアルの各項目に対応します。</p>
</div>
<div class="paragraph">
<p>実際のフローテーブルの例を見てみましょう。<a href="#flow_table_entry">表 1-3</a> はあるスイッチのフローテーブルで、各行がフローエントリです。フローエントリは主に、マッチフィールド・アクション・カウンタの 3 つの要素からなります<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]</sup>。</p>
</div>
<table id="flow_table_entry" class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. 表 1-3: フローテーブルとフローエントリの例</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチフィールド</th>
<th class="tableblock halign-left valign-top">アクション</th>
<th class="tableblock halign-left valign-top">カウンタ</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元 IP アドレス = 192.168.1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ポート 8 番に転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">80 パケット</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN ID = 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ポート 10 番に転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64 パケット</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元 MAC アドレス = 00:50:56:c0:00:08</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN ID = 2 を付けてポート 8 番に転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24 パケット</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元 IP アドレス = 203.0.113.0/16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットを破棄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 パケット</p></td>
</tr>
</tbody>
</table>
<div class="dlist">
<dl>
<dt class="hdlist1">マッチフィールド</dt>
<dd>
<p>届いたパケットに対応するフローエントリを探すための<strong>条件</strong>です。たとえば「リモコンの調子がおかしい」という問い合わせ内容と同じく、マッチフィールドには「送信元 IP アドレス = 192.168.1.0」などと指定します。</p>
</dd>
<dt class="hdlist1">アクション</dt>
<dd>
<p>届いたパケットをどう処理するかという<strong>処理方法</strong>にあたります。たとえば「リモコン担当の技術サポートへ引き継ぎ」という対応方法と同じく、アクションには「スイッチのポート 8 番に転送」などと指定します。</p>
</dd>
<dt class="hdlist1">カウンタ</dt>
<dd>
<p>フローエントリごとの<strong>パケット処理量</strong>を記録します。たとえば「リモコン関連の問い合わせ数は 9 件」とマニュアルに記録したように、「このフローエントリに従って処理したパケットは 80 個」といった情報が入ります。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>このように、実は OpenFlow はとても単純で理解しやすい仕組みです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ストーリー_2_エアコンがまたまた故障">1.3.4. ストーリー 2: エアコンがまたまた故障</h4>
<div class="paragraph">
<p>エアコンもしばらくは順調でしたが、1 ヶ月後また調子が悪くなってしまいました。友太郎君は再びカスタマーサポートへダイヤルします。</p>
</div>
<div class="paragraph">
<p>「エアコンの排水ホースがすぐ詰まっちゃうんです」</p>
</div>
<div class="paragraph">
<p>どうやらまったく新しい不具合のようです。青井さんはいつものように手元の対応マニュアルを調べましたが、困ったことに排水ホースの項目は載っていません。</p>
</div>
<div class="paragraph">
<p>「申し訳ございませんが少々お待ちください。対応可能な技術サポートがいるかどうか確認いたします」</p>
</div>
<div class="paragraph">
<p>そして電話口にはどこか軽快な音楽と、「しばらくお待ちください」のメッセージが繰り返し流れはじめました。</p>
</div>
<div id="yoyodyne_support_miyasaka" class="imageblock">
<div class="content">
<img src="images/how_does_openflow_work/yoyodyne_support_miyasaka.png" alt="yoyodyne support miyasaka">
</div>
<div class="title">図 1-3: 対応マニュアルに対処法が見つからなかった場合、上司に聞く</div>
</div>
<div class="paragraph">
<p>こういうとき、青井さんがいつも頼るのは上司の宮坂部長です (<a href="#yoyodyne_support_miyasaka">図1-3</a>)。</p>
</div>
<div class="paragraph">
<p>「宮坂さん、排水ホースについての問い合わせがきたのですが、どの技術サポートにつなげばよいですか？」</p>
</div>
<div class="paragraph">
<p>「それだったら消耗品技術サポートだよ」</p>
</div>
<div class="paragraph">
<p>転送先がわかった青井さんは、友太郎君の待つ電話に戻ります。</p>
</div>
<div class="paragraph">
<p>「大変お待たせいたしました。担当の技術サポートに転送いたします」</p>
</div>
<div class="paragraph">
<p>一度目の問い合わせと比べてかなり時間がかかってしまいましたが、これでようやく一件落着です。青井さんは忘れないうちに、宮坂部長から教わった消耗品技術サポートの連絡先をマニュアルに追加します (<a href="#operator_manual_add_row">表 1-4</a>)。もしも同じ問い合わせがきた場合には、素早く答えられるようにするためです。</p>
</div>
<table id="operator_manual_add_row" class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. 表 1-4: マニュアルに新しい項目を追加してアップデートする</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">問い合わせ内容</th>
<th class="tableblock halign-left valign-top">対応方法</th>
<th class="tableblock halign-left valign-top">問い合わせ件数</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リモコンの不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周辺機器担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">エアコン本体の不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">エアコン担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">室外機の不調</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周辺機器担当の技術サポートに転送</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">いたずら電話</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">電話を切る</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>排水ホースの不調</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>消耗品担当の技術サポートに転送</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>1 件</strong></p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_openflow_に置き換えると_2">OpenFlow に置き換えると</h5>
<div class="paragraph">
<p>OpenFlow でこの上司にあたるのが、<strong>コントローラ</strong>と呼ばれるソフトウェアです (<a href="#openflow_host_switch_controller">図 1-4</a>)。フローテーブルに載っていないパケットがスイッチに届くと、スイッチは「このパケットはどうすればよいですか」とコントローラに指示をあおぎます。コントローラはパケットの中身を調べ、どうすべきかという指示、つまり新しいフローエントリをフローテーブルに書き込みます。</p>
</div>
<div id="openflow_host_switch_controller" class="imageblock">
<div class="content">
<img src="images/how_does_openflow_work/openflow_host_switch_controller.png" alt="openflow host switch controller">
</div>
<div class="title">図 1-4: フローテーブルにエントリーが見つからなかった場合、コントローラに問い合わせる</div>
</div>
<div class="paragraph">
<p>当然ながら、コントローラへの問い合わせが発生するとパケット転送が遅くなります。そこで、あらかじめ必要とわかっているフローエントリは、スイッチの起動時に書き込んでおくようにします。そうすれば、スイッチ側でパケットを素早く処理できます。</p>
</div>
<div class="paragraph">
<p>OpenFlow でネットワークインフラをプログラミングする場合、プログラマが書くのはこのコントローラです。頭脳であるコントローラをソフトウェアとして記述することで、ネットワークを自由自在に制御できるというわけです。ただし、スイッチからの問い合わせをあまり発生させずに効率良くパケット転送できるかどうかは、すべてコントローラの設計にかかっています。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_openflow_のうれしさ">1.4. OpenFlow のうれしさ</h3>
<div class="paragraph">
<p>OpenFlow の大枠が理解できたところで、OpenFlow の利点を具体的に見ていきましょう。</p>
</div>
<div class="sect3">
<h4 id="_自動化やシステム連携がしやすい">1.4.1. 自動化やシステム連携がしやすい</h4>
<div class="paragraph">
<p>カスタマーサポートセンターでは、お客さん対応はすべて電話オペレータがやってくれます。上司があらかじめ適切なマニュアルを作っておけば、あとはほとんどの仕事を電話オペレータにおまかせできるのです。これによって、電話オペレータが対応している間、管理職は他の部署との連携に集中できます。</p>
</div>
<div class="paragraph">
<p>OpenFlow では上司であるコントローラ自体をソフトウェアとして書けるので、ネットワークだけでなくその管理も自動化できます。さらにコントローラが Ruby や Python、Java などの汎用言語で書いてあれば、既存のシステムやサービスとの連携も簡単です。たとえば、アプリケーションからの要求やビジネスポリシーの変更、問題発生などさまざまなトリガーに応じてネットワークの設定を変更するといった、一歩進んだ自動化もできます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>システム連携の一例として、コントローラに REST API を実装する方法を<a href="#sliceable_switch">17 章「ネットワークを仮想化する」</a>で解説します。また、実際のデータセンターでのコントローラと各種サービスの連携については、<a href="#openvnet">18 章「OpenVNet で本格的な仮想ネットワーク」</a>で紹介します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ネットワークトラフィックを集中制御しやすい">1.4.2. ネットワークトラフィックを集中制御しやすい</h4>
<div class="paragraph">
<p>カスタマーサポートセンターでは問い合わせ件数の情報はすべて上司に上がってくるため、混み具合の把握や全体の交通整理が楽です。もし特定の技術サポートに問い合わせが集中しても、問い合わせがうまくバラけるようにマニュアルを通じて電話オペレータの全員に指示できます。反対にもし各オペレータが個々に判断してしまうと、おなじ技術サポートに問い合わせが偏ることは避けられません。</p>
</div>
<div class="paragraph">
<p>OpenFlow でもすべての情報はコントローラに上がってくるため、全体を見たトラフィックの最適化が可能です。フローエンントリ内のカウンタを集計し、検出したスイッチの接続関係 (ネットワークトポロジ) と突き合わせることで、コントローラはネットワーク全体のトラフィックを把握できます。そしてその情報をもとに各スイッチのフローテーブルを更新することで、全体的に見て最適となるパケットの通り道を引けます。反対に、もし個々のスイッチが判断してしまうと、効率的にトラフィックを分散できません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>各種カウンタの収集方法については<a href="#switch_monitor">4 章「スイッチ監視ツール」</a>で、ネットワークトポロジの検出方法については<a href="#topology">15 章「ネットワークトポロジを検出する」</a>で、またトラフィックの分散方法については<a href="#routing_switch">16 章「たくさんのスイッチを制御する」</a>で解説します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ソフトウェア開発のテクニックやツールが使える">1.4.3. ソフトウェア開発のテクニックやツールが使える</h4>
<div class="paragraph">
<p>コントローラはソフトウェアの一種なので、ソフトウェア開発で長年培われているさまざまなテクニックやツールをネットワーク構築に応用できます。</p>
</div>
<div class="paragraph">
<p>たとえば近年主流のアジャイル開発手法でコントローラを開発すれば、反復的な機能追加が可能です。ユーザからのフィードバックを受けながら少しずつバージョンアップしてくことで、ネットワークを段階的に構築できます。</p>
</div>
<div class="paragraph">
<p>またコントローラのテストコードを書くことで、ネットワーク全体を自動的にテストできます。テストコードやテスト結果の出力は、そのまま仕様書の一部として使えます。もう Excel や Word で書いた仕様書を別個に管理する必要はありません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>アジャイル開発手法やソフトウェアテストによるコントローラ開発については、<a href="#tdd">9 章「Trema でテスト駆動開発」</a>で解説します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_アップグレード方法の選択肢が広がる">1.4.4. アップグレード方法の選択肢が広がる</h4>
<div class="paragraph">
<p>従来のネットワーク機器を OpenFlow コントローラで置き換えれば、アップグレード方法の選択肢が広がります。従来のスイッチ・ルータ・ファイアウォールといったネットワーク機器では、ポート数を増やしたい場合にはワンランク上のハイエンドな機器との入れ換えが必要でした。これは、コストのかかる垂直方向のアップグレードです。しかし、ネットワーク機器を OpenFlow のコントローラとして汎用サーバ上にソフトウェア実装すれば、並べるサーバを増やすだけでポート数を増やせます。こうした水平方向へのアップグレードは垂直方向のアップグレードと比べて低コストで実現できます。</p>
</div>
<div class="paragraph">
<p>さらに、ネットワーク機器の機能アップグレードも、OpenFlow ではソフトウェアの書き換えで済みます。従来のようにワンランク上の高機能なネットワーク機器を購入するかわりに、新機能をコントローラにソフトウェアとして実装すればよいのです。</p>
</div>
<div class="paragraph">
<p>ただし、これらはもちろん<strong>自分で実装しなければならない</strong>という前提付きです。たとえば水平方向にサーバを増やす場合には、サーバ間での設定情報の同期や、一部のサーバがダウンした場合の障害復旧といった機能を自分で実装しなければなりません。また、ハイエンドなネットワーク機器の機能の中には、ソフトウェアによる実現がむずかしい複雑な機能もあるでしょう。これらを実現するには、既存の分散データベースといったミドルウェアを利用したり、OpenFlow で実装しやすい機能に置き換えたり、といった工夫が必要になります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>こうしたネットワーク機器の OpenFlow 実装については、<a href="#patch_panel">6 章「インテリジェントなパッチパネル」</a>・<a href="#learning_switch">7 章「すべての基本、ラーニングスイッチ」</a>・<a href="#learning_switch13">8 章「OpenFlow1.3 版ラーニングスイッチ」</a>・<a href="#firewall">11 章「ファイアウォール」</a>・<a href="#router_part1">12 章「ルータ (前編)」</a>・<a href="#router_part2">13 章「ルータ (後編)」</a>・<a href="#router13">14 章「ルータ (マルチプルテーブル編)」</a>でそれぞれ解説します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">OpenFlowは回転ずし</div>
<div class="paragraph">
<p>従来のファイアウォールやルータ、スイッチといった専用機器は、ベンダが提供する機能をそのまま使うしかありませんでした。たとえば、100 個ある機能のうち、本当に使いたい機能は 10 個だけだったとしても、100 機能付きのルータを買うしかありません。これではある意味、フルコースしか頼めないフレンチレストランのようなものです。一部の機能しか利用していないのに障害ポイントが無数にあるので、切り分けやデバッグが難航することもままあります。</p>
</div>
<div class="paragraph">
<p>OpenFlow は回転ずしです。フランス料理の味に近づけるのは大変ですが、必要な機能だけをチョイスしてがんばって実装すれば、思いどおりの機器が手に入るのです。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_openflowで気をつけること">1.5. OpenFlowで気をつけること</h3>
<div class="paragraph">
<p>もちろん、OpenFlow はうれしいことばかりではありません。コントローラで制御を一手に引き受けるため、コントローラの過負荷に気をつける必要があります。たとえばもし、フローテーブルに載っていないパケットが一気にコントローラへ到着すると、パケットの配送が遅延するか、最悪の場合にはコントローラが停止してしまいます。</p>
</div>
<div class="paragraph">
<p>そこで、OpenFlow の使いどころにはとくに注意する必要があります。たとえばフローエントリの入っていない OpenFlow スイッチをインターネットのような多種多様のパケットが流れる環境につなげると、すぐにコントローラへの問い合わせが殺到し破綻してしまいます。しかしデータセンターなどの閉じた環境では、トラフィックの特徴や流れるパケットの種類はあらかじめ見当を付けておけます。そこで最低限のパケットのみがコントローラへ上がってくるようにうまくフローエントリを設計することで、スイッチが増えてもうまくスケールできます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ">1.6. まとめ</h3>
<div class="paragraph">
<p>本章では SDN を実現する部品である OpenFlow を解説しました。OpenFlow で構築したネットワークは、フローテーブルを持つスイッチと、スイッチを集中制御するソフトウェアであるコントローラからなります。このようにネットワークの制御をソフトウェア化することによって、次の恩恵があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自動化やさまざまなシステムとの連携</p>
</li>
<li>
<p>トラフィック制御のしやすさ</p>
</li>
<li>
<p>ソフトウェア開発テクニックの適用</p>
</li>
<li>
<p>水平方向へのアップグレード</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次章では OpenFlow の仕様をもう少し詳しく紹介します。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="openflow_spec">2. OpenFlow の仕様</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>OpenFlow の概要がわかったところで、もう少し細かい仕様に進みましょう。実用重視で OpenFlow バージョン 1.3 仕様のポイントとよく使う用語を押さえます。</p>
</div>
<div class="sect2">
<h3 id="_説明する範囲とバージョン">2.1. 説明する範囲とバージョン</h3>
<div class="paragraph">
<p>OpenFlow標準仕様が主に定義するのは次の 2 つです。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>コントローラとスイッチの間の通信プロトコル</p>
</li>
<li>
<p>書き込んだフローエントリに対するスイッチの動作</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>本章ではこの 2 つの中でも、特によく使う機能のみを重点的に説明します。主に対象とするバージョンは、執筆時の安定バージョンであるバージョン 1.3 です。なお、バージョン 1.3 と以前の安定バージョンである 1.0 では、考え方やモデルに大きな違いはありません。そのため 1.3 を理解すれば 1.0 も理解しやすいでしょう。</p>
</div>
<div class="paragraph">
<p>なお OpenFlow が初めての方は、最初は難しい部分を読み飛ばしても構いません。後からより詳しく知りたくなった時に、いつでも読み直してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_スイッチとコントローラ間のやりとり">2.2. スイッチとコントローラ間のやりとり</h3>
<div class="paragraph">
<p>OpenFlow スイッチとコントローラは、OpenFlow 仕様の規定するメッセージをやりとりしながら動作します。ここでは具体的にどのようなメッセージを送受信するか、順を追って説明します。<a href="#how_does_openflow_work">1 章「OpenFlow の仕組み」</a>で見た、カスタマーサポートセンターでのやりとりを思い出しながら読んでください。</p>
</div>
<div class="sect3">
<h4 id="_スイッチ_コントローラ間の接続">2.2.1. スイッチ・コントローラ間の接続</h4>
<div class="paragraph">
<p>最初にコントローラとスイッチは TCP 接続を確立します。これを <strong>OpenFlow チャンネル</strong>と呼びます。この TCP 接続は、仕様によるとスイッチとコントローラのどちらが始めてもよいことになっています。しかし多くの場合、<a href="#openflow_channel">図 2-1</a> のようにスイッチからコントローラへと接続する実装となっています。</p>
</div>
<div id="openflow_channel" class="imageblock">
<div class="content">
<img src="images/openflow_spec/openflow_channel.png" alt="openflow channel">
</div>
<div class="title">図 2-1: スイッチがコントローラに接続し OpenFlow チャンネルを確立</div>
</div>
<div class="paragraph">
<p>なお OpenFlow チャンネルには普通の TCP 接続だけでなく、よりセキュアな TLS (Transport Layer Security) も使えます。ただし、コントローラとスイッチの両方が TLS に対応している必要があります。また、TLS は暗号化・復号化に多くのリソースを必要とするので、大量にメッセージをやりとりする場合には性能が低下します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_バージョンの確認">2.2.2. バージョンの確認</h4>
<div class="paragraph">
<p>次にスイッチとコントローラは、使う OpenFlow バージョンをお互いに確認します。これを一般にバージョンネゴシエーションと呼びます。OpenFlow チャンネルの確立後、スイッチとコントローラは自分のしゃべれるバージョン番号を乗せた <strong>Hello メッセージ</strong>をお互いに出し合います (<a href="#version_negotiation">図 2-2</a>)。</p>
</div>
<div id="version_negotiation" class="imageblock">
<div class="content">
<img src="images/openflow_spec/version_negotiation.png" alt="version negotiation">
</div>
<div class="title">図 2-2: Hello メッセージを出し合うことで、お互いの OpenFlow プロトコルバージョンを確認</div>
</div>
<div class="paragraph">
<p>もしここで、相手と同じバージョンを話せるようであればネゴシエーションに成功です。成功すると、Hello 以外のメッセージもやりとりできるようになります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_スイッチの_datapath_id_の確認">2.2.3. スイッチの Datapath ID の確認</h4>
<div class="paragraph">
<p>次にコントローラは接続したスイッチの Datapath ID を確認します。コントローラがスイッチに <strong>Features Request メッセージ</strong>を送ると、スイッチは Datapath ID とスペックを乗せた <strong>Features Reply メッセージ</strong>を返答します。</p>
</div>
<div id="features_request_reply" class="imageblock">
<div class="content">
<img src="images/openflow_spec/features_request_reply.png" alt="features request reply">
</div>
<div class="title">図 2-3: Features Request メッセージでスイッチの Datapath ID を確認</div>
</div>
<div class="paragraph">
<p>Features Reply メッセージには Datapath ID に加えて、主に次のスペック情報が入っています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一度にバッファできるパケットの数</p>
</li>
<li>
<p>サポートするテーブルの数</p>
</li>
<li>
<p>サポートする機能の一覧</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_コントローラへの受信パケットの通知">2.2.4. コントローラへの受信パケットの通知</h4>
<div class="paragraph">
<p>スイッチは、受信したパケットと関連情報を <strong>Packet In メッセージ</strong>でコントローラへ通知できます。たとえば、フローテーブルに登録していない通信を検知した場合など、Packet In メッセージを使ってパケットの情報をコントローラへ送ります (<a href="#packet_in">図 2-4</a>)。</p>
</div>
<div id="packet_in" class="imageblock">
<div class="content">
<img src="images/openflow_spec/packet_in.png" alt="packet in">
</div>
<div class="title">図 2-4: 受信パケットとその情報を Packet In メッセージとしてコントローラに上げる</div>
</div>
</div>
<div class="sect3">
<h4 id="_パケットの出力">2.2.5. パケットの出力</h4>
<div class="paragraph">
<p><strong>Packet Out メッセージ</strong>は Packet In メッセージの逆で、スイッチからパケットを出力するためのメッセージです (<a href="#packet_out">図 2-5</a>)。</p>
</div>
<div id="packet_out" class="imageblock">
<div class="content">
<img src="images/openflow_spec/packet_out.png" alt="packet out">
</div>
<div class="title">図 2-5: Packet Out メッセージでパケットをスイッチから出力</div>
</div>
<div class="paragraph">
<p>Packet Out の典型的な利用例は、Packet In でコントローラへ届いたパケットを宛先に届ける場合です。もしも Packet In の後に Packet Out をやらないと、パケットはコントローラに残ったままで宛先には届きません。</p>
</div>
</div>
<div class="sect3">
<h4 id="_フローテーブルの更新">2.2.6. フローテーブルの更新</h4>
<div class="paragraph">
<p><strong>Flow Mod メッセージ</strong>はスイッチのフローエントリを追加・削除・変更するためのメッセージです (<a href="#flow_mod">図 2-6</a>)。Flow Mod メッセージを受け取ったスイッチは、メッセージ内容に従って自身のフローテーブルを更新します。</p>
</div>
<div id="flow_mod" class="imageblock">
<div class="content">
<img src="images/openflow_spec/flow_mod.png" alt="flow mod">
</div>
<div class="title">図 2-6: Flow Mod メッセージでフローテーブルを更新</div>
</div>
<div class="paragraph">
<p>OpenFlow 仕様によると、スイッチはフローテーブルの更新完了をコントローラに通知しません。その理由は、もしも Flow Mod メッセージごとに応答メッセージを返すことにすると、多くのフローエントリを設定する場合に時間がかかってしまうためです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">禁じ手: Flow ModとPacket Outを同時にやる方法</div>
<div class="paragraph">
<p>実は OpenFlow の仕様には、1つの Flow Mod メッセージで同時に Packet Out もまとめてやってしまう方法があります。しかし、これは危険なプログラミングスタイルです。</p>
</div>
<div class="paragraph">
<p>この Flow Mod &amp; Packet Out は<a href="#flow_mod_and_packet_out">図 2-7</a> のように動作します。スイッチは Packet In を起こすと、スイッチのバッファ領域に Packet In を起こしたパケットの中身をバッファします。そしてコントローラに送る Packet In メッセージに、このバッファ領域の ID (Buffer ID と呼ぶ) 情報を入れて送ります。コントローラは Flow Mod のときにこの Buffer ID を指定すると、スイッチがフローテーブルの更新と同時に、コントローラの代わりに Packet Out してくれます。</p>
</div>
<div id="flow_mod_and_packet_out" class="imageblock">
<div class="content">
<img src="images/openflow_spec/flow_mod_and_packet_out.png" alt="flow mod and packet out">
</div>
<div class="title">図 2-7: Flow Mod に Buffer ID を指定することで同時に Packet Out する</div>
</div>
<div class="paragraph">
<p>しかし、この方法は<strong>禁じ手</strong>です。これは次の 3 つの理由によります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>スイッチのバッファにパケットが残っているかどうかはスイッチの外からわからない。つまり指定した Buffer ID のパケットがまだバッファに残っているかどうかは、イチかバチかである</p>
</li>
<li>
<p>もしスイッチのバッファに残っているとわかったとしても、Flow Mod を打った時には消えているかもしれない</p>
</li>
<li>
<p>格安のスイッチには、そもそもバッファがないかもしれない</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>というわけで、やはり Packet Out は Flow Mod と独立して打つのが良い方法です。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_フローテーブル更新完了の確認">2.2.7. フローテーブル更新完了の確認</h4>
<div class="paragraph">
<p>Flow Mod メッセージによるフローテーブルの更新完了を確認するには <strong>Barrier メッセージ</strong>を使います (<a href="#barrier">図 2-8</a>)。コントローラが <strong>Barrier Request メッセージ</strong>を送ると、それ以前に送った Flow Mod メッセージの処理が全て完了した後、スイッチは <strong>Barrier Reply メッセージ</strong>を返します。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openflow_spec/barrier.png" alt="barrier">
</div>
<div class="title">図 2-8: Barrier Request/Reply メッセージによってフローテーブルの更新完了を確認</div>
</div>
</div>
<div class="sect3">
<h4 id="_フローエントリ削除の通知">2.2.8. フローエントリ削除の通知</h4>
<div class="paragraph">
<p>フローエントリが消えると、消えたフローエントリーの情報は <strong>Flow Removed メッセージ</strong>としてコントローラに届きます。Flow Removed メッセージには、消えたフローエントリの内容とそのフローエントリにしたがって処理したパケットの統計情報が入っています。これを使えば、たとえばネットワークのトラフィック量の集計ができます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openflow_spec/flow_removed.png" alt="flow removed">
</div>
<div class="title">図 2-9: フローエントリが消えると、フローエントリの内容と転送したパケットの統計情報が Flow Removed としてコントローラへ上がる</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_フローエントリの中身">2.3. フローエントリの中身</h3>
<div class="paragraph">
<p><a href="#how_does_openflow_work">1章</a>で見たようにフローエントリは次の 6 要素から成ります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>優先度</p>
</li>
<li>
<p>カウンタ (統計情報)</p>
</li>
<li>
<p>タイムアウト (寿命)</p>
</li>
<li>
<p>クッキー</p>
</li>
<li>
<p>マッチフィールド</p>
</li>
<li>
<p>インストラクション</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_優先度">2.3.1. 優先度</h4>
<div class="paragraph">
<p>フローエントリには、優先度 (0 〜 65535) が設定できます。受信パケットが、フローテーブル中に複数のフローエントリにマッチする場合、この優先度の値が高いフローエントリが優先されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_カウンタ_統計情報">2.3.2. カウンタ (統計情報)</h4>
<div class="paragraph">
<p>OpenFlow 1.3 ではフローエントリごとにカウンタを持っており、次の統計情報を取得できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>受信パケット数</p>
</li>
<li>
<p>受信バイト数</p>
</li>
<li>
<p>フローエントリが作られてからの経過時間 (秒)</p>
</li>
<li>
<p>フローエントリが作られてからの経過時間 (ナノ秒)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_タイムアウト_寿命">2.3.3. タイムアウト (寿命)</h4>
<div class="paragraph">
<p>フローエントリにはタイムアウト (寿命) を設定できます。寿命の指定には次の 2 種類があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>アイドルタイムアウト: 参照されない時間がこの寿命に逹すると、そのフローエントリを消す。パケットが到着し、フローエントリが参照された時点で 0 秒にリセットされる。</p>
</li>
<li>
<p>ハードタイムアウト: 参照の有無を問わず、フローエントリが書き込まれてからの時間がこの寿命に逹すると、そのフローエントリを消す。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>どちらのタイムアウトも 0 にして打ち込むと、そのフローエントリは明示的に消さない限りフローテーブルに残ります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_クッキー">2.3.4. クッキー</h4>
<div class="paragraph">
<p>フローエントリには、クッキーを設定できます。クッキーに設定された値は、スイッチにおけるパケット処理には全く影響を与えません。例えば、フローエントリを管理するために、コントローラがクッキーフィールドに管理用の ID を付与するといった使い方ができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_マッチフィールド">2.3.5. マッチフィールド</h4>
<div class="paragraph">
<p>マッチフィールドとは、OpenFlow スイッチがパケットを受け取ったときにアクションを起こすかどうかを決める条件です。たとえば「パケットの宛先が http サーバだったら」とか「パケットの宛先がブロードキャストアドレスだったら」などという条件に適合したパケットにだけ、スイッチがアクションを起こすというわけです。</p>
</div>
<div class="paragraph">
<p>OpenFlow 1.3 では、40 種類の条件が使えます。主な条件を <a href="#matching_rules">表2-1</a> に示します。これらの条件はイーサネットや TCP/UDP でよく使われる値です。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">コラム マッチフィールドの別名</div>
<div class="paragraph">
<p>OpenFlow が使われ始めたころ、フローエントリの要素の1つであるマッチフィールドには、"OpenFlow 12 タプル"、"ヘッダフィールド" 等、さまざまな別の呼び方がありました。混乱を避けるため、本書の前版では "マッチングルール" という呼び方に統一しました。パケットがきたときにルールに従ってマッチする、という役割をすなおに表現していて、いちばんわかりやすい名前だったからです。</p>
</div>
<div class="paragraph">
<p>その後、OpenFlow バージョン 1.3 で正式な呼び名が "マッチフィールド" に決まりました。そのため、本書では仕様に従い "マッチフィールド" という呼び方を使っています。</p>
</div>
</td>
</tr>
</table>
</div>
<table id="matching_rules" class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. マッチフィールドで指定できる主な条件</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名前</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">In Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">スイッチの論理ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">In Phy Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">スイッチの物理ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ether Src</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元 MAC アドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ether Dst</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先 MAC アドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ether Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">イーサネットの種別</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN Priority</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN PCP の値 (CoS)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP DSCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DiffServ コードポイント</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP ECN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP ECN ビット</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP Src</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元 IP アドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP Dst</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先 IP アドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP Proto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP のプロトコル種別</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP Src Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP の送信元ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP Dst Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP の宛先ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP Src Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP の送信元ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP Dst Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP の宛先ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMPv4 Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMP 種別</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMPv4 Code</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMP コード</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 Src</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元 IPv6 アドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 Dst</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先 IPv6 アドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 Flowlabel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 フローラベル</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMPv6 Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMPv6 種別</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMPv6 Code</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ICMPv6 コード</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPLS Label</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPLS ラベル</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPLS TC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPLS トラフィッククラス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PBB ISID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PBB ISID</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>OpenFlow の世界では、このマッチフィールドで指定できる条件を自由に組み合わせて通信を制御します。たとえば、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>スイッチの物理ポート 1 番から届く、宛先が TCP 80 番 (= HTTP) のパケットを書き換える</p>
</li>
<li>
<p>MAC アドレスが 02:27:e4:fd:a3:5d で宛先の IP アドレスが 192.168.0.0/24 は遮断する</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>などといった具合です。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">OSI ネットワークモデルが壊れる？</div>
<div class="paragraph">
<p>あるネットワークの経験豊富な若者がこんな事を言っていました。</p>
</div>
<div class="paragraph">
<p>「OpenFlow のようにレイヤをまたがって自由に何でもできるようになると、OSI ネットワークモデル(よく「レイヤ 2」とか「レイヤ 3」とか呼ばれるアレのこと。正確には ISO によって制定された、異機種間のデータ通信を実現するためのネットワーク構造の設計方針)が壊れるんじゃないか？」</p>
</div>
<div class="paragraph">
<p>その心配は無用です。OSI ネットワークモデルは正確に言うと「OSI 参照モデル」と言って、通信プロトコルを分類して見通しを良くするために定義した "参照用" の階層モデルです。たとえば自分が xyz プロトコルというのを作ったけど人に説明したいというときに、どう説明するか考えてみましょう。「これはレイヤ 3 のプロトコルで、…」という風に階層を指して (参照して) 説明を始めれば相手に通りがよいでしょう。つまり、OSI ネットワークモデルはネットワーク屋同士で通じる「語彙」として使える、まことに便利なものなのです。</p>
</div>
<div class="paragraph">
<p>でも、これはあくまで「参照」であって「規約」ではないので、すべてのネットワークプロトコル、ネットワーク機器がこれに従わなければいけない、というものではありません。さっき言ったように「この ○○ は、仮に OSI で言うとレイヤ4 にあたる」のように使うのが正しいのです。</p>
</div>
<div class="paragraph">
<p>そして、OpenFlow はたまたまいくつものレイヤの情報が使える、ただそれだけのことです。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_インストラクション">2.3.6. インストラクション</h4>
<div class="paragraph">
<p>インストラクションには、そのフローエントリにマッチしたパケットを、次にどのように扱うかを指定します。OpenFlow 1.3 では主に、以下のインストラクションを利用可能です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apply-Actions: 指定されたアクションを実行します。</p>
</li>
<li>
<p>Write-Actions: 指定されたアクションをアクションセットに追加します。</p>
</li>
<li>
<p>Clear-Actions: アクションセット中のアクションをすべてクリアします。</p>
</li>
<li>
<p>Write-Metadata: 受信したパケットに、メタデータを付与します。</p>
</li>
<li>
<p>Goto-Table: 指定のフローテーブルに移動します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらのうち Write-Actions, Clear-Actions, Write-Metadata, Goto-Table は、マルチプルテーブルを使う際に用いるインストラクションです。そのため、マルチプルテーブルを説明する際に、合わせて詳しく説明します。</p>
</div>
<div class="paragraph">
<p>Apply-Actions にて指定するアクションとは、スイッチに入ってきたパケットをどう料理するか、という <strong>動詞</strong> にあたる部分です。よく「OpenFlow でパケットを書き換えて曲げる」などと言いますが、こうした書き換えなどはすべてアクションで実現できます。OpenFlow 1.3 では、次の 7 種類のアクションがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Output: パケットを指定したポートから出す</p>
</li>
<li>
<p>Group: パケットに対し、指定したグループテーブルの処理を適用する</p>
</li>
<li>
<p>Drop: パケットを捨てる</p>
</li>
<li>
<p>Set-Queue: ポートごとに指定されたスイッチのキューに入れる。QoS 用</p>
</li>
<li>
<p>Push-Tag/Pop-Tag: パケットに対し MPLS/VLAN タグの付与/除去を行う</p>
</li>
<li>
<p>Set-Field: 指定のフィールドの中身を書き換える</p>
</li>
<li>
<p>Change-TTL: TTL フィールドの値を書き換える</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>アクションは動詞と同じく指定した順番に実行されます。「おにぎりを作って、食べて、片付ける」といったふうに。たとえば、パケットを書き換えて指定したポートから出したいときには、</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Set-Field, Output]</pre>
</div>
</div>
<div class="paragraph">
<p>と、複数のアクション並べて指定します。この実行順に並べられた複数のアクションのことを、アクションリストと呼びます。Apply-Actions インストラクションや Write-Actions インストラクションには、アクションリストを用いることで、複数のアクションを指定できます。</p>
</div>
<div class="paragraph">
<p>ここで、アクションリストは指定された順番に実行されることに注意してください。アクションリストの順番を変えてしまうと、違う結果が起こります。たとえば「おにぎりを食べてから、おにぎりを作る」と最後におにぎりが残ってしまいます。同様に先ほどの例を逆にしてしまうと、まず先にパケットがフォワードされてしまいます。その後 Set-Field が実行されても、書き換えられた後、そのパケットは破棄されるだけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre># パケットを書き換える前にフォワードされてしまう。
[Output, Set-Field]</pre>
</div>
</div>
<div class="paragraph">
<p>同じ動詞を複数指定することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Set-Field A, Set-Field B, Output A, Output B]</pre>
</div>
</div>
<div class="paragraph">
<p>この場合は、フィールド A と B を書き換えて、ポート A と B へフォワードする、と読めます。このように、複数のフィールドを書き換えたり、複数のポートにパケットを出したりする場合には、アクションを複数連ねて指定します<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnote_5" title="View footnote.">5</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>Drop は特殊なアクションで、実際に Drop アクションというものが具体的に定義されているわけではありません。アクションのリストに Output アクションを1つも入れなかった場合、そのパケットはどこにもフォワードされずに捨てられます。これを便宜的に Drop アクションと呼んでいるわけです。</p>
</div>
<div class="paragraph">
<p>それでは、もっともよく使われる Output アクションと Set-Field アクションで具体的に何が指定できるか見て行きましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_output_アクション">2.3.7. Output アクション</h4>
<div class="paragraph">
<p>Output アクションでは指定したポートからパケットを出力します。出力先にはポート番号を指定しますが、特殊用途のために定義されている論理ポートを使うこともできます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ポート番号: パケットを指定した番号のポートに出す。</p>
</li>
<li>
<p>IN_PORT: パケットを入ってきたポートに出す。</p>
</li>
<li>
<p>ALL: パケットを入ってきたポート以外のすべてのポートに出す。</p>
</li>
<li>
<p>FLOOD: パケットをスイッチが作るスパニングツリーに沿って出す。</p>
</li>
<li>
<p>CONTROLLER: パケットをコントローラに明示的に送り、Packet In を起こす。</p>
</li>
<li>
<p>NORMAL: パケットをスイッチの機能を使って転送する。</p>
</li>
<li>
<p>LOCAL: パケットをスイッチのローカルスタックに上げる。ローカルスタック上で動作するアプリケーションにパケットを渡したい場合に使う。あまり使われない。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この中でも FLOOD や NORMAL は OpenFlow スイッチ機能と既存のスイッチ機能を組み合わせて使うための論理ポートです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_set_field_アクション">2.3.8. Set-Field アクション</h4>
<div class="paragraph">
<p>Set-Field アクションでは、パケットのさまざまな部分を書き換えられます。パケットで書き換えられるフィールドは、マッチフィールドで指定可能なフィールドと同じです (<a href="#matching_rules">表2-1</a>)。例えば、以下に示す書き換えが可能です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>送信元/宛先 MAC アドレスの書き換え</p>
</li>
<li>
<p>送信元/宛先 IP アドレスの書き換え</p>
</li>
<li>
<p>ToS フィールドの書き換え</p>
</li>
<li>
<p>TCP/UDP 送信元/宛先ポートの書き換え</p>
</li>
<li>
<p>VLAN ID/プライオリティの書き換え</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>それでは Set-Field アクションの代表的な使い道を順に見ていきましょう。</p>
</div>
<div class="sect4">
<h5 id="_mac_アドレスの書き換え">MAC アドレスの書き換え</h5>
<div class="paragraph">
<p>MAC アドレス書き換えの代表的な例がルータです。OpenFlow はルータの実装に必要な、送信元と宛先 MAC アドレスの書き換えをサポートしています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openflow_spec/rewrite_mac.png" alt="rewrite mac">
</div>
<div class="title">図 2-10: ルータでの送信元と宛先 MAC アドレスの書き換え</div>
</div>
<div class="paragraph">
<p>ルータは 2 つのネットワークの間で動作し、ネットワーク間で行き交うパケットの交通整理を行います。ホスト A が異なるネットワークに属するホスト B にパケットを送ると、ルータはそのパケットを受け取りその宛先 IP アドレスから転送先のネットワークを決定します。そして、パケットに記述された宛先 MAC アドレスを次に送るべきホストの MAC アドレスに、送信元を自分の MAC アドレスに書き換えてデータを転送します。</p>
</div>
</div>
<div class="sect4">
<h5 id="_ip_アドレスの書き換え">IP アドレスの書き換え</h5>
<div class="paragraph">
<p>IP アドレス書き換えの代表的な例が NAT (Network Address Transition) です。OpenFlow は NAT の実装に必要な、送信元と宛先 IP アドレスの書き換えをサポートしています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openflow_spec/rewrite_ip_address.png" alt="rewrite ip address">
</div>
<div class="title">図 2-11: NAT での送信元と宛先 IP アドレスの書き換え</div>
</div>
<div class="paragraph">
<p>インターネットと接続するルータでは、プライベート/グローバルネットワーク間での通信を通すために IP アドレスを次のように変換します。プライベートネットワーク内のクライアントからインターネット上のサーバに通信をする場合、ゲートウェイはプライベートネットワークから届いたパケットの送信元 IP アドレスを自分のグローバルな IP アドレスに変換して送信します。逆にサーバからの返信は逆の書き換えを行うことによりプライベートネットワーク内のクライアントに届けます。</p>
</div>
</div>
<div class="sect4">
<h5 id="_tos_フィールドの書き換え">ToS フィールドの書き換え</h5>
<div class="paragraph">
<p>ToS フィールドは通信のサービス品質 (QoS) を制御する目的でパケットを受け取ったルータに対して処理の優先度を指定するために使われます。OpenFlow はこの ToS フィールドの書き換えをサポートしています。</p>
</div>
</div>
<div class="sect4">
<h5 id="_tcp_udp_ポート番号の書き換え">TCP/UDP ポート番号の書き換え</h5>
<div class="paragraph">
<p>TCP/UDP ポート番号書き換えの代表的な例が IP マスカレードです。OpenFlow は IP マスカレードの実装に必要な、送信元と宛先の TCP/UDP ポート番号の書き換えをサポートしています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openflow_spec/rewrite_port.png" alt="rewrite port">
</div>
<div class="title">図 2-12: IP マスカレードでの送信元と宛先 TCP/UDP ポート番号の書き換え</div>
</div>
<div class="paragraph">
<p>ブロードバンドルータなど 1 つのグローバルアドレスで複数のホストが同時に通信を行う環境では、NAT だけだと TCP/UDP のポート番号が重複する可能性があります。そこで、IP マスカレードではプライベートネットワーク側のポート番号をホストごとに適当に割り当て、通信のつどポート番号を変換することで解決します。</p>
</div>
</div>
<div class="sect4">
<h5 id="_vlan_ヘッダの書き換え">VLAN ヘッダの書き換え</h5>
<div class="paragraph">
<p>既存のタグ付き VLAN で構築したネットワークと OpenFlow で構築したネットワークを接続するという特別な用途のために、VLAN ヘッダの書き換えができます。VLAN をひとことで説明すると、既存のスイッチで構成されるネットワーク (ブロードキャストが届く範囲のネットワーク) を複数のネットワークに分割して使用するための仕組みです。この分割したネットワーク自体を VLAN と呼ぶ場合もあります。どの VLAN に所属するかを区別するのが VLAN ID で、パケットに付与される VLAN タグがこの VLAN ID を含みます。Set-Field アクションを用いることで、以下に示す 2 種類の VLAN ヘッダ操作ができます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openflow_spec/strip_vlan.png" alt="strip vlan">
</div>
<div class="title">図 2-13: VLAN ヘッダを書き換えるアクションの使い道</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">VLAN ID の書き換え</dt>
<dd>
<p>VLAN パケットが属する VLAN の ID を書き換えます。たとえば VLAN ID を 3 に書き換えるといったアクションを指定できます。また、VLAN ヘッダがついていないパケットに 指定した VLAN ID を持つ VLAN ヘッダを付与することもできます。</p>
</dd>
<dt class="hdlist1">VLAN プライオリティの書き換え</dt>
<dd>
<p>VLAN 上でのパケットを転送する優先度を変更します。このプライオリティはトラフィックの種類 (データ、音声、動画など) を区別する場合などに使います。指定できる値は 0 (最低) から 7 (最高) までです。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_change_ttl_アクション">2.3.9. Change-TTL アクション</h4>
<div class="paragraph">
<p>Chante-TTL アクションは、パケット中の TTL (Time-To-Live) の値を変更するためのアクションです。TTL は、なんらかの不具合によりネットワーク中でパケットがループすることを防ぐための仕組みです。パケットを受信したネットワーク機器は、ヘッダ中の TTL の値を一つ減らしてからパケットを転送します。もし、受信したパケットの TTL の値が 0 だった場合、そのパケットを破棄します。このようにすることで、パケットがループ中を転送され続けることを防ぎます。Change-TTL アクションでは、以下に示す TTL の書き換えが可能です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MPLS ヘッダの TTL に指定の値を設定 (Set MPLS TTL)</p>
</li>
<li>
<p>IP ヘッダの TTL に指定の値を設定 (Set IP TTL)</p>
</li>
<li>
<p>MPLS ヘッダの TTL の値を一つ減算 (Decrement MPLS TTL)</p>
</li>
<li>
<p>IP ヘッダの TTL の値を一つ減算 (Decrement IP TTL)</p>
</li>
<li>
<p>内側ヘッダの TTL の値を外側ヘッダの TTL のフィールドにコピー (Copy TTL outwards)</p>
</li>
<li>
<p>外側ヘッダの TTL の値を内側ヘッダの TTL のフィールドにコピー (Copy TTL inwards)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例えば、内側が IP ヘッダで外側が MPLS ヘッダである時、Copy TTL outwards では、IP ヘッダの TTL 値を MPLS ヘッダの TTL のフィールドに設定します。一方、Copy TTL inwards では、MPLS ヘッダの TTL 値を IP ヘッダの TTL のフィールドに設定します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_マルチプルテーブル">2.4. マルチプルテーブル</h3>
<div class="paragraph">
<p>OpenFlow バージョン 1.3 では、OpenFlow スイッチがフローテーブルを複数持てます。この複数のフローテーブルのことを、マルチプルテーブルと呼びます。マルチプルテーブルをうまく活用することで、複雑なパケット処理を行えます。</p>
</div>
<div class="paragraph">
<p>宮坂部長グループの社内ネットワーク運用について考えてみましょう(<a href="#multiple_table_example">図 2-14</a>)。</p>
</div>
<div id="multiple_table_example" class="imageblock">
<div class="content">
<img src="images/openflow_spec/multiple_table_example.png" alt="multiple table example">
</div>
<div class="title">図 2-14: 宮坂部長グループの社内ネットワーク</div>
</div>
<div class="ulist">
<ul>
<li>
<p>宮坂部長 (192.168.0.1) の端末からのパケットは、MailとWebのトラフィックの場合のみ、ポート 2 に出力したい。</p>
</li>
<li>
<p>一般社員の端末 (192.168.0.2 ～ 192.168.0.254) からは、すべてのトラフィックを、ポート 2 に出力したい。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mail のトラフィックを許可する場合には、TCP で Destination Port 番号が 25 と 110 のパケットを通過するようにします。同様に Web では、TCP で Destination Port 番号 80 と 443 を許可します。</p>
</div>
<div class="paragraph">
<p>これをフローテーブルに設定すると、<a href="#table0_1">表2-2</a> の様になります。先頭の 5 つのが宮坂部長の端末 (192.168.0.1) からのパケット向けのフローエントリです。</p>
</div>
<table id="table0_1" class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. マルチプルテーブルを使わない場合のフローテーブルの例1</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
<th class="tableblock halign-left valign-top">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宮坂部長用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Drop)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.0/24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一般社員用</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>宮坂部長の仕事が多くなったため、事務員を雇うことになりました。事務員は宮坂部長の業務を手伝う必要があるため、事務員に割り当てられた端末 (192.168.0.2) は宮坂部長の端末と同じポリシーで運用することとします。この場合、フローテーブルを <a href="#table0_2">表2-3</a> のように書き換える必要があります。</p>
</div>
<table id="table0_2" class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. マルチプルテーブルを使わない場合のフローテーブルの例2</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
<th class="tableblock halign-left valign-top">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宮坂部長用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32, dst_port = 443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Drop)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.2/32, dst_port = 25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事務員用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.2/32, dst_port = 110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.2/32, dst_port = 80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.2/32, dst_port = 443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.2/32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Drop)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.0/24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一般社員用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wildcard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Drop)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="#table0_1">表2-2</a> と <a href="#table0_2">表2-3</a> を比較すると、フローエントリが 5 つ増えているのがわかります。もし事務員をもう一人雇うことになった場合、さらに 5 つのエントリを追加する必要があります。</p>
</div>
<div class="paragraph">
<p>このようにフローテーブルの内容が複雑になるケースでも、マルチプルテーブルを使うことですっきりできます。まず Table1 の内容は <a href="#table1">表2-4</a> の様になります。宮坂部長および事務員の端末からのパケットを、TCP のポート番号を見てからどのように処理するか判断すべきです。そのための判断をするために、これらのパケットは次に Table 2 を見るように Goto-Table インストラクションが指定されています。</p>
</div>
<table id="table1" class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. マルチプルテーブルを使う場合のフローテーブルの例 1 (Table1)</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
<th class="tableblock halign-left valign-top">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.1/32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宮坂部長用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.2/32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事務員用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.0.0/24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一般社員用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wildcard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Drop)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Table2 の内容は、<a href="#table2">表2-5</a> のようになっています。このテーブルを参照するのは、宮坂部長、事務員の端末からのパケットが到着した場合のみなので、あとは Mail, Web のトラフィックのみ通過できるようなエントリを記述すれば良いことになります。</p>
</div>
<table id="table2" class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. マルチプルテーブルを使う場合のフローテーブルの例 2 (Table2)</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
<th class="tableblock halign-left valign-top">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dst_port = 25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宮坂部長、事務員用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dst_port = 110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dst_port = 80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dst_port = 443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wildcard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Drop)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>マルチプルテーブルを使ったほうが、<a href="#table0_2">図2-3</a> と比べ、シンプルになることがわかります。もし、事務員をもう一人雇うことになった場合でも、Table1 に一つエントリを追加するだけで済みます。</p>
</div>
<div class="sect3">
<h4 id="_write_actions_と_clear_actions">2.4.1. Write-Actions と Clear-Actions</h4>
<div class="paragraph">
<p>Apply-Actions に指定されたアクションは、フローテーブルが参照された段階で即座に実行されます。一方で、Write-Actions を使うと、一旦アクションセットに格納されます。そしてフローテーブルの参照が全て終わった段階で、アクションセットに格納されたアクションが実行されます。</p>
</div>
<div class="paragraph">
<p>例えば、<a href="#table_write_action1">表2-6</a> と <a href="#table_write_action2">表2-7</a> のようにフローエントリが格納されていたとします。宛先ポート番号 25 のパケットを受信した時、このパケットは Table1 の 1 番目のエントリにマッチします。そのため、Write-Actions インストラクションで指定されている Set-Field A というアクションがアクションセットに格納されます。1 番目のエントリには、Goto-Table インストラクションも指定されていますので、次に Table2 の参照を行います。受信パケットは Table2 の 1 番目のエントリにもマッチしますので、同様にアクションセットに Output 2 というアクションが格納されます。最終的にアクションセットには、Set-Field A および Output 2 という二つのアクションが格納されている状態になります。</p>
</div>
<table id="table_write_action1" class="tableblock frame-all grid-all spread">
<caption class="title">Table 10. Write-Actions を含むフローテーブルの例 1 (Table1)</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dst_port = 25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Actions (Set-Field A), Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dst_port = 110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Actions (Set-Field B), Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
</tbody>
</table>
<table id="table_write_action2" class="tableblock frame-all grid-all spread">
<caption class="title">Table 11. Write-Actions を含むフローテーブルの例 2 (Table2)</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wildcard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>アクションセットに格納された複数のアクションは、次の優先順位に従って実行されます。格納された順に実行されるわけではない点に注意が必要です。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>copy TTL inwards : 外側ヘッダの TTL を内側ヘッダの TTL へコピーするアクションを実行します。</p>
</li>
<li>
<p>pop : 指定されたタグを除去するアクションを実行します。</p>
</li>
<li>
<p>push-MPLS : MPLS tag をパケットに付与するアクションを実行します。</p>
</li>
<li>
<p>push-PBB : PBB tag をパケットに付与するアクションを実行します。</p>
</li>
<li>
<p>push-VLAN : VLAN tag をパケットに付与するアクションを実行します。</p>
</li>
<li>
<p>copy TTL outwards : 内側ヘッダの TTL を外側ヘッダの TTL へコピーするアクションを実行します。</p>
</li>
<li>
<p>decrement TTL : TTL を 1 減らすアクションを実行します。</p>
</li>
<li>
<p>set : Set-Field アクションを実行します。</p>
</li>
<li>
<p>qos : Set-Queue アクションを実行します。</p>
</li>
<li>
<p>group : Group アクションを実行します。</p>
</li>
<li>
<p>output : group の指定がない場合のみ、Output アクションを実行します。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#table_write_action1">表2-6</a> と <a href="#table_write_action2">表2-7</a> で示した例の場合、Output アクションより優先度が高い Set-Field アクションが先に実行され、その後 Output アクションが実行されます。</p>
</div>
<div class="paragraph">
<p>アクションセットは、一連の処理が終わった後にクリアされます。前に受信したパケットのアクションがアクションセットに入ったままになり、次のパケットの処理に用いられることは起こりません。</p>
</div>
<div class="paragraph">
<p>マルチプルテーブルを使ったパケットの処理中であっても、Clear-Actions インストラクションを使うことで、アクションセットの中身をクリアできます。Clear-Actions インストラクションを使えば、Write-Actions で格納したアクションをアクションセット中から全て消去できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_メタデータの利用">2.4.2. メタデータの利用</h4>
<div class="paragraph">
<p>Write-Metadata インストラクションを使って、メタデータを付与できます。付与されたメタデータは、Goto-Table インストラクションで次のフローテーブルを参照する際に、マッチフィールドの一部として利用できます。</p>
</div>
<div class="paragraph">
<p>例えば、送信元 IP アドレスが 192.168.1.101, 102 の場合、宛先ポート番号が 25, 110 のパケットのみをポート 2 から出力し、また送信元 IP アドレスが 192.168.1.103, 104 の場合、宛先ポートが 80, 443 のパケットのみをポート 2 から出力することを考えます。この例をメタデータを使って実現したのが <a href="#table_metadata1">表2-8</a> と <a href="#table_metadata2">表2-9</a> です。</p>
</div>
<div class="paragraph">
<p><a href="#table_metadata1">表2-8</a> には、送信元 IP アドレスをマッチとしたフローエントリが格納しています。<a href="#table_metadata2">表2-9</a> には、宛先ポートをマッチとしたフローエントリが格納されています。このように、メタデータを用いることで、複雑な条件であっても、シンプルなフローエントリの組み合わせで設定できます。</p>
</div>
<table id="table_metadata1" class="tableblock frame-all grid-all spread">
<caption class="title">Table 12. メタデータを含むフローテーブルの例 1 (Table1)</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.1.101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Metadata 1, Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.1.102</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Metadata 1, Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.1.103</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Metadata 2, Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src_ip = 192.168.1.104</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-Metadata 2, Goto-Table 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
</tbody>
</table>
<table id="table_metadata2" class="tableblock frame-all grid-all spread">
<caption class="title">Table 13. メタデータを含むフローテーブルの例 2 (Table2)</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">マッチ</th>
<th class="tableblock halign-left valign-top">インストラクション</th>
<th class="tableblock halign-left valign-top">優先度</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">metadata = 1, dst_port = 25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">metadata = 1, dst_port = 110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">metadata = 2, dst_port = 80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">metadata = 2, dst_port = 443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apply-Actions (Output 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>メタデータは 64bit 長のビット列で、初期値は All 0 です。Write-Matadata インストラクションは、各ビットの値を変更します。Write-Metadata インストラクションを使うときは、値とマスクの組を指定します。マスクで指定されたビットの値がメタデータに反映されます。</p>
</div>
<div class="paragraph">
<p>例を使って説明します。実際にはメタデータは 64bit ですが、ここでは 8bit であるとします。メタデータの現在の値が 11111111 であり、Write-Metadata インストラクションでの指定した値は 00001010、マスクは 00001111 であったとします。マスクは下位 4bit が 1 であるため、値の下位 4bit 分だけをメタデータに反映します。その結果、メタデータは 11111010 となります。</p>
</div>
<div class="paragraph">
<p>また、メタデータをマッチフィールドで用いる場合にも、値とマスクを指定します。マスクで指定されたビットのみ、マッチに用います。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_2">2.5. まとめ</h3>
<div class="paragraph">
<p>OpenFlow 仕様の中でもとくにポイントとなる部分を見てきました。ここまでの章で学んできた内容だけで、すでに OpenFlow 専門家と言ってもよいほどの知識が身に付いたはずです。次の章では OpenFlow コントローラを開発するためのプログラミングフレームワークである Trema (トレマ) に触れてみましょう。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hello_trema">3. Hello, Trema!</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p><strong>Trema(トレマ)</strong>を使うと楽しくSDNの世界が味わえます。これでいよいよあなたもOpenFlowプログラマの仲間入りです!</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hello_trema/izakaya.png" alt="izakaya">
</div>
</div>
<div class="sect2">
<h3 id="_作ってわかるopenflow">3.1. 作ってわかるOpenFlow</h3>
<div class="paragraph">
<p>いよいよOpenFlowを使ってネットワークを実際にプログラムしていきます。職場や自宅のような小規模ネットワークでもすぐに試せるコードを通じ、OpenFlowの世界を体験しましょう。実際に手を動かし実行してみれば「OpenFlowってどんな場面で使えるの?」というよくある疑問も徐々に氷解していくでしょう。</p>
</div>
<div class="paragraph">
<p>実装はステップバイステップで進みます。最初はOpenFlowやプログラミングの基礎から始めます。そしてパッチパネルやイーサネットスイッチ、ファイアウォール、ルータの実装など徐々に複雑な機能へとステップアップしていきます。そして最終的には、データセンターでも動く本格的なネットワーク仮想化の実装を目標とします。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Hello Trema (本章)</dt>
<dd>
<p>OpenFlow 版 Hello World</p>
</dd>
<dt class="hdlist1">スイッチ監視ツール (<a href="#switch_monitor">4章</a>)</dt>
<dd>
<p>スイッチの死活監視ツール</p>
</dd>
<dt class="hdlist1">Cbenchベンチマーク (<a href="#cbench">5章</a>)</dt>
<dd>
<p>OpenFlow のマイクロベンチマークツール</p>
</dd>
<dt class="hdlist1">パッチパネル (<a href="#patch_panel">6章</a>)</dt>
<dd>
<p>ソフトウェアとして実装したインテリジェント・パッチパネル</p>
</dd>
<dt class="hdlist1">ラーニングスイッチ (<a href="#learning_switch">7章</a>)</dt>
<dd>
<p>イーサネットスイッチをエミュレートするコントローラ</p>
</dd>
<dt class="hdlist1">ラーニングスイッチ OpenFlow1.3 (<a href="#learning_switch13">8章</a>)</dt>
<dd>
<p>ラーニングスイッチの OpenFlow1.3 による実装</p>
</dd>
<dt class="hdlist1">テスト駆動開発 (<a href="#tdd">9章</a>)</dt>
<dd>
<p>コントローラのテスト駆動開発</p>
</dd>
<dt class="hdlist1">ブリッジ (<a href="#one_way_bridge">10章</a>)</dt>
<dd>
<p>レガシーなネットワークとOpenFlowネットワークのブリッジ</p>
</dd>
<dt class="hdlist1">ファイアウォール (<a href="#firewall">11章</a>)</dt>
<dd>
<p>透過型ファイアウォール</p>
</dd>
<dt class="hdlist1">ルータ (<a href="#router_part1">12章</a>,<a href="#router_part2">13章</a>,<a href="#router13">14章</a>)</dt>
<dd>
<p>基本的なレイヤ3スイッチ (ルータ)</p>
</dd>
<dt class="hdlist1">トポロジ (<a href="#topology">15章</a>)</dt>
<dd>
<p>中規模〜大規模ネットワークのトポロジ検知</p>
</dd>
<dt class="hdlist1">ルーティングスイッチ (<a href="#routing_switch">16章</a>)</dt>
<dd>
<p>中規模〜大規模ネットワーク用の仮想レイヤ2スイッチ</p>
</dd>
<dt class="hdlist1">ネットワークスライス (<a href="#sliceable_switch">17章</a>)</dt>
<dd>
<p>ルーティングスイッチに仮想ネットワーク機能を追加</p>
</dd>
<dt class="hdlist1">OpenVNet (<a href="#openvnet">18章</a>)</dt>
<dd>
<p>Tremaベースの商用SDN</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>まずは、OpenFlowプログラミングのためのフレームワーク、Tremaを改めて紹介します。</p>
</div>
</div>
<div class="sect2">
<h3 id="_tremaとは">3.2. Tremaとは</h3>
<div class="paragraph">
<p>TremaはOpenFlowコントローラを開発するためのフリーソフトウェアです。GitHub上でオープンに開発を進める、GPL2ライセンスのフリーソフトウェアです。その強力な機能や使いやすさから、国内外の企業・大学・研究機関などの幅広い組織が採用しています。</p>
</div>
<div class="paragraph">
<p>Tremaの情報はおもに次のURLから入手できます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Tremaホームページ</dt>
<dd>
<p><a href="https://trema.github.com/trema/" class="bare">https://trema.github.com/trema/</a></p>
</dd>
<dt class="hdlist1">GitHubのプロジェクトページ</dt>
<dd>
<p><a href="https://github.com/trema/" class="bare">https://github.com/trema/</a></p>
</dd>
<dt class="hdlist1">メーリングリスト</dt>
<dd>
<p><a href="http://groups.google.com/group/trema-dev/" class="bare">http://groups.google.com/group/trema-dev/</a></p>
</dd>
<dt class="hdlist1">Twitterアカウント</dt>
<dd>
<p><a href="https://twitter.com/trema_news" class="bare">https://twitter.com/trema_news</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Tremaの特徴はRuby on Rails<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnote_6" title="View footnote.">6</a>]</sup>と同じく「プログラミングフレームワーク」を謳っていることです。でも、プログラミングフレームワークとはいったい何でしょうか。</p>
</div>
<div class="paragraph">
<p>Webサービスの世界では、90年代半ばには原始的なプログラミングが開発の主流でした。HTTPプロトコルを意識した低レベルなCGIをCやPerlで書かねばならず、ごく単純な掲示板サービスを作るのにも大量のコーディングが伴いました。</p>
</div>
<div class="paragraph">
<p>しかし2000年代に入り状況は一変します。より生産性の高い開発手法の登場 — プログラミングフレームワークによるアジャイル開発 — によって一気にWebサービスは「カンブリア爆発」を迎えました。Railsを代表とするWebプログラミングフレームワークは、HTTPプロトコルの詳細を抽象化した高レベルなAPIを提供します。また、RubyやPythonをはじめとするスクリプティング言語の採用や、開発全体をラップトップPC1台で完結できる数々の開発支援ツールの提供によって、生産性を劇的に向上します。</p>
</div>
<div class="paragraph">
<p>この流れをOpenFlow界にも吹き込んだのがTremaです。Tremaは「OpenFlow版Rails」を合言葉として、2011年に初のOpenFlowプログラミングフレームワークとして登場しました。開発言語にはRailsと同じくRubyを採用し、また高レベルなOpenFlow APIを提供することで、プログラマはごく短いコードでOpenFlowコントローラを実装できます。また強力なOpenFlow開発ツール群を提供することで、ソフトウェアテストを中心とした反復的で段階的なアジャイル開発を可能にします。</p>
</div>
<div class="paragraph">
<p>こうした強力なツールの一つがTremaの仮想ネットワーク機能です。OpenFlowスイッチを持っていない開発者でも、Tremaを使えばラップトップPC1台の中に仮想的なOpenFlowネットワークを作り、そこで自分の開発したコントローラを実行できます。この「作ったものをすぐに実行できる」という利点は、生産性の向上だけでなくSDNやOpenFlowのような新しい技術の習得にもつながります。正しい理解のためには概念の理解に加えて実践、つまり実際に手を動かすことが欠かせないからです。</p>
</div>
<div class="paragraph">
<p>ここからは実際にTremaを使ってOpenFlowコントローラを作り、そして動かしていきます。まずはTremaの実行環境をセットアップしましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Tremaの由来は?</div>
<div class="paragraph">
<p>Tremaの名前は、著者の一人がファンである「とれまレコード」(<a href="http://www.fumiyatanaka.com/toremarecords/" class="bare">http://www.fumiyatanaka.com/toremarecords/</a>) という大阪の小さなレコードレーベルの名前から来ています。とれまレコードの楽曲は国内だけでなく海外でも人気があり、海外のクラブチャートにもよくランクインします。</p>
</div>
<div class="paragraph">
<p>この「とれまレコード」の名前には面白い由来があります。日本がバブルの頃、道路上の「とまれ」という標示がよく「とれま」と間違えて描かれており、これに目をつけたレーベルオーナーが「とれまレコード」と名付けたのだそうです。</p>
</div>
<div class="paragraph">
<p>このありえないミスの原因は、バブル景気時代にまでさかのぼります。当時の景気に乗って急増した外国人労働者達は、日本語もままならないまま工事現場で働いていました。そのおかげで道路に「とれま」と描いてしまう珍事が発生したのだそうです。</p>
</div>
<div id="trema_logo" class="imageblock">
<div class="content">
<img src="images/hello_trema/trema_logo.png" alt="trema logo">
</div>
<div class="title">図 3-A: Tremaの公式ロゴ</div>
</div>
<div class="paragraph">
<p>この逸話にのっとって、Tremaの公式ロゴも<a href="#trema_logo">図 3-A</a>のとおり道路標識の写真になっています。……ちなみに、こんな道路標識は日本中どこを探してもありません! 本書の編集者が画像編集ソフトで試しに作ってみたところ評判が良かったので、そのまま公式ロゴになりました。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_trema実行環境のセットアップ">3.3. Trema実行環境のセットアップ</h3>
<div class="paragraph">
<p>TremaはLinux用のソフトウェアです。次のLinuxディストリビューションでの動作を確認しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ubuntu Linux</p>
</li>
<li>
<p>Debian GNU/Linux</p>
</li>
<li>
<p>CentOS 6 系, 7 系</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tremaに必要なソフトウェアは次の4つです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">sudo</dt>
<dd>
<p>Trema が root 権限でコマンドを実行するのに使います。あらかじめ、<code>sudo</code> コマンドを使って root 権限でコマンドを実行できるかどうか、sudo の設定ファイルを確認しておいてください。</p>
</dd>
<dt class="hdlist1">Ruby</dt>
<dd>
<p>Trema の実行には Ruby のバージョン 2.0 以降が必要です。Trema を使ったコントローラの開発にも Ruby を使います。</p>
</dd>
<dt class="hdlist1">Bundler <sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnote_7" title="View footnote.">7</a>]</sup></dt>
<dd>
<p>Ruby ライブラリのインストーラです。Trema 本体と実行に必要なライブラリ一式を自動的にインストールするのに使います。</p>
</dd>
<dt class="hdlist1">Open vSwitch <sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnote_8" title="View footnote.">8</a>]</sup></dt>
<dd>
<p>OpenFlow に対応したソフトウェアスイッチの一種です。Trema の仮想ネットワーク機能で使用します。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_rubyのインストール">3.3.1. Rubyのインストール</h4>
<div class="paragraph">
<p>Rubyのインストール方法は、Linuxディストリビューションごとに異なります。</p>
</div>
<div class="sect4">
<h5 id="_ubuntu_debianにインストールする場合">Ubuntu/Debianにインストールする場合</h5>
<div class="paragraph">
<p>標準のパッケージマネージャ apt で以下のようにRuby関連パッケージをインストールします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo apt-get update
$ sudo apt-get install ruby2.0 ruby2.0-dev build-essential</pre>
</div>
</div>
<div class="paragraph">
<p>なお build-essential パッケージは Trema が依存する外部ライブラリのインストールに必要な gcc コンパイラなどを含んでいます。</p>
</div>
</div>
<div class="sect4">
<h5 id="_centos_にインストールする場合">CentOS にインストールする場合</h5>
<div class="paragraph">
<p>標準のパッケージマネージャ yum で以下のようにRuby関連パッケージをインストールします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo yum update
$ sudo yum install ruby ruby-devel gcc gcc-c++</pre>
</div>
</div>
<div class="paragraph">
<p>なお gcc と gcc-c++ パッケージは Trema が依存する外部ライブラリのインストールに必要です。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bundler_のインストール">3.3.2. Bundler のインストール</h4>
<div class="paragraph">
<p>Bundler は次のコマンドでインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gem install bundler</pre>
</div>
</div>
<div class="paragraph">
<p>なお <code>gem</code> は Ruby の標準ライブラリ形式 .gem をインストールするコマンドです。ここでは最新版の Bundler の .gem を自動的にダウンロードしてインストールしています。</p>
</div>
</div>
<div class="sect3">
<h4 id="_open_vswitchのインストール">3.3.3. Open vSwitchのインストール</h4>
<div class="paragraph">
<p>Open vSwitchのインストール方法も、Linuxディストリビューションごとに異なります。</p>
</div>
<div class="sect4">
<h5 id="_ubuntu_debian_にインストールする場合">Ubuntu/Debian にインストールする場合</h5>
<div class="paragraph">
<p>Open vSwitchも <code>apt-get</code> コマンドで簡単にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo apt-get install openvswitch-switch</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_centos_にインストールする場合_2">CentOS にインストールする場合</h5>
<div class="paragraph">
<p><code>yum</code> コマンドでOpen vSwitchをインストールします。RDO(RPM Distribution of OpenStack)<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnote_9" title="View footnote.">9</a>]</sup>というRedHat系Linux用のOpenStackパッケージリポジトリを使うと、簡単にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo yum update
$ sudo yum install https://rdoproject.org/repos/rdo-release.rpm
$ sudo yum install openvswitch
$ sudo systemctl start openvswitch.service</pre>
</div>
</div>
<div class="paragraph">
<p>以上でTremaを使うための準備が整いました。それでは早速、入門の定番Hello, Worldを書いて実行してみましょう。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hello_trema">3.4. Hello, Trema!</h3>
<div class="paragraph">
<p>Hello Trema!はもっとも簡単なOpenFlowコントローラです。その唯一の機能は、スイッチと接続して <code>Hello, 0xabc!</code> (<code>0xabc</code> はスイッチのユニーク ID) と表示するだけです。このように機能は単純ですが、そのソースコードはTremaでコントローラを作るのに必要な基本知識をすべて含んでいます。</p>
</div>
<div class="sect3">
<h4 id="_hello_tremaを書く">3.4.1. Hello Tremaを書く</h4>
<div class="paragraph">
<p>コントローラの実装はプロジェクト用ディレクトリを作ることから始めます。まずは次のように、Hello Trema!用の空のディレクトリ <code>hello_trema/</code> と、ソースコード用ディレクトリ <code>hello_trema/lib/</code> を <code>mkdir -p</code> コマンドで新たに作ってください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ mkdir -p hello_trema/lib
$ cd hello_trema</pre>
</div>
</div>
<div class="sect4">
<h5 id="_プロジェクトディレクトリの中身">プロジェクトディレクトリの中身</h5>
<div class="paragraph">
<p>プロジェクトディレクトリには、コントローラに関連するすべてのファイルを置きます。コントローラのソースコードをはじめ、README.mdやLICENSEといったドキュメント類、コントローラの動作をテストするためのテストファイル、そして各種設定ファイルがここに入ります。</p>
</div>
<div class="paragraph">
<p>プロジェクトディレクトリのお手本として、GitHub の <code>trema/hello_trema</code> リポジトリ (<a href="https://github.com/trema/hello_trema" class="bare">https://github.com/trema/hello_trema</a>) を見てみましょう。このリポジトリは、標準的な Ruby プロジェクトのファイル構成に従っています。次に主要なファイルを挙げます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>README.md</code></dt>
<dd>
<p>メインのドキュメント</p>
</dd>
<dt class="hdlist1"><code>LICENSE</code></dt>
<dd>
<p>配布ライセンスの指定</p>
</dd>
<dt class="hdlist1"><code>CHANGELOG.md</code></dt>
<dd>
<p>開発履歴</p>
</dd>
<dt class="hdlist1"><code>Gemfile</code></dt>
<dd>
<p>実行に必要なgemパッケージの定義</p>
</dd>
<dt class="hdlist1"><code>Rakefile</code></dt>
<dd>
<p>開発用タスク</p>
</dd>
<dt class="hdlist1"><code>lib/</code></dt>
<dd>
<p>コントローラの実装</p>
</dd>
<dt class="hdlist1"><code>features/</code></dt>
<dd>
<p>受け入れテスト</p>
</dd>
<dt class="hdlist1"><code>spec/</code></dt>
<dd>
<p>ユニットテスト</p>
</dd>
<dt class="hdlist1"><code>tasks/</code></dt>
<dd>
<p>開発用タスク定義</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このうち受け入れテスト関連の <code>features/</code> ディレクトリについては、9 章「<a href="#tdd">Trema でテスト駆動開発</a>」で詳しく説明します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_コントローラ本体の実装">コントローラ本体の実装</h5>
<div class="paragraph">
<p>エディタで <code>hello_trema</code> ディレクトリ内の <code>lib/hello_trema.rb</code> を開き、次の Ruby コードを入力してください。<code>.rb</code> は Ruby プログラムの標準的な拡張子です。Ruby の文法は必要に応じておいおい説明しますので、もしわからなくても気にせずそのまま入力してください。</p>
</div>
<div class="listingblock">
<div class="title">lib/hello_trema.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Hello World!</span>
<span class="keyword">class</span> <span class="class">HelloTrema</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    logger.info <span class="string"><span class="delimiter">'</span><span class="content">Trema started.</span><span class="delimiter">'</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">#{</span>datapath_id.to_hex<span class="inline-delimiter">}</span></span><span class="content">!</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_スイッチの定義">スイッチの定義</h5>
<div class="paragraph">
<p>Hello Trema! の実行には OpenFlow スイッチが 1 台必要です。さきほどインストールした Open vSwitch を Hello Trema コントローラに接続することにしましょう。次の設定ファイル <code>trema.conf</code> をエディタで <code>hello_trema/</code> ディレクトリ直下に作成してください。</p>
</div>
<div class="listingblock">
<div class="title">trema.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch { datapath_id <span class="integer">0xabc</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>コントローラを実行する際にこの設定ファイルを指定することで、Open vSwitch を起動しコントローラに接続できます。</p>
</div>
<div class="paragraph">
<p>この設定ファイルでは1台のソフトウェアスイッチを定義しています。<code>vswitch</code> で始まる行が1台の仮想スイッチに対応します。続く波括弧(<code>{ }</code>)内で指定している <code>datapath_id</code> (<code>0xabc</code>) は、仮想スイッチを識別するための16進数の値です。</p>
</div>
<div class="paragraph">
<p>この <strong>Daptapath ID</strong> とはちょうどMACアドレスのような存在で、スイッチを一意に特定するIDとして使います。OpenFlowの仕様では、この値には64ビットの一意な整数値を割り振ることになっています。仮想スイッチでは好きな値を設定できるので、もし複数台の仮想スイッチを作る場合にはお互いがぶつからないように注意してください。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Datapath ってどういう意味？</div>
<div class="paragraph">
<p>実用的には「Datapath = OpenFlowスイッチ」と考えて問題ありません。”データパス”で検索すると、「CPUは演算処理を行うデータパスと、指示を出すコントローラから構成されます」というハードウェア教科書の記述が見つかります。つまり、ハードウェアの世界では一般に</p>
</div>
<div class="ulist">
<ul>
<li>
<p>筋肉にあたる部分 = データパス</p>
</li>
<li>
<p>脳にあたる部分 = コントローラ</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>という分類をするようです。</p>
</div>
<div class="paragraph">
<p>OpenFlowの世界でも同じ用法を踏襲しています。OpenFlowのデータパスはパケット処理を行うスイッチを示し、その制御を行うソフトウェア部分をコントローラと呼びます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_trema_のインストール">Trema のインストール</h5>
<div class="paragraph">
<p>Hello Trema の実行にはもちろん Trema が必要です。実行に必要な Ruby のアプリケーションやライブラリの gem を <code>hello_trema/</code> ディレクトリ直下の <code>Gemfile</code> というファイルに次のように書くことで、Hello Trema の実行環境として Trema を使うということを指定します。</p>
</div>
<div class="listingblock">
<div class="title">Gemfile</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">source <span class="string"><span class="delimiter">'</span><span class="content">https://rubygems.org/</span><span class="delimiter">'</span></span> <i class="conum" data-value="1"></i><b>(1)</b>

gem ‘trema’ <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>gem の取得元として標準的な <a href="https://rubygems.org" class="bare">https://rubygems.org</a> を指定する</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>実行環境に Trema を追加する</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Gemfile に記述した実行環境のセットアップには Bundler を使います。<code>hello_trema</code> ディレクトリ直下で次の <code>bundle install --binstubs</code> コマンドを実行すると、<code>Gemfile</code> に記述した Trema と Trema が依存する <code>.gem</code> ファイル一式を自動的にインストールし、Trema の実行コマンド <code>trema</code> を <code>bin/</code> ディレクトリに生成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ bundle install --binstubs
$ ./bin/trema --version
trema version 0.9.0</pre>
</div>
</div>
<div class="paragraph">
<p>実行に最低限必要なコードはこれだけです。それでは細かい部分は後で説明するとして「習うより慣れろ」でさっそく実行してみましょう。</p>
</div>
</div>
<div class="sect4">
<h5 id="_実行してみよう_trema_run">実行してみよう(trema run)</h5>
<div class="paragraph">
<p>作成したコントローラは <code>trema run</code> コマンドですぐに実行できます。Rubyはインタプリタ言語なので、コンパイルの必要はありません。ターミナルで次のように入力し、コントローラを起動してみてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/hello_trema.rb -c trema.conf
Trema started.
Hello, 0xabc! <i class="conum" data-value="1"></i><b>(1)</b>
$</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><span class="keyseq"><kbd>Ctrl</kbd>+<kbd>c</kbd></span> でコントローラを終了</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このように <code>Trema started. Hello, 0xabc!</code> と出力できたら成功です。</p>
</div>
<div class="paragraph">
<p>ここまで見てきたように、<code>trema</code> コマンドを使うと、とても簡単にコントローラを実行できます。<code>trema</code> コマンドには他にもいくつかの機能がありますので、ここで簡単に紹介しておきましょう。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trema_コマンド">3.5. trema コマンド</h3>
<div class="paragraph">
<p><code>trema</code> コマンドは Trema 唯一のコマンドラインツールであり、コントローラの起動やテストなどさまざまな用途に使います。</p>
</div>
<div class="paragraph">
<p>たとえばHello, Trema!で見たように、<code>trema run</code> はコントローラの起動コマンドです。起動したコントローラは OpenFlow スイッチと接続しメッセージをやりとりします。また、<code>trema run</code> コマンドに <code>-c</code> (<code>--conf</code>) オプションを指定することで、コントローラを仮想ネットワークのスイッチとも接続できます (<a href="#trema_run_command">図 3-1</a>)。</p>
</div>
<div id="trema_run_command" class="imageblock">
<div class="content">
<img src="images/hello_trema/trema_overview.png" alt="trema overview">
</div>
<div class="title">図 3-1: trema runコマンドの実行イメージ</div>
</div>
<div class="paragraph">
<p><code>trema</code> コマンドは <code>git</code> や <code>svn</code> コマンドと似たコマンド体系を持っています。<code>trema</code> に続けて <code>run</code> などのサブコマンドを指定することで、さまざまな機能を呼び出します。こうしたコマンド体系を一般に「コマンドスイート」と呼びます。</p>
</div>
<div class="paragraph">
<p>一般的なコマンドスイートと同じく、サブコマンドの一覧は <code>trema help</code> で表示できます。また、サブコマンド自体のヘルプは <code>trema help サブコマンド名</code> で表示できます。以下に、<code>trema help</code> で表示されるサブコマンド一覧をざっと紹介しておきます。それぞれの使い方は続く章で説明していきますので、今は目を通すだけでかまいません。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>trema run</code></dt>
<dd>
<p>コントローラをフォアグラウンドまたはバックグラウンド (デーモンモード) で実行する</p>
</dd>
<dt class="hdlist1"><code>trema killall</code></dt>
<dd>
<p>バックグラウンドで起動している Trema プロセス全体を停止する</p>
</dd>
<dt class="hdlist1"><code>trema stop</code></dt>
<dd>
<p>指定した仮想ホストまたは仮想スイッチを停止する</p>
</dd>
<dt class="hdlist1"><code>trema start</code></dt>
<dd>
<p>指定した仮想ホストまたは仮想スイッチを再び有効にする</p>
</dd>
<dt class="hdlist1"><code>trema send_packets</code></dt>
<dd>
<p>仮想ネットワーク内でテストパケットを送信する</p>
</dd>
<dt class="hdlist1"><code>trema show_stats</code></dt>
<dd>
<p>仮想ホストで送受信したパケットの統計情報を表示する</p>
</dd>
<dt class="hdlist1"><code>trema reset_stats</code></dt>
<dd>
<p>仮想ホストで送受信したパケットの統計情報をリセットする</p>
</dd>
<dt class="hdlist1"><code>trema port_down</code></dt>
<dd>
<p>仮想スイッチのポートを落とす</p>
</dd>
<dt class="hdlist1"><code>trema port_up</code></dt>
<dd>
<p>仮想スイッチのポートを上げる</p>
</dd>
<dt class="hdlist1"><code>trema delete_link</code></dt>
<dd>
<p>仮想ネットワーク内の仮想リンクを切る</p>
</dd>
<dt class="hdlist1"><code>trema netns</code></dt>
<dd>
<p>仮想ホストのネットワークネームスペースでコマンドを実行する</p>
</dd>
<dt class="hdlist1"><code>trema dump_flows</code></dt>
<dd>
<p>仮想スイッチのフローテーブルを表示する</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>では、気になっていた Ruby の文法にそろそろ進みましょう。今後はたくさん Ruby を使いますが、その都度必要な文法を説明しますので心配はいりません。しっかりついてきてください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_即席ruby入門">3.6. 即席Ruby入門</h3>
<div class="paragraph">
<p>Rubyを習得する一番の近道は、コードを構成する各要素の種類(品詞)を押さえることです。これは、外国語を習得するコツに近いものがあります。ただし外国語と違い、Rubyの構成要素にはその品詞を見分けるための視覚的なヒントがかならずあります。このためRubyのコードはずいぶんと読みやすくなっています。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">品詞</th>
<th class="tableblock halign-left valign-top">例</th>
<th class="tableblock halign-left valign-top">視覚的ヒント</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">定数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HelloTrema</code>, <code>Trema::Controller</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大文字で始まる</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">インスタンス変数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@switches</code>, <code>@name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@</code> で始まる</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">シンボル</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:match</code>, <code>:actions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:</code> で始まる</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>インスタンス変数とシンボルについては<a href="#switch_monitor">4 章「スイッチ監視ツール」</a>で詳しく説明します。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このように最初の文字を見れば、それがどんな品詞かすぐにわかります。たとえば、大文字で始まる名前はかならず定数です。品詞がわかれば、そのRubyコードがどんな構造かも見えてきます。これからそれぞれの品詞について順に説明していきますが、最初からすべてが理解できなくとも構いません。しばらくすればRubyコードのあらゆる部分が識別できるようになっているはずです。</p>
</div>
<div class="sect3">
<h4 id="_定数">3.6.1. 定数</h4>
<div class="paragraph">
<p><code>HelloTrema</code> や <code>Trema::Controller</code> など、大文字で始まる名前が<strong>定数</strong>です。Rubyの定数は英語や日本語といった自然言語における固有名詞にあたります。</p>
</div>
<div class="listingblock">
<div class="title">lib/hello_world.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Hello World!</span>
<span class="keyword">class</span> <span class="class">HelloTrema</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    logger.info <span class="string"><span class="delimiter">'</span><span class="content">Trema started.</span><span class="delimiter">'</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">#{</span>datapath_id.to_hex<span class="inline-delimiter">}</span></span><span class="content">!</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>HelloTrema</code> と <code>Trema::Controller</code> が定数</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>英語でも固有名詞は大文字で始めることになっています。たとえば英語のTokyo Tower(東京タワー)がそうです。東京タワーは動かすことができませんし、何か別なものに勝手に変えることもできません。このように、固有名詞は時間とともに変化しないものを指します。そして固有名詞と同様、Rubyの定数は一度セットすると変更できません。もし変更しようとすると、次のように警告が出ます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ irb
&gt; TokyoTower = "東京都港区芝公園4丁目2-8"
&gt; TokyoTower = "増上寺の近く"
(irb):2: warning: already initialized constant TokyoTower
(irb):1: warning: previous definition of TokyoTower was here
=&gt; "東京都港区芝公園4丁目2-8"</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ここで使っている <code>irb</code> (Interactive Ruby) は Ruby のインタラクティブな実行ツールです。ちょっとしたサンプルコードを試したり、Rubyの挙動を調べるのに便利です。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>class</code> に続く定数は<strong>クラス定義</strong>です。Hello, Trema!の例では <code>HelloTrema</code> がクラス名です。「<code>class</code> +クラス名」から始まるクラス定義は、同じ字下げレベルの <code>end</code> までの範囲です。</p>
</div>
<div class="listingblock">
<div class="title">lib/hello_trema.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">HelloTrema</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Trema started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">#{</span>datapath_id.to_hex<span class="inline-delimiter">}</span></span><span class="content">!</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>HelloTremaクラス定義の始まり</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>クラス定義の終わり</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_コントローラクラスの継承">コントローラクラスの継承</h5>
<div class="paragraph">
<p>Tremaではすべてのコントローラはクラスとして定義し、Tremaの提供する <code>Trema::Controller</code> クラスをかならず継承します。クラスを継承するには、<code>class クラス名 &lt; 親クラス名</code> と書きます.</p>
</div>
<div class="listingblock">
<div class="title">lib/hello_trema.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">HelloTrema</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span> <i class="conum" data-value="1"></i><b>(1)</b>
  ...
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Trema::Controller</code> クラスを継承した <code>HelloTrema</code> クラスを定義</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Trema::Controller</code> クラスを継承することで、コントローラに必要な基本機能が <code>HelloTrema</code> クラスに追加されます。たとえば次に説明するハンドラもその基本機能の一つです。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ハンドラの定義">3.6.2. ハンドラの定義</h4>
<div class="paragraph">
<p>さて、こうして定義した <code>HelloTrema</code> クラスはどこから実行が始まるのでしょうか。C言語で言う <code>main()</code> 関数に当たるものがどこにも見あたりません。</p>
</div>
<div class="paragraph">
<p>その答はTremaの動作モデルであるイベントドリブンモデルにあります。Tremaのコントローラは、さまざまなイベントに反応するイベントハンドラ (以下、<strong>ハンドラ</strong>と呼びます) をいくつも持ちます。コントローラが動作するのは、さまざまなイベントに対してハンドラが反応したときです。</p>
</div>
<div class="paragraph">
<p>ハンドラの定義は <code>def</code> に続く名前から <code>end</code> までの部分で、実際には<strong>メソッド</strong>定義です。たとえば <code>HelloTrema</code> の例では <code>start</code> ハンドラと <code>switch_ready</code> ハンドラを定義しています。ハンドラ名の後のカッコで囲まれた部分 (<code>_args</code> と <code>datapath_id</code>) はそれぞれのメソッドに渡される引数です。</p>
</div>
<div class="listingblock">
<div class="title">lib/hello_trema.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">HelloTrema</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args) <i class="conum" data-value="1"></i><b>(1)</b>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Trema started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id) <i class="conum" data-value="2"></i><b>(2)</b>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">#{</span>datapath_id.to_hex<span class="inline-delimiter">}</span></span><span class="content">!</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>start</code> ハンドラの定義</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>switch_ready</code> ハンドラの定義</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">start ハンドラ</dt>
<dd>
<p>コントローラの起動イベント発生時、つまり <code>trema run</code> でコントローラを起動したときに自動で呼び出します。</p>
</dd>
<dt class="hdlist1">switch_ready ハンドラ</dt>
<dd>
<p>スイッチがコントローラに接続し、初期化が完了したときに自動で呼び出します。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Rubyのイディオム: アンダーバー (<code>_</code>) で始まる引数名</div>
<div class="paragraph">
<p>メソッドの中で使わない引数は、<code>_args</code> のようにアンダーバーで始めます。これによって、この引数はメソッドの中で使われていないことが一目でわかります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># メソッド内で _args は使っていない</span>
<span class="keyword">def</span> <span class="function">start</span>(_args)
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Trema started.</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># メソッド内で args を使っている</span>
<span class="keyword">def</span> <span class="function">start</span>(args)
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Arguments = </span><span class="inline"><span class="inline-delimiter">#{</span>args.join <span class="string"><span class="delimiter">'</span><span class="content">, </span><span class="delimiter">'</span></span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このほかにTremaでよく使うハンドラをリストアップしておきます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">switch_disconnected ハンドラ</dt>
<dd>
<p>スイッチがコントローラから切断したときに呼び出します。</p>
</dd>
<dt class="hdlist1">packet_in ハンドラ</dt>
<dd>
<p>Packet In メッセージ (<a href="#cbench">5 章「マイクロベンチマークCbench」</a>で紹介) がコントローラへ到着したときに呼び出します。</p>
</dd>
<dt class="hdlist1">flow_removed ハンドラ</dt>
<dd>
<p>フローが消えたときのFlow Removedメッセージ到着時に呼び出します。</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">ハンドラの自動呼び出し</div>
<div class="paragraph">
<p>「ハンドラを定義しただけで、なぜ自動的に呼び出せるんだろう?」と不思議に思う人もいるでしょう。コード中にどんなメソッドがあるか、というコンパイル時情報をプログラム自身が実行時に知るためには、言語処理系の助けが必要です。</p>
</div>
<div class="paragraph">
<p>Rubyではオブジェクトが自らの持つメソッドを実行時に調べられます。これをイントロスペクション(リフレクションや自己反映計算などとも言う)と呼びます。たとえばPacket Inメッセージが到着したとき、コントローラはイントロスペクションして自分が <code>packet_in</code> メソッドを持っているかどうかを実行時に調べます。そしてもし見つかればそのメソッドを呼ぶというわけです。</p>
</div>
<div class="paragraph">
<p>この仕組みは <code>Trema::Controller</code> クラスを継承したとき、自動的にコントローラへ導入されます。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_キーワード">3.6.3. キーワード</h4>
<div class="paragraph">
<p>Rubyにはたくさんの組込みの語 (<strong>キーワード</strong>) があり、それぞれに意味があります。これらのキーワードを変数として使ったり、自分の目的に合わせて意味を変えたりはできません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>alias and BEGIN begin break case class def defined do else elsif END
end ensure false for if in module next nil not or redo rescue retry
return self super then true undef unless until when while yield</pre>
</div>
</div>
<div class="paragraph">
<p>このうち、Hello, Trema!では <code>class</code>・<code>def</code>・<code>end</code> の 3 つのキーワードを使いました。先ほど説明したように、<code>class</code> キーワードは続く名前のクラスを定義します。そして <code>def</code> キーワードは続く名前のメソッドを定義します。</p>
</div>
<div class="paragraph">
<p>この <code>def</code> や <code>class</code> で始まって <code>end</code> で終わる領域のことを<strong>ブロック</strong>と呼びます。すべてのRubyプログラムはこのブロックがいくつか組み合わさったものです。</p>
</div>
<div class="paragraph">
<p>さて、ここまででHello Trema!に必要なRubyの文法は学びました。再びHello Trema!のソースコードに戻りましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_スイッチの起動を捕捉する">3.6.4. スイッチの起動を捕捉する</h4>
<div class="paragraph">
<p>新しくスイッチが起動すると <code>switch_ready</code> ハンドラが起動します。<code>switch_ready</code> ハンドラは、接続したスイッチのDatapath IDを16進形式(0xで始まる文字列)でログに出力します。</p>
</div>
<div class="listingblock">
<div class="title">HelloTrema#switch_ready (lib/hello_trema.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content">!</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">switch_readyの中身</div>
<div class="paragraph">
<p>実は OpenFlow の仕様には <code>switch_ready</code> というメッセージは定義されていません。実は、これは Trema が独自に定義するイベントなのです。<code>switch_ready</code> の裏では<a href="#switch_ready">図 3-B</a>に示す一連の複雑な処理が行われていて、Trema がこの詳細をうまくカーペットの裏に隠してくれているというわけです。</p>
</div>
<div id="switch_ready" class="imageblock">
<div class="content">
<img src="images/hello_trema/switch_ready.png" alt="switch ready">
</div>
<div class="title">図 3-B: switch_ready イベントが起こるまで</div>
</div>
<div class="paragraph">
<p>最初に、スイッチとコントローラがしゃべる OpenFlow プロトコルが合っているか確認します。OpenFlow の Hello メッセージを使ってお互いにプロトコルのバージョンを知らせ、うまく会話できそうか判断します。</p>
</div>
<div class="paragraph">
<p>次は、スイッチを識別するための Datapath ID の取得です。Datapath IDのようなスイッチ固有の情報は、スイッチに対して OpenFlow の Features Request メッセージを送ることで取得できます。成功した場合、Datapath IDや最大テーブル数などの情報が Features Reply メッセージに乗ってやってきます。</p>
</div>
<div class="paragraph">
<p>最後にスイッチを初期化します。スイッチに以前の状態が残っているとコントローラが管理する情報と競合が起こるので、スイッチを初期化することでこれを避けます。</p>
</div>
<div class="paragraph">
<p>これら一連の処理が終わると、ようやく <code>switch_ready</code> がコントローラに通知されるというわけです。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_datapath_idを16進形式にする">Datapath IDを16進形式にする</h5>
<div class="paragraph">
<p><code>to_hex</code> は整数を16進形式の文字列に変換するメソッドです。<code>switch_ready</code> ハンドラの引数 <code>dpid</code> の値は64ビットの正の整数で、OpenFlowでは慣習的に <code>0xfffb</code> などと16進で表します。この慣習に従って、ターミナルやログに出力する場合には <code>to_hex</code> で16進形式に変換しておいたほうがよいでしょう。</p>
</div>
</div>
<div class="sect4">
<h5 id="_ログメッセージを出力する">ログメッセージを出力する</h5>
<div class="paragraph">
<p>ログメッセージを出力するには、<code>logger</code> を使います。</p>
</div>
<div class="listingblock">
<div class="title">HelloTrema#start (lib/hello_trema.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  logger.info <span class="string"><span class="delimiter">'</span><span class="content">Trema started.</span><span class="delimiter">'</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>logger</code> はTrema標準のロガーで、ログメッセージの出力はこれを通じて行います。ログメッセージの重要度に応じて、<code>unknown</code> (重要度 最高) から <code>debug</code> (重要度 最低) までの次の6種類のメソッドを選べます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">unknown</dt>
<dd>
<p>不明なエラー。重要度にかかわらず常にロギングする</p>
</dd>
<dt class="hdlist1">fatal</dt>
<dd>
<p>回復不能なエラー</p>
</dd>
<dt class="hdlist1">error</dt>
<dd>
<p>エラー</p>
</dd>
<dt class="hdlist1">warn</dt>
<dd>
<p>警告</p>
</dd>
<dt class="hdlist1">info</dt>
<dd>
<p>通常レベルの情報</p>
</dd>
<dt class="hdlist1">debug</dt>
<dd>
<p>デバッグ出力</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>trema run</code> のオプションでロギングレベルを指定できます。たとえば次のコードを実行するとしましょう。</p>
</div>
<div class="listingblock">
<div class="title">ロギングレベルの確認用コード (try_logging.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">TryLogging</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    logger.unknown <span class="string"><span class="delimiter">'</span><span class="content">UNKNOWN</span><span class="delimiter">'</span></span>
    logger.fatal <span class="string"><span class="delimiter">'</span><span class="content">FATAL</span><span class="delimiter">'</span></span>
    logger.error <span class="string"><span class="delimiter">'</span><span class="content">ERROR</span><span class="delimiter">'</span></span>
    logger.warn <span class="string"><span class="delimiter">'</span><span class="content">WARN</span><span class="delimiter">'</span></span>
    logger.info <span class="string"><span class="delimiter">'</span><span class="content">INFO</span><span class="delimiter">'</span></span>
    logger.debug <span class="string"><span class="delimiter">'</span><span class="content">DEBUG</span><span class="delimiter">'</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>このコードをたとえば次のようにロギングレベル <code>warn</code> で実行すると、<code>info</code> と <code>debug</code> メッセージは出力されません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run try_logging.rb --logging_level warn
UNKNOWN
FATAL
ERROR
WARN</pre>
</div>
</div>
<div class="paragraph">
<p>ログメッセージはログファイルにも記録されます。ログファイルのデフォルトパスは <code>/tmp/[コントローラのクラス名].log</code> です。たとえばHelloTremaの場合には <code>/tmp/HelloTrema.log</code> になります。ログファイルの出力先ディレクトリを変更するには、<code>trema run</code> の <code>--log_dir</code> または <code>-L</code> オプションを指定します。たとえば次のようにすると、<code>/var/log/HelloTrema.log</code> が作られます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run try_logging.rb --log_dir /var/log/</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_文字列に式を組込む">文字列に式を組込む</h5>
<div class="paragraph">
<p><code>logger.info</code> に渡している文字列中の <code>#{}</code> は、文字列内にRubyの式を組込みます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content">!</span><span class="delimiter">&quot;</span></span>
<span class="comment">#=&gt; Hello 0xabc!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>これは次のコードと同じです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">logger.info <span class="string"><span class="delimiter">'</span><span class="content">Hello </span><span class="delimiter">'</span></span> + dpid.to_hex + <span class="string"><span class="delimiter">'</span><span class="content">!</span><span class="delimiter">'</span></span>
<span class="comment">#=&gt; Hello 0xabc!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>どちらを使っても構いませんが、文字列を <code>+</code> でつなげすぎると最終的な出力がコードからはわかりにくくなることがあります。その場合、このように <code>#{}</code> で組み込んだほうがよいでしょう。</p>
</div>
<div class="paragraph">
<p>これでHello, Trema!の説明はおしまいです。Tremaで作るコントローラは基本的にこのHello, Trema!と同じ構成をしています。これをベースにいくつか必要なハンドラメソッドを追加していけば、より複雑で実践的なコントローラも作れます。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_3">3.7. まとめ</h3>
<div class="paragraph">
<p>この章ではTremaの開発環境をセットアップし、すべてのコントローラのテンプレートとなるHello, Trema!コントローラを書きました。この章で学んだことを簡単にまとめてから、より実用的なコントローラの開発に入っていくことにしましょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>コントローラはクラスとして定義し、<code>Trema::Controller</code> クラスを継承することでコントローラの基本機能を取り込む</p>
</li>
<li>
<p>コントローラに機能を追加するには、各種イベントに対応するハンドラをコントローラクラスに定義する</p>
</li>
<li>
<p>コントローラは <code>trema run</code> コマンドでコンパイルなしにすぐ実行できる</p>
</li>
<li>
<p>仮想ネットワーク機能を使うと、OpenFlowスイッチを持っていなくてもコントローラを実行できる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これでTremaの基礎知識は充分に身に付きました。次の章では、OpenFlowコントローラのためのマイクロベンチマークツール、Cbenchを計測するためのコントローラを書きます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考文献">3.8. 参考文献</h3>
<div class="paragraph">
<p>Rubyプログラミングが初めてという人達のために、この章では入門に役立つサイトや本をいくつか紹介します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">『Ruby 2.2.0 リファレンスマニュアル』(<a href="http://docs.ruby-lang.org/ja/2.2.0/doc/" class="bare">http://docs.ruby-lang.org/ja/2.2.0/doc/</a>)</dt>
<dd>
<p>Ruby の完全なリファレンスです。Ruby でプログラミングする際は参照しましょう。</p>
</dd>
<dt class="hdlist1">『メタプログラミングRuby 第2版』(Paolo Perrotta 著／角 征典 訳／オライリージャパン)</dt>
<dd>
<p>Ruby プログラムを短く簡潔に書くためのテクニックをたくさん紹介しています。「プロっぽい」 Ruby コードを書きたい人は必読です。</p>
</dd>
<dt class="hdlist1">『Why’s (Poignant) Guide to Ruby』(<a href="http://mislav.uniqpath.com/poignant-guide/" class="bare">http://mislav.uniqpath.com/poignant-guide/</a>) <sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnote_10" title="View footnote.">10</a>]</sup></dt>
<dd>
<p>Ruby界の伝説的ハッカー_why氏による風変わりで楽しいRuby入門です。この章のRubyの品詞の説明は、このドキュメントを参考にしました。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="switch_monitor">4. スイッチ監視ツール</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>OpenFlowの特長の一つは、たくさんのスイッチを集中管理できることです。その雰囲気を簡単なOpenFlowコントローラを書いて体験してみましょう。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/switch_monitor/scope.png" alt="scope">
</div>
</div>
<div class="sect2">
<h3 id="_ネットワークを集中管理しよう">4.1. ネットワークを集中管理しよう</h3>
<div class="paragraph">
<p>OpenFlowではたくさんのスイッチを1つのコントローラで集中制御できます。スイッチにはフローテーブルに従ったパケットの転送という1つの仕事だけをやらせ、頭脳であるコントローラが全体のフローテーブルを統括するというわけです。これによって<a href="#how_does_openflow_work">1 章「OpenFlow の仕組み」</a>で見てきたように、自動化やさまざまなシステム連携・トラフィック制御のしやすさ・ソフトウェア開発のテクニック適用・水平方向へのアップグレード、といったさまざまなメリットが生まれるのでした。</p>
</div>
<div class="paragraph">
<p>本章ではこの集中制御の一例として、スイッチ監視ツールを作ります。このツールは「今、ネットワーク中にどんなスイッチが動いていて、それぞれがどんな状態か」をリアルタイムに表示します。OpenFlowでの集中制御に必要な基本テクニックをすべて含んでいます。</p>
</div>
<div class="paragraph">
<p>スイッチ監視ツールは<a href="#switch_monitor_tool">図 4-1</a>のように動作します。コントローラはスイッチの接続を検知すると、起動したスイッチの情報を表示します。逆にスイッチが予期せぬ障害など何らかの原因で接続を切った場合、コントローラはこれを検知して警告を表示します。</p>
</div>
<div id="switch_monitor_overview" class="imageblock">
<div class="content">
<img src="images/switch_monitor/switch_monitor_overview.png" alt="switch monitor overview">
</div>
<div class="title">図 4-1: スイッチ監視ツールの動作</div>
</div>
</div>
<div class="sect2">
<h3 id="_インストール">4.2. インストール</h3>
<div class="paragraph">
<p>スイッチ監視ツールのソースコードは GitHub から次のようにダウンロードできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/switch_monitor.git</pre>
</div>
</div>
<div class="paragraph">
<p>ダウンロードしたソースツリー上で <code>bundle install --binstubs</code> を実行すると、Tremaの <code>./bin/trema</code> コマンドなど必要な実行環境一式を自動的にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd switch_monitor
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>以上でスイッチ監視ツールとTremaのセットアップは完了です。</p>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう">4.3. 実行してみよう</h3>
<div class="paragraph">
<p>試しに仮想スイッチ3台の構成でスイッチ監視ツールを起動してみましょう。次の内容の設定ファイルを <code>switch_monitor.conf</code> として保存してください。なお、それぞれの <code>datapath_id</code> がかぶらないように <code>0x1</code>, <code>0x2</code>, <code>0x3</code> と連番を振っていることに注意してください。</p>
</div>
<div class="listingblock">
<div class="title">switch_monitor.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch { datapath_id <span class="integer">0x1</span> }
vswitch { datapath_id <span class="integer">0x2</span> }
vswitch { datapath_id <span class="integer">0x3</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>この構成でスイッチ監視ツールを起動するには、この設定ファイルを <code>trema run</code> の <code>-c</code> オプションに渡すのでした。スイッチ監視ツールの出力は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/trema run ./lib/switch_monitor.rb -c switch_monitor.conf
SwitchMonitor started.
All =
0x3 is up (All = 0x3) <i class="conum" data-value="1"></i><b>(1)</b>
0x3 manufacturer = Nicira, Inc. <i class="conum" data-value="2"></i><b>(2)</b>
0x3 hardware info = <i class="conum" data-value="3"></i><b>(3)</b>
0x3 software info = <i class="conum" data-value="4"></i><b>(4)</b>
0x3 serial number = <i class="conum" data-value="5"></i><b>(5)</b>
0x3 description = <i class="conum" data-value="6"></i><b>(6)</b>
0x1 is up (All = 0x1, 0x3)
0x1 manufacturer = Nicira, Inc.
0x1 hardware info =
0x1 software info =
0x1 serial number =
0x1 description =
0x2 is up (All = 0x1, 0x2, 0x3)
0x2 manufacturer = Nicira, Inc.
0x2 hardware info =
0x2 software info =
0x2 serial number =
0x2 description =
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スイッチ 0x3 がコントローラに接続</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>スイッチの製造者情報</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>スイッチのハードウェア情報 (空)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>スイッチのソフトウェア情報 (空)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>スイッチのシリアル番号 (空)</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>スイッチの詳細情報 (空)</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>0x1 is up</code> などの行から、仮想ネットワーク設定ファイルに定義したスイッチ3台をコントローラが検出していることがわかります。続く行では、スイッチの製造者といった詳細情報や、スイッチ一覧 (<code>All = 0x1, 0x2, 0x3</code> の行) も確認できます。</p>
</div>
<div class="paragraph">
<p>このように実際にスイッチを持っていなくても、設定ファイルを書くだけでスイッチを何台も使ったコントローラの動作テストができます。設定ファイルの <code>vswitch { &#8230;&#8203; }</code> の行を増やせば、スイッチをさらに5台、10台、…と足していくことも思いのままです。</p>
</div>
<div class="sect3">
<h4 id="_仮想スイッチを停止_再起動してみる">4.3.1. 仮想スイッチを停止/再起動してみる</h4>
<div class="paragraph">
<p>それでは、スイッチの切断をうまく検出できるか確かめてみましょう。仮想スイッチを停止するコマンドは <code>trema stop</code> です。<code>trema run</code> を実行したターミナルはそのままで別ターミナルを開き、次のコマンドで仮想スイッチ <code>0x3</code> を落としてみてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema stop 0x3</pre>
</div>
</div>
<div class="paragraph">
<p>すると、<code>trema run</code> を実行したターミナルで新たに <code>0x3 is down</code> の行が出力されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/trema run ./switch_monitor.rb -c ./switch_monitor.conf
SwitchMonitor started.
All =
0x3 is up (All = 0x3)
0x3 manufacturer = Nicira, Inc.
0x3 hardware info =
0x3 software info =
0x3 serial number =
0x3 description =
……
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3
0x3 is down (All = 0x1, 0x2) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スイッチ 0x3 が停止したことを示すログメッセージ</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>うまくいきました! それでは逆に、さきほど落した仮想スイッチを再び起動してみましょう。仮想スイッチを起動するコマンドは <code>trema start</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema start 0x3</pre>
</div>
</div>
<div class="paragraph">
<p><code>0x3 is up</code> の行が出力されれば成功です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/trema run ./switch_monitor.rb -c ./switch_monitor.conf
SwitchMonitor started.
All =
0x3 is up (All = 0x3)
0x3 manufacturer = Nicira, Inc.
0x3 hardware info =
0x3 software info =
0x3 serial number =
0x3 description =
……
All = 0x1, 0x2, 0x3
All = 0x1, 0x2, 0x3
0x3 is down (All = 0x1, 0x2)
All = 0x1, 0x2
……
All = 0x1, 0x2
All = 0x1, 0x2
0x3 is up (All = 0x1, 0x2, 0x3) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スイッチ 0x3 が再び起動したことを示すログメッセージ</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このように、<code>trema stop</code> と <code>trema start</code> は仮想ネットワークのスイッチを制御するためのコマンドです。引数にスイッチのDatapath IDを指定することで、スイッチを停止または起動してコントローラの反応を確かめられます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">trema stop [Datapath ID]</dt>
<dd>
<p>指定した仮想スイッチを停止する</p>
</dd>
<dt class="hdlist1">trema start [Datapath ID]</dt>
<dd>
<p>指定した仮想スイッチを再び起動する</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>スイッチ監視ツールの動作イメージがわかったところで、そろそろソースコードの解説に移りましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ソースコード解説">4.4. ソースコード解説</h3>
<div class="paragraph">
<p>まずはざっとスイッチ監視ツールのソースコード(<a href="#switch_monitor.rb">lib/switch_monitor.rb</a>)を眺めてみましょう。今までに学んできたRubyの品詞を頭の片隅に置きながら、次のコードに目を通してみてください。</p>
</div>
<div id="switch_monitor.rb" class="listingblock">
<div class="title">lib/switch_monitor.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Switch liveness monitor.</span>
<span class="keyword">class</span> <span class="class">SwitchMonitor</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  timer_event <span class="symbol">:show_all_switches</span>, <span class="key">interval</span>: <span class="integer">10</span>.sec

  <span class="keyword">def</span> <span class="function">start</span>(_args)
    <span class="instance-variable">@switches</span> = []
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
    <span class="instance-variable">@switches</span> &lt;&lt; dpid
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> is up (All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="content">)</span><span class="delimiter">&quot;</span></span>
    send_message dpid, <span class="constant">DescriptionStats</span>::<span class="constant">Request</span>.new
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_disconnected</span>(dpid)
    <span class="instance-variable">@switches</span> -= [dpid]
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> is down (All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="content">)</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">description_stats_reply</span>(dpid, desc)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> manufacturer = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.manufacturer<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> hardware info = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.hardware<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> software info = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.software<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> serial number = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.serial_number<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> description = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.datapath<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">show_all_switches</span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">all_switches_in_string</span>
    <span class="instance-variable">@switches</span>.sort.map(&amp;<span class="symbol">:to_hex</span>).join(<span class="string"><span class="delimiter">'</span><span class="content">, </span><span class="delimiter">'</span></span>)
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>新しい品詞や構文がいくつかありますが、今までに学んだ知識だけでこのRubyソースコードの構成はなんとなくわかったはずです。まず、スイッチ監視ツールの本体は <code>SwitchMonitor</code> という名前のクラスです。そしてこのクラスにはいくつかハンドラメソッドが定義してあるようです。おそらくそれぞれがスイッチの接続や切断、そして統計情報イベントを処理しているんだろう、ということが想像できれば上出来です。</p>
</div>
<div class="sect3">
<h4 id="_スイッチの起動を捕捉する_2">4.4.1. スイッチの起動を捕捉する</h4>
<div class="paragraph">
<p><code>switch_ready</code> ハンドラでは、スイッチ一覧リスト <code>@switches</code> に新しく接続したスイッチのDatapath IDを追加し、接続したスイッチの情報を画面に表示します。</p>
</div>
<div class="listingblock">
<div class="title">SwitchMonitor#switch_ready (lib/switch_monitor.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
  <span class="instance-variable">@switches</span> &lt;&lt; dpid
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> is up (All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="content">)</span><span class="delimiter">&quot;</span></span>
  send_message dpid, <span class="constant">DescriptionStats</span>::<span class="constant">Request</span>.new
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@switches</code> は <code>start</code> ハンドラで空の配列に初期化されます。</p>
</div>
<div class="listingblock">
<div class="title">SwitchMonitor#start (lib/switch_monitor.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  <span class="instance-variable">@switches</span> = []
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_インスタンス変数">4.4.2. インスタンス変数</h4>
<div class="paragraph">
<p>アットマーク(<code>@</code>)で始まる語は<strong>インスタンス変数</strong>です。インスタンス変数はたとえば人間の歳や身長などといった、属性を定義するときによく使われます。アットマークはアトリビュート (属性) を意味すると考えれば覚えやすいでしょう。</p>
</div>
<div class="paragraph">
<p>インスタンス変数は同じクラスの中のメソッド定義内であればどこからでも使えます。具体的な例として次の <code>Human</code> クラスを見てください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">Human</span>
  <span class="keyword">def</span> <span class="function">initialize</span>
    <span class="instance-variable">@age</span> = <span class="integer">0</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">birthday</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="instance-variable">@age</span> += <span class="integer">1</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>インスタンス変数を初期化。生まれたときは 0 歳</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一年に一度、歳をとる</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Human</code> クラスで定義される <code>Human</code> オブジェクトは、初期化したときにはそのインスタンス変数 <code>@age</code> は0、つまり0歳です。<code>birthday</code> を呼び出すたびに歳を取り、<code>@age</code> が 1 増えます。このように <code>@age</code> は <code>initialize</code> および <code>birthday</code> メソッドのどちらからでもその値を変更できます。</p>
</div>
<div class="sect4">
<h5 id="_配列">配列</h5>
<div class="paragraph">
<p>配列は角カッコで囲まれたリストで、カンマで区切られています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[]</code> は空の配列</p>
</li>
<li>
<p><code>[1, 2, 3]</code> は数字の配列</p>
</li>
<li>
<p><code>["バナナ", "みかん", "りんご"]</code> は文字列の配列</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Rubyの配列はとても直感的に要素を足したり取り除いたりできます。たとえば配列の最後に要素を加えるには <code>&lt;&lt;</code> を使います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">fruits = [<span class="string"><span class="delimiter">&quot;</span><span class="content">バナナ</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">みかん</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">りんご</span><span class="delimiter">&quot;</span></span>]
fruits &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">パイナップル</span><span class="delimiter">&quot;</span></span>
<span class="comment">#=&gt; [&quot;バナナ&quot;, &quot;みかん&quot;, &quot;りんご&quot;, &quot;パイナップル&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>配列から要素を取り除くには <code>-=</code> を使います。これは左右の配列同士を見比べ、共通する要素を取り除いてくれます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">fruits = [<span class="string"><span class="delimiter">&quot;</span><span class="content">バナナ</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">みかん</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">テレビ</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">りんご</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">たわし</span><span class="delimiter">&quot;</span></span>]
fruits -= [<span class="string"><span class="delimiter">&quot;</span><span class="content">テレビ</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">たわし</span><span class="delimiter">&quot;</span></span>]
<span class="comment">#=&gt; [&quot;バナナ&quot;, &quot;みかん&quot;, &quot;りんご&quot;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>配列</strong>はRubyで多用するデータ構造で、この他にもたくさんのメソッドがあらかじめ定義されています。もし詳しく知りたい人は<a href="#hello_trema">3 章「Hello, Trema!」</a>の参考文献で紹介したRubyのサイトや書籍を参照してください。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_スイッチの切断を捕捉する">4.4.3. スイッチの切断を捕捉する</h4>
<div class="paragraph">
<p><code>switch_disconnected</code> ハンドラでは、スイッチ一覧リストから切断したスイッチのDatapath IDを削除し、切断したスイッチの情報を画面に表示します。</p>
</div>
<div class="listingblock">
<div class="title">SwitchMonitor#switch_disconnected (lib/switch_monitor.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_disconnected</span>(dpid)
  <span class="instance-variable">@switches</span> -= [dpid]
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> is down (All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="content">)</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは <code>switch_ready</code> とは逆に、配列の引き算 (<code>-=</code>) で切断したスイッチのDatapath IDを <code>@switches</code> から除いていることに注意してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="_スイッチ一覧を一定時間ごとに表示する">4.4.4. スイッチ一覧を一定時間ごとに表示する</h4>
<div class="paragraph">
<p>スイッチの一覧を一定時間ごとに表示するには、Tremaの<strong>タイマー機能</strong>を使います。次のように <code>timer_event</code> に続いて一定間隔ごとに呼び出したいメソッドと呼び出し間隔を指定しておくと、指定したメソッドが指定した間隔ごとに呼ばれます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># 1 年に一度、年をとるクラス</span>
<span class="keyword">class</span> <span class="class">Human</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  timer_event <span class="symbol">:birthday</span>, <span class="key">interval</span>: <span class="integer">1</span>.year  <i class="conum" data-value="1"></i><b>(1)</b>
  ...

  private  <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="keyword">def</span> <span class="function">birthday</span>  <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="instance-variable">@age</span> += <span class="integer">1</span>
  <span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>1 年ごとに <code>birthday</code> メソッドを呼ぶ</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>この行から下はプライベートメソッド</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>タイマーから呼ばれる <code>birthday</code> メソッド</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この定義は <code>Human</code> クラス定義の先頭に書けるので、まるで <code>Human</code> クラスの属性としてタイマーをセットしているように読めます。このようにTremaを使うとタイマー処理も短く読みやすく書けます。</p>
</div>
<div class="paragraph">
<p>タイマーから呼び出すメソッドは、クラスの中だけで使うのでよくプライベートなメソッドとして定義します。Rubyでは <code>private</code> と書いた行以降のメソッドはプライベートメソッドとして定義され、クラスの外からは見えなくなります。</p>
</div>
<div class="paragraph">
<p>これを踏まえてスイッチ監視ツールのソースコードのタイマー部分を見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">SwitchMonitor</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  timer_event <span class="symbol">:show_all_switches</span>, <span class="key">interval</span>: <span class="integer">10</span>.sec
  ...

  private

  <span class="keyword">def</span> <span class="function">show_all_switches</span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>クラス名定義直後のタイマー定義より、10秒ごとに <code>show_all_switches</code> メソッドを呼んでいることがわかります。</p>
</div>
<div class="sect4">
<h5 id="_シンボル">シンボル</h5>
<div class="paragraph">
<p><strong>シンボル</strong>は文字列の軽量版と言える品詞です。<code>:a</code>・<code>:number</code>・<code>:show_all_switches</code> のように必ずコロンで始まり、英字・数字・アンダースコアを含みます。シンボルは定数のように一度決めると変更できないので、文字列のようにいつの間にか書き変わっている心配がありません。このため、ハッシュテーブル (<a href="#patch_panel">6 章「インテリジェントなパッチパネル」</a>参照) の検索キーとしてよく使われます。</p>
</div>
<div class="paragraph">
<p>また、シンボルは誰かにメソッドを名前で渡すときにも登場します。これだけですとわかりづらいと思うので、具体的な例を見ていきましょう。リスト <code>switch_monitor.rb</code> には、次のようにシンボルを使っている箇所がありました。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">timer_event <span class="symbol">:show_all_switches</span>, <span class="key">interval</span>: <span class="integer">10</span>.sec</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>:show_all_switches</code> は <code>SwitchMonitor</code> クラスのメソッド名をシンボルで書いたものです。</p>
</div>
<div class="paragraph">
<p>もしここでシンボルを使わずに、直接次のように指定するとどうなるでしょうか。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># まちがい!</span>
timer_event show_all_switches, <span class="key">interval</span>: <span class="integer">10</span>.sec</code></pre>
</div>
</div>
<div class="paragraph">
<p>これではうまく動きません。なぜならば、ソースコードの中に <code>show_all_switches</code> とメソッドの名前を書いた時点でそのメソッドが実行されてしまい、その返り値が <code>timer_event</code> へと渡されてしまうからです。</p>
</div>
<div class="paragraph">
<p>もしメソッド名を何かに渡すときにはかならずシンボルにする、と覚えましょう。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_スイッチの詳細情報を表示する">4.4.5. スイッチの詳細情報を表示する</h4>
<div class="paragraph">
<p>スイッチの情報を取得するには、取得したい情報をリクエストするメッセージを <code>send_message</code> でスイッチに送信し、そのリプライメッセージをハンドラで受け取ります。たとえば、今回のようにスイッチの詳細情報を取得するには、<code>DescriptionStats::Request</code> メッセージを送信し、対応するハンドラ <code>description_stats_reply</code> でメッセージを受け取ります。</p>
</div>
<div class="listingblock">
<div class="title">SwitchMonitor#switch_ready, SwitchMonitor#description_stats_reply (lib/switch_monitor.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
  <span class="instance-variable">@switches</span> &lt;&lt; dpid
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> is up (All = </span><span class="inline"><span class="inline-delimiter">#{</span>all_switches_in_string<span class="inline-delimiter">}</span></span><span class="content">)</span><span class="delimiter">&quot;</span></span>
  send_message dpid, <span class="constant">DescriptionStats</span>::<span class="constant">Request</span>.new
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">description_stats_reply</span>(dpid, desc)
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> manufacturer = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.manufacturer<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> hardware info = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.hardware<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> software info = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.software<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> serial number = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.serial_number<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> description = </span><span class="inline"><span class="inline-delimiter">#{</span>desc.datapath<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>スイッチの詳細情報のほかにも、さまざまな統計情報を取得できます。OpenFlow 1.0がサポートしている統計情報の一覧は次のとおりです。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">取得できる情報</th>
<th class="tableblock halign-left valign-top">スイッチへ送るメッセージ</th>
<th class="tableblock halign-left valign-top">ハンドラ名</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">スイッチの詳細情報</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DescriptionStats::Request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description_stats_reply</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">単一フローエントリの統計情報</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FlowStats::Request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flow_stats_reply</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">複数フローエントリの統計情報</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AggregateStats::Request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aggregate_stats_reply</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">フローテーブルの統計情報</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TableStats::Request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>table_stats_reply</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">スイッチポートの統計情報</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PortStats::Request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>port_stats_reply</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">キューの統計情報</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>QueueStats::Request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>queue_stats_reply</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_4">4.5. まとめ</h3>
<div class="paragraph">
<p>この章ではスイッチの動作状況を監視するスイッチ監視ツールを作りました。また、作ったスイッチ監視ツールをテストするため Trema の仮想ネットワーク機能を使いました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>スイッチの起動と切断を捕捉するには、<code>switch_ready</code> と <code>switch_disconnected</code> ハンドラメソッドを定義する</p>
</li>
<li>
<p>スイッチの詳細情報を取得するには、<code>DescriptionStats::Request</code> メッセージをスイッチへ送信し <code>description_stats_reply</code> ハンドラでリプライを受信する</p>
</li>
<li>
<p>タイマー (<code>timer_event</code>) を使うと一定間隔ごとに指定したメソッドを起動できる</p>
</li>
<li>
<p><code>trema start</code> と <code>trema stop</code> コマンドで仮想ネットワーク内のスイッチを起動/停止できる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>続く章では、いよいよ OpenFlow の最重要メッセージである Packet In と Flow Mod を使ったプログラミングに挑戦です。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cbench">5. マイクロベンチマークCbench</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>本格的なOpenFlowプログラミングの第一歩として、スイッチのフローテーブルを書き換えてみましょう。マイクロベンチマークツールCbenchを題材に、Packet InとFlow Modメッセージの使い方を学びます。</p>
</div>
<div class="sect2">
<h3 id="_cbenchベンチマークとは">5.1. Cbenchベンチマークとは</h3>
<div class="paragraph">
<p>CbenchはOpenFlow1.0コントローラのためのベンチマークです。このベンチマークの内容は、1秒あたりにコントローラが出せるFlow Modの数を計測するというものです。これはOpenFlowプロトコル全体のうちのごく一部の性能だけを対象にしているので、ベンチマークの中でもマイクロベンチマークに分類できます。</p>
</div>
<div class="paragraph">
<p>Cbenchは<a href="#cbench_overview">図 5-1</a>のように動作します。まずcbenchプロセスはOpenFlowスイッチのふりをしてコントローラに接続し、コントローラにPacket Inを連続して送ります。コントローラはPacket Inを受け取るとcbenchプロセスにFlow Modを返します。cbenchプロセスは決められた時間の間に受け取ったFlow Modの数をカウントし、ベンチマークのスコアとします。つまり大量のPacket Inに反応し素早くFlow Modを返せるコントローラほど「速い」とみなします。</p>
</div>
<div id="cbench_overview" class="imageblock">
<div class="content">
<img src="images/cbench/cbench_overview.png" alt="cbench overview">
</div>
<div class="title">図 5-1: cbenchプロセスとコントローラの動作</div>
</div>
</div>
<div class="sect2">
<h3 id="_インストール_2">5.2. インストール</h3>
<div class="paragraph">
<p>Cbenchの実行にはopenflow.org <sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnote_11" title="View footnote.">11</a>]</sup> の配布するベンチマークスイートOflopsを使います。GitHubのtrema/cbenchリポジトリには、Oflops一式とCbenchコントローラのソースコードが入っています。次のコマンドでダウンロードしてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/cbench.git</pre>
</div>
</div>
<div class="paragraph">
<p>ダウンロードしたソースツリー上で <code>bundle install --binstubs</code> を実行すると、Tremaの <code>./bin/trema</code> コマンドと Cbench の実行コマンド <code>./bin/cbench</code> など必要な実行環境一式を自動的にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd cbench
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>以上でCbenchとTremaのセットアップは完了です。</p>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_2">5.3. 実行してみよう</h3>
<div class="paragraph">
<p>さっそくCbenchを実行してみましょう。まず、コントローラを次のように起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/cbench.rb</pre>
</div>
</div>
<div class="paragraph">
<p>そして別ターミナルを開き、次のコマンドでcbenchプロセスを実行しベンチマークを開始します<sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnote_12" title="View footnote.">12</a>]</sup>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/cbench --port 6653 --switches 1 --loops 10 --ms-per-test 10000 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'latency'
   connecting to controller at localhost:6653
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  807   total = 0.080652 per ms
1   switches: fmods/sec:  797   total = 0.079694 per ms
1   switches: fmods/sec:  799   total = 0.079730 per ms
1   switches: fmods/sec:  797   total = 0.079698 per ms
1   switches: fmods/sec:  801   total = 0.080003 per ms
1   switches: fmods/sec:  800   total = 0.079965 per ms
1   switches: fmods/sec:  802   total = 0.080159 per ms
1   switches: fmods/sec:  802   total = 0.080182 per ms
1   switches: fmods/sec:  806   total = 0.080549 per ms
1   switches: fmods/sec:  801   total = 0.080082 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 79.69/80.55/80.01/0.26 responses/s</pre>
</div>
</div>
<div class="paragraph">
<p>この例では、10秒間のベンチマークを10回実行しその結果を表示しています。<code>fmods/sec</code> の右側の数字が、実際に 1 秒間に打った Flow Mod の数です。実行環境によって値は変わりますが、Trema は秒間に数百回のFlow Modを打てることがわかります。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ソースコード解説_2">5.4. ソースコード解説</h3>
<div class="paragraph">
<p>Cbenchが正しく実行できたところで、CbenchのソースコードからPacket InとFlow Modメッセージの処理方法を見ていきましょう。ファイルは lib/cbench.rb です。</p>
</div>
<div class="listingblock">
<div class="title">lib/cbench.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># A simple openflow controller for benchmarking.</span>
<span class="keyword">class</span> <span class="class">Cbench</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
    send_flow_mod_add(
      datapath_id,
      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
      <span class="key">buffer_id</span>: packet_in.buffer_id,
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(packet_in.in_port + <span class="integer">1</span>)
    )
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Cbench のソースコードを眺めると、いくつか見慣れない品詞や構文が登場していることに気付きます。この節では順にそれぞれを紹介していきますが、最初からすべてを覚える必要はありません。もし後でわからなくなったときには見直すようにしてください。</p>
</div>
<div class="sect3">
<h4 id="_メソッド呼び出し">5.4.1. メソッド呼び出し</h4>
<div class="paragraph">
<p>Cbench のソースコードにはいくつかの<strong>メソッド呼び出し</strong>があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>logger.info(&#8230;&#8203;)</code> (<a href="#hello_trema">3 章「Hello, Trema!」</a>で解説)</p>
</li>
<li>
<p><code>ExactMatch.new(&#8230;&#8203;)</code></p>
</li>
<li>
<p><code>packet_in.buffer_id</code></p>
</li>
<li>
<p><code>SendOutPort.new(&#8230;&#8203;)</code></p>
</li>
<li>
<p><code>packet_in.in_port</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>このようにメソッドは普通、変数や定数の後にドットでつなげます。定数や変数が名詞なら、メソッドはちょうど動詞と同じです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">door.open</code></pre>
</div>
</div>
<div class="paragraph">
<p>上の例では <code>open</code> がメソッドです。英語のopenは動詞なので、当然メソッドであるとも言えます。</p>
</div>
<div class="paragraph">
<p>ふつう、メソッド呼び出しによって何らかの動作をすると新しい結果が得られます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="string"><span class="delimiter">'</span><span class="content">redrum</span><span class="delimiter">'</span></span>.reverse
<span class="comment">#=&gt; &quot;murder&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この場合、文字が逆順になった新しい文字列が返ってきました。</p>
</div>
<div class="paragraph">
<p>メソッドは引数を取るものもあります。次の例は配列の各要素の間に指定した文字をはさんで連結 (<code>join</code>) します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">[<span class="string"><span class="delimiter">'</span><span class="content">M</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">S</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">H</span><span class="delimiter">'</span></span>].join(<span class="string"><span class="delimiter">'</span><span class="content">★</span><span class="delimiter">'</span></span>)
<span class="comment">#=&gt; &quot;M★A★S★H&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rubyにはこのようなメソッドが何百種類もあります。それぞれの動作は名前から大体想像できるものがほとんどです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_startハンドラ">5.4.2. startハンドラ</h4>
<div class="listingblock">
<div class="title">Cbench#start (lib/cbench.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>前章と同じく、<code>start</code> ハンドラでコントローラの起動をログに書き込みます。引数は今回も使っていないので、名前を <code>_args</code> のようにアンダースコアで始めます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_packet_inハンドラ">5.4.3. packet_inハンドラ</h4>
<div class="paragraph">
<p>コントローラに上がってくる未知のパケットを拾うには、Packet Inハンドラをコントローラクラスに実装します。Packet Inハンドラは次の形をしています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
  ...
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>packet_in</code> ハンドラはその引数として、Packet Inを起こしたスイッチ(cbenchプロセス)の Datapath ID とPacket Inメッセージを受け取ります。</p>
</div>
<div class="sect4">
<h5 id="_packetin_クラス">PacketIn クラス</h5>
<div class="paragraph">
<p><code>packet_in</code> ハンドラの2番目の引数はPacket Inメッセージオブジェクトで、<code>PacketIn</code> クラスのインスタンスです。この <code>PacketIn</code> クラスは主に次の3種類のメソッドを持っています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Packet Inを起こしたパケットのデータやその長さ、およびパケットが入ってきたスイッチのポート番号などOpenFlowメッセージ固有の情報を返すメソッド</p>
</li>
<li>
<p>Packet Inを起こしたパケットの種別 (TCPかUDPか。VLANタグがついているかどうか、など)を判定するための <code>?</code> で終わるメソッド</p>
</li>
<li>
<p>送信元や宛先のMACアドレスやIPアドレスなど、パケットの各フィールドを調べるためのアクセサメソッド</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>PacketIn</code> クラスは非常に多くのメソッドを持っており、またTremaのバージョンアップごとにその数も増え続けているためすべては紹介しきれません。そのかわり、代表的でよく使うものを<a href="#packet_in_class">表5-1</a>に紹介します。</p>
</div>
<table id="packet_in_class" class="tableblock frame-all grid-all spread">
<caption class="title">Table 14. PacketIn クラスのメソッド (一部)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">メソッド</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:raw_data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットのデータ全体をバイナリ文字列で返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:in_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットが入ってきたスイッチのポート番号を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:buffered?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Packet Inを起こしたパケットがスイッチにバッファされているかどうかを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:buffer_id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">バッファされている場合、そのバッファ領域の ID を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:total_length</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットのデータ長を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:source_mac_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットの送信元MACアドレスを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:destination_mac_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットの宛先MACアドレスを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ipv4?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットがIPv4である場合 <code>true</code> を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ipv4_protocol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPのプロトコル番号を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ipv4_source_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットの送信元IPアドレスを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ipv4_destination_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットの宛先IPアドレスを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ipv4_tos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPのToSフィールドを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:tcp?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットがTCPである場合 <code>true</code> を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:tcp_source_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットのTCPの送信元ポート番号を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:tcp_destination_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットのTCP宛先ポート番号を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:udp?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットがUDPである場合 <code>true</code> を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:udp_source_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットのUDPの送信元ポート番号を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:udp_destination_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットのUDPの宛先ポート番号を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:vlan?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットにVLANヘッダが付いている場合 <code>true</code> を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:vlan_vid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLANのVIDを返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:vlan_priority</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLANの優先度を返す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ether_type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">イーサタイプを返す</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>このようなメソッドは他にもたくさんあります。完全なメソッドのリストや詳しい情報を知りたい場合には、<a href="#hello_trema">3 章「Hello, Trema!」</a>で紹介した Trema ホームページを参照してください。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flow_mod_の送り方">5.4.4. Flow Mod の送り方</h4>
<div class="paragraph">
<p>Cbenchの仕様によると、コントローラからCbenchへと送るFlow Modメッセージは、次の内容にセットする必要があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>マッチフィールド: Packet In メッセージのExactMatch (後述)</p>
</li>
<li>
<p>アクション: Packet In メッセージのin_portに+1したポートへ転送</p>
</li>
<li>
<p>バッファID: Packet In メッセージのバッファID</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>それぞれの指定方法を順に見ていきましょう。</p>
</div>
<div class="sect4">
<h5 id="_マッチフィールド_openflow_1_0">マッチフィールド (OpenFlow 1.0)</h5>
<div class="paragraph">
<p>マッチフィールドを指定するには、<code>send_flow_mod_add</code> の引数に <code>match:</code> オプションとしてマッチフィールドオブジェクト (<code>Match.new(&#8230;&#8203;)</code> または <code>ExactMatch.new(&#8230;&#8203;)</code>) を渡します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_flow_mod_add(
  datapath_id,
  <span class="key">match</span>: <span class="constant">Match</span>.new(...), <i class="conum" data-value="1"></i><b>(1)</b>
  ...
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>マッチフィールドを指定する <code>match:</code> オプション</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>マッチフィールドを作るには、<code>Match.new</code> に指定したい条件のオプションを渡します。たとえば、送信元 MAC アドレスが 00:50:56:c0:00:08 で VLAN ID が 3 というルールを指定したマッチフィールドを Flow Mod に指定するコードは、次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_flow_mod_add(
  datapath_id,
  <span class="key">match</span>: <span class="constant">Match</span>.new(
           <span class="key">source_mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">00:50:56:c0:00:08</span><span class="delimiter">'</span></span>
           <span class="key">vlan_vid</span>: <span class="integer">3</span>
         )
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>OpenFlow 1.0 において指定できるマッチフィールドは 12 種類です。<code>Match.new</code> のオプションには、以下の12種類の条件を指定できます(<a href="#match_field_1.0">表5-2</a>)。</p>
</div>
<table id="match_field_1.0" class="tableblock frame-all grid-all spread">
<caption class="title">Table 15. マッチフィールドを作る Match.new のオプション</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">オプション</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:in_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">スイッチの物理ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:source_mac_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元MACアドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:destination_mac_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先MACアドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ether_type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">イーサネットの種別</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:source_ip_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元IPアドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:destination_ip_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先IPアドレス</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ip_protocol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPのプロトコル種別</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:tos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPのToSフィールド</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:transport_source_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP/UDPの送信元ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:transport_destination_port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP/UDPの宛先ポート番号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:vlan_vid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLAN IDの値</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:vlan_priority</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLANのプライオリティ</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#openflow_spec">2章「OpenFlow の仕様」</a>で説明したように、OpenFlow 1.3 でマッチフィールドは 40 種類に増えました。しかし、OpenFlow 1.3 での Match オブジェクトのオプションの指定方法は、OpenFlow 1.0 の場合と変わりません。詳しくは OpenFlow 1.3 を扱う <a href="#learning_switch13">8章「OpenFlow1.3版ラーニングスイッチ」</a>や<a href="#router13">14章「ルータ (マルチプルテーブル編)」</a>を参照してください。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_exact_matchの作り方_openflow_1_0">Exact Matchの作り方 (OpenFlow 1.0)</h6>
<div class="paragraph">
<p>マッチフィールドの中でもすべての条件を指定したものをExact Matchと呼びます。たとえばPacket Inとしてコントローラに入ってきたパケットとマッチフィールドが定義する12個の条件がすべてまったく同じ、というのがExact Matchです。</p>
</div>
<div class="paragraph">
<p>マッチフィールドを作る構文 <code>Match.new</code> にこの12種類の条件すべてを渡せば、次のようにExact Matchを作れます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
  ...
  send_flow_mod_add(
    datapath_id,
    <span class="key">match</span>: <span class="constant">Match</span>.new(
             <span class="key">in_port</span>: packet_in.in_port,
             <span class="key">source_mac_address</span>: packet_in.source_mac_address,
             <span class="key">destination_mac_address</span>: packet_in.destination_mac_address,
             ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>しかし、マッチフィールドを1つ作るだけで12行も書いていたら大変です。そこで、TremaではPacket InメッセージからExact Matchを楽に書ける次のショートカットを用意しています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_out</span>(datapath_id, packet_in)
  send_flow_mod_add(
    datapath_id,
    <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>たった1行で書けました! Tremaにはこのようにコードを短く書ける工夫がたくさんあります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ExactMatch が使えるのは OpenFlow 1.0 のみです。OpenFlow 1.3 ではマッチフィールドの種類が増えたため、ExactMatch は廃止されました。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_アクション_openflow1_0">アクション (OpenFlow1.0)</h5>
<div class="paragraph">
<p>アクションを指定するには、<code>send_flow_mod_add</code> の引数に <code>actions:</code> オプションとして単体のアクションまたはアクションのリストを渡します<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnote_13" title="View footnote.">13</a>]</sup>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_flow_mod_add(
  datapath_id,
  ...
  <span class="key">actions</span>: アクション <i class="conum" data-value="1"></i><b>(1)</b>
)

または

send_flow_mod_add(
  datapath_id,
  ...
  <span class="key">actions</span>: [アクション0, アクション1, アクション2, ...] <i class="conum" data-value="2"></i><b>(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>actions:</code> オプションでアクションを 1 つ指定</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>actions:</code> オプションにアクションを複数指定</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>たとえば、「VLAN ヘッダを除去しポート2番に転送」というアクションを Flow Mod に指定するコードは、次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_flow_mod_add(
  datapath_id,
  ...
  <span class="key">actions</span>: [<span class="constant">StripVlanHeader</span>.new, <span class="constant">SendOutPort</span>.new(<span class="integer">2</span>)] <i class="conum" data-value="1"></i><b>(1)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>アクションを 2 つ指定</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>アクションには<a href="#flow_mod_actions">表5-3</a>の13種類のアクションを単体で、または組み合わせて指定できます。</p>
</div>
<table id="flow_mod_actions" class="tableblock frame-all grid-all spread">
<caption class="title">Table 16. 指定できるアクション</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">アクション</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SendOutPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したスイッチポートにパケットを出力する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetEtherSourceAddress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元MACアドレスを指定した値に書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetEtherDestinationAddress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先MACアドレスを指定した値に書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetIpSourceAddress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">送信元のIPアドレスを指定した値に書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetIpDstinationAddress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宛先のIPアドレスを指定した値に書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetIpTos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPのToSフィールドを書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetTransportSourcePort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP/UDPの送信元ポート番号を書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetTransportDestinationPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP/UDPの宛先ポート番号を書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StripVlanHeader</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLANのヘッダを除去する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetVlanVid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したVLAN IDをセットする、または既存のものがあれば書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SetVlanPriority</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したVLANプライオリティをセットする、または既存のものがあれば書き換える</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enqueue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したスイッチポートのキューにパケットを入れる</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VendorAction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ベンダ定義の独自拡張アクションを実行する</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>まだ使っていないアクションについては、続く章で具体的な使い方を見ていきます。</p>
</div>
</div>
<div class="sect4">
<h5 id="_send_flow_mod_add_のオプション">send_flow_mod_add のオプション</h5>
<div class="paragraph">
<p>バッファIDを指定するには、<code>buffer_id:</code> オプションを <code>send_flow_mod_add</code> の引数に指定します。たとえば次のコードは、バッファ ID に Packet Inメッセージのバッファ ID を指定する典型的な例です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_flow_mod_add(
  datapath_id,
  <span class="key">match</span>: ...,
  <span class="key">actions</span>: ...,
  <span class="key">buffer_id</span>: packet_in.buffer_id <i class="conum" data-value="1"></i><b>(1)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Flow Mod のオプションにバッファ ID を指定</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>send_flow_mod_add</code> で指定できるすべてのオプションは<a href="#send_flow_mod_add_options">表5-4</a>の通りです。</p>
</div>
<table id="send_flow_mod_add_options" class="tableblock frame-all grid-all spread">
<caption class="title">Table 17. send_flow_mod_addで指定できるオプション</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">オプション</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:match</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フローエントリのマッチフィールドを指定する。本章で紹介した <code>Match</code> オブジェクトまたは <code>ExactMatch</code> オブジェクトを指定する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:actions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フローエントリのアクションを指定する。アクションには単体のアクションまたは複数のアクションを配列 (<a href="#switch_monitor">4章</a>で解説) によって指定できる</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:buffer_id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">アクションが参照するパケットがバッファされている領域の ID を指定する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:idle_timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フローエントリが一定時間参照されなかった場合に破棄されるまでの秒数を指定する。デフォルトは0秒で、この場合フローエントリは破棄されない</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:hard_timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フローエントリの寿命を秒数で指定する。デフォルトは0秒で、この場合フローエントリは破棄されない</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:priority</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">フローエントリの優先度(符号なし16ビット、大きいほど優先度高)。Packet Inメッセージはこの優先度順にフローエントリのマッチフィールドと照らし合わされる。デフォルトは <code>0xffff</code> (最高優先度)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:send_flow_removed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">タイムアウトでフローエントリが消えるときに、Flow Removedメッセージをコントローラに送るかどうかを指定する。デフォルトは <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:check_overlap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> にセットすると、フローテーブルの中に同じ優先度で競合するものがあった場合、フローエントリを追加せずにエラーを起こす。デフォルトは <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:emerg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> にセットすると、フローエントリを緊急エントリとして追加する。緊急エントリはスイッチが何らかの障害でコントローラと切断したときにのみ有効となる。デフォルトは <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:cookie</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意の用途に使える64ビットの整数。使い道としては、同じクッキー値を持つフローエントリ同士をまとめて管理するなどといった用途がある</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>こうしたオプションも、続くいくつかの章で具体的な使い方を紹介します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>OpenFlow1.0 では<a href="#openflow_spec">2章「OpenFlow の仕様」</a>で解説したインストラクションは使いません。そのためインストラクションの代わりに、アクションを直接フローエントリに指定します。OpenFlow 1.3 でのインストラクションの使い方は、<a href="#learning_switch13">8章「OpenFlow1.3版ラーニングスイッチ」</a>にて詳しく説明します。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_マルチスレッド化する">5.5. マルチスレッド化する</h3>
<div class="paragraph">
<p>Tremaはシングルスレッドで動作するので、実のところ Cbench の結果はあまり速くありません。シングルスレッドとはつまり、同時に1つの <code>packet_in</code> ハンドラしか実行できないという意味です。たとえ cbench プロセスがたくさん Packet In メッセージを送ってきても、Trema は順に 1 つひとつ処理するため遅くなります。</p>
</div>
<div class="paragraph">
<p>Trema がシングルスレッドである理由は、マルチスレッドプログラミング由来のやっかいなバグを避けるためです。たとえば次のようなマルチスレッドで動作する <code>multi_threaded_packet_in</code> というハンドラがあったとして、この中でスレッドセーフでない変数の内容を変更すると、タイミングや環境に起因するやっかいなバグが発生してしまいます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  <span class="instance-variable">@db</span> = <span class="constant">DB</span>.new  <i class="conum" data-value="1"></i><b>(1)</b>
<span class="keyword">end</span>

<span class="comment"># マルチスレッド版 packet_in ハンドラ</span>
<span class="keyword">def</span> <span class="function">multi_threaded_packet_in</span>(datapath_id, packet_in)  <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="comment"># !!! ここで @db の読み書きは危険 !!!</span>
  <span class="keyword">return</span> <span class="keyword">if</span> <span class="instance-variable">@db</span>.lookup(packet_in.in_port)
  <span class="instance-variable">@db</span>.add packet_in.source_mac_address, packet_in.in_port
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スレッドセーフでないインスタンス変数</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>独立したスレッドで動く Packet In ハンドラ</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>マルチスレッドプログラミングでは、スレッド間で共有するリソースに競合が起こらないように、注意深くコードを書く必要があるのです。</p>
</div>
<div class="sect3">
<h4 id="_排他制御">5.5.1. 排他制御</h4>
<div class="paragraph">
<p>スレッド間の競合を解決する代表的な方法が Mutex による排他制御です。スレッド間で競合の起こる箇所を Mutex で囲むことで、その箇所へは同時に 1 つのスレッドしか入れなくなります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  <span class="instance-variable">@db</span> = <span class="constant">DB</span>.new
  <span class="instance-variable">@mutex</span> = <span class="constant">Mutex</span>.new  <i class="conum" data-value="1"></i><b>(1)</b>
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">multi_threaded_packet_in</span>(datapath_id, packet_in)
  <span class="instance-variable">@mutex</span>.synchronize <span class="keyword">do</span>  <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="comment"># この中で@dbを読み書きすれば安全</span>
    <span class="keyword">return</span> <span class="keyword">if</span> <span class="instance-variable">@db</span>.lookup(packet_in.in_port)
    <span class="instance-variable">@db</span>.add packet_in.source_mac_address, packet_in.in_port
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>排他制御用の Mutex</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>do&#8230;&#8203;end</code> の中には同時に 1 つのスレッドしか入れない</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>これでひとまず競合は回避できたので、<code>packet_in</code> をスレッド化してみましょう。次のように高速化したいハンドラメソッドの中身を別スレッドで起動し、インスタンス変数へのアクセスを Mutex で排他制御してやります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  <span class="instance-variable">@db</span> = <span class="constant">DB</span>.new
  <span class="instance-variable">@mutex</span> = <span class="constant">Mutex</span>.new
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
  <span class="constant">Thread</span>.start <span class="keyword">do</span>  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="instance-variable">@mutex</span>.synchronize <span class="keyword">do</span>
      <span class="keyword">return</span> <span class="keyword">if</span> <span class="instance-variable">@db</span>.lookup(packet_in.in_port)
      <span class="instance-variable">@db</span>.add packet_in.source_mac_address, packet_in.in_port
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>packet_in</code> ハンドラの中身をスレッドで起動</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>しかし、これでもまだ問題は残ります。<code>Thread.start</code> によるスレッド起動はそれなりにコストのかかる処理なので、Packet In が届くたびに <code>Tread.new</code> でスレッドを作っていては速くなりません。</p>
</div>
<div class="paragraph">
<p>そこで、次のようにあらかじめいくつかワーカースレッドを作って待機させておく、いわゆるスレッドプールという手法が使えます。そして <code>packet_in</code> ハンドラが呼ばれるたびに待機中のスレッドに <code>packet_in</code> の処理をまかせます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  <span class="instance-variable">@db</span> = <span class="constant">DB</span>.new
  <span class="instance-variable">@mutex</span> = <span class="constant">Mutex</span>.new
  <span class="instance-variable">@work_queue</span> = <span class="constant">Queue</span>.new  <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="integer">10</span>.times { start_worker_thread }  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
  <span class="instance-variable">@work_queue</span>.push [datapath_id, packet_in]  <i class="conum" data-value="3"></i><b>(3)</b>
<span class="keyword">end</span>

private

<span class="comment"># ワーカースレッドを開始</span>
<span class="keyword">def</span> <span class="function">start_worker_thread</span>  <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="constant">Thread</span>.new <span class="keyword">do</span>
    loop <span class="keyword">do</span>
      datapath_id, packet_in = <span class="instance-variable">@work_queue</span>.pop  <i class="conum" data-value="5"></i><b>(5)</b>
      <span class="instance-variable">@mutex</span>.synchronize <span class="keyword">do</span>
        <span class="keyword">next</span> <span class="keyword">if</span> <span class="instance-variable">@db</span>.lookup(packet_in.in_port)
        <span class="instance-variable">@db</span>.add packet_in.source_mac_address, packet_in.in_port
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スレッドにまかせたい仕事を入れておくキュー</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>スレッドプールに 10 個のスレッドを追加</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Packet In が届いたら datapath_id と Packet In をキューに入れる</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>ワーカースレッドを起動するプライベートメソッド</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>スレッドの中でキューから datapath_id と Packet In を取り出す。Queue クラスはスレッドセーフなので、<code>@mutex.synchronize do &#8230;&#8203; end</code> の中に入れる必要はないことに注意</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このスレッドプールを使った、最終的なマルチスレッド版 Cbench コントローラは次のようになります。</p>
</div>
<div class="listingblock">
<div class="title">lib/multi_threaded_cbench.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># A simple openflow controller for benchmarking (multi-threaded version).</span>
<span class="keyword">class</span> <span class="class">MultiThreadedCbench</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    <span class="instance-variable">@work_queue</span> = <span class="constant">Queue</span>.new
    <span class="integer">10</span>.times { start_worker_thread }
    logger.info <span class="string"><span class="delimiter">'</span><span class="content">Cbench started.</span><span class="delimiter">'</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
    <span class="instance-variable">@work_queue</span>.push [datapath_id, packet_in]
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">start_worker_thread</span>
    <span class="constant">Thread</span>.new <span class="keyword">do</span>
      loop <span class="keyword">do</span>
        datapath_id, packet_in = <span class="instance-variable">@work_queue</span>.pop
        send_flow_mod_add(datapath_id,
                          <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
                          <span class="key">buffer_id</span>: packet_in.buffer_id,
                          <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(packet_in.in_port + <span class="integer">1</span>))
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>実際に性能を計測してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run lib/multi_threaded_cbench.rb</pre>
</div>
</div>
<div class="paragraph">
<p>別ターミナルで Cbench を起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/cbench --port 6653 --switches 1 --loops 10 --ms-per-test 10000 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6653
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  748   total = 0.074746 per ms
1   switches: fmods/sec:  714   total = 0.071319 per ms
1   switches: fmods/sec:  705   total = 0.070448 per ms
1   switches: fmods/sec:  704   total = 0.070376 per ms
1   switches: fmods/sec:  718   total = 0.071747 per ms
1   switches: fmods/sec:  734   total = 0.073346 per ms
1   switches: fmods/sec:  739   total = 0.073763 per ms
1   switches: fmods/sec:  736   total = 0.073487 per ms
1   switches: fmods/sec:  732   total = 0.073146 per ms
1   switches: fmods/sec:  730   total = 0.072917 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 70.38/73.76/72.28/1.25 responses/s</pre>
</div>
</div>
<div class="paragraph">
<p>おや？シングルスレッド版よりも若干遅くなってしまいました。これには 2 つの原因があります。まず、Ruby のスレッドは OS のネイティブスレッドであるため、スレッド切り替えのオーバーヘッドが大きくかかります。しかも、Packet In 処理は一瞬で終わるため、マルチスレッド化しても並列性はあまり上がりません。これらの原因から、マルスレッド化によって新たにスレッド切り替えのオーバーヘッドがかかった分、元のバージョンより遅くなってしまったのです。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_無理やり高速化する">5.6. 無理やり高速化する</h3>
<div class="paragraph">
<p>ほかに高速化の方法はないでしょうか。実は cbench プロセスが送ってくる Packet In はすべて同じ中身なので、cbench プロセスへ送る Flow Mod メッセージを何度も使いまわすことで簡単に高速化できます。最初のコードでは Packet In ハンドラの中で <code>send_flow_mod_add</code> で毎回 Flow Mod メッセージを作り直していました。この無駄な処理をなくすために、一度作った Flow Mod メッセージをキャッシュしておいて、2 回目以降はキャッシュした Flow Mod を <code>send_message</code> で送るのです。</p>
</div>
<div class="paragraph">
<p>このキャッシュによって高速化したものがこちらです。ただしこれはただ Cbench のために無理やり高速化したコードなので、すべてを理解する必要はありません。</p>
</div>
<div class="listingblock">
<div class="title">lib/fast_cbench.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># A simple openflow controller for benchmarking (fast version).</span>
<span class="keyword">class</span> <span class="class">FastCbench</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_in</span>(dpid, packet_in)
    <span class="instance-variable">@flow_mod</span> ||= create_flow_mod_binary(packet_in) <i class="conum" data-value="1"></i><b>(1)</b>
    send_message dpid, <span class="instance-variable">@flow_mod</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">create_flow_mod_binary</span>(packet_in)
    options = {
      <span class="key">command</span>: <span class="symbol">:add</span>,
      <span class="key">priority</span>: <span class="integer">0</span>,
      <span class="key">transaction_id</span>: <span class="integer">0</span>,
      <span class="key">idle_timeout</span>: <span class="integer">0</span>,
      <span class="key">hard_timeout</span>: <span class="integer">0</span>,
      <span class="key">buffer_id</span>: packet_in.buffer_id,
      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(packet_in.in_port + <span class="integer">1</span>)
    }
    <span class="constant">FlowMod</span>.new(options).to_binary.tap <span class="keyword">do</span> |flow_mod| <i class="conum" data-value="3"></i><b>(3)</b>
      <span class="keyword">def</span> flow_mod.<span class="function">to_binary</span>
        <span class="predefined-constant">self</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>最初は <code>@flow_mod</code> が <code>nil</code> なので、最初だけ <code>create_flow_mod_binary</code> で Flow Mod メッセージを作る。二回目以降は呼ばれない</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>キャッシュした Flow Mod メッセージを cbench プロセスに送る</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>send_message</code> のときに Trema が呼び出す <code>FlowMod#to_binary</code> を軽くするため、キャッシュしたバイナリを返す特異メソッドを定義</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>実行結果は次のようになります。秒間約 6000 発の Flow Mod が打てており、元のバージョンに比べて 10 倍近く高速化できました!</p>
</div>
<div class="listingblock">
<div class="content">
<pre>cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6653
   faking 1 switches :: 10 tests each; 10000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  6741   total = 0.674018 per ms
1   switches: fmods/sec:  6400   total = 0.639859 per ms
1   switches: fmods/sec:  6508   total = 0.650710 per ms
1   switches: fmods/sec:  6334   total = 0.633349 per ms
1   switches: fmods/sec:  6325   total = 0.632465 per ms
1   switches: fmods/sec:  6293   total = 0.629207 per ms
1   switches: fmods/sec:  6276   total = 0.627579 per ms
1   switches: fmods/sec:  6332   total = 0.633133 per ms
1   switches: fmods/sec:  6219   total = 0.621860 per ms
1   switches: fmods/sec:  6293   total = 0.629266 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 621.86/650.71/633.05/7.77 responses/s</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Cbenchの注意点</div>
<div class="paragraph">
<p>Cbench のスコアを盲信しないようにしてください。現在、OpenFlow コントローラの多くがその性能指標として Cbench のスコアを使っているのをよく見掛けます。たとえば Floodlight (<a href="http://www.projectfloodlight.org/" class="bare">http://www.projectfloodlight.org/</a>) は 1 秒間に 100 万発の Flow Mod を打てると宣伝しています。実際にこれはなかなかすごい数字です。スレッドを駆使してめいっぱい I/O を使い切るようにしなければなかなかこの数字は出ません。でも、この数字はほとんど無意味です。</p>
</div>
<div class="paragraph">
<p>Flow Mod を 1 秒間に 100 万発打たなければならない状況を考えてみてください。それは、Packet In が 1 秒間に 100 万回起こるということになります。Packet In が 1 秒間に 100 万発起こるとはどういうことでしょうか。スイッチで処理できないパケットがすべてコントローラへやってくる、これが 1 秒間に 100 万回も起こるということです。明らかにフローテーブルの設計がうまく行っていません。</p>
</div>
<div class="paragraph">
<p>コントローラが Packet In を何発さばけるかという性能は、極端に遅くない限りは重要ではありません。データセンターのように、どこにどんなマシンがありどういう通信をするか把握できている場合は、フローテーブルをちゃんと設計していれば Packet In はそんなに起こらないからです。力技で Packet In をさばくよりも、いかに Packet In が起こらないフローテーブル設計をするかの方がずっと大事です。</p>
</div>
<div class="paragraph">
<p>Cbench のようなマイクロベンチマークでは、測定対象が何でその結果にはどんな意味があるかを理解しないと、針小棒大な結論を招きます。Cbench のスコアは参考程度にとどめましょう。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_5">5.7. まとめ</h3>
<div class="paragraph">
<p>Packet InとFlow Modの最初の一歩として、ベンチマークツールCbenchと接続できるコントローラを書きました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>フローエントリを追加するための <code>send_flow_mod_add</code> を使って、スイッチのフローテーブルを書き換える方法を学んだ</p>
</li>
<li>
<p>マッチフィールドの作り方と、指定できるルールを学んだ</p>
</li>
<li>
<p>SendOutPort アクションによるパケットの転送と、その他のアクションを学んだ</p>
</li>
<li>
<p>コントローラをマルチスレッド化する方法を学んだ</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>OpenFlow プログラミングの基礎はできたので、そろそろ実用的なツールを作ってみましょう。続く章では、遠隔操作可能なソフトウェアパッチパネルを作ります。もう、ネットワークケーブルを挿し替えるためだけにサーバルームまで出向く必要はなくなります。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="patch_panel">6. インテリジェントなパッチパネル</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>日々のネットワーク管理に役立ち、さらにネットワーク仮想化の入門にもなるのがこのOpenFlowで作るパッチパネルです。そのうえソースコードも簡単とくれば、試さない手はありません。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/patch_panel/cables.png" alt="cables">
</div>
</div>
<div class="sect2">
<h3 id="_便利なインテリジェント_パッチパネル">6.1. 便利なインテリジェント・パッチパネル</h3>
<div class="paragraph">
<p>無計画にネットワークを構築すると、ケーブルの配線は悲惨なまでにごちゃごちゃになります。からみあったケーブルのせいで見通しが悪くなり、そのままさらにスイッチやサーバを増築していくと配線のやり直しとなります。こうなってしまう一番の原因は、スイッチとスイッチ、スイッチとサーバをケーブルで直接つないでしまうことです。これでは、つなぐものを増やせば増やすほどごちゃごちゃになっていくのは当然です。</p>
</div>
<div class="paragraph">
<p>これを解消するのがパッチパネルという装置です (<a href="#patch_panel_overview">図 6-1</a>)。パッチパネルの仕組みはシンプルで、ケーブルを挿すためのコネクタがずらりと並んでいて、配線をいったんパッチパネルで中継できるようになっています。スイッチやサーバをいったん中継点となるパッチパネルにつなぎ、パッチパネル上の変更だけで全体の配線を自由に変更できるので、ケーブルがすっきりし拡張性も向上します。</p>
</div>
<div id="patch_panel_overview" class="imageblock">
<div class="content">
<img src="images/patch_panel/patch_panel.png" alt="patch panel">
</div>
<div class="title">図 6-1: ごちゃごちゃした配線をパッチパネルですっきりと</div>
</div>
<div class="paragraph">
<p>パッチパネルをさらに便利にしたのが、いわゆるインテリジェント・パッチパネルです。インテリジェント・パッチパネルとは、パッチパネルをネットワーク経由で操作できるようにしたものです。従来のパッチパネルでは、メンテナンス性は向上できるとしても、配線を変更するたびにサーバ室まで足を運ぶという面倒さがありました。インテリジェント・パッチパネルを使えば、居室にいながらリモートでパッチパネルの配線を変更できるようになります。</p>
</div>
</div>
<div class="sect2">
<h3 id="_openflow版インテリジェント_パッチパネル">6.2. OpenFlow版インテリジェント・パッチパネル</h3>
<div class="paragraph">
<p>インテリジェント・パッチパネルはOpenFlowで簡単に実装できます。パッチパネルでの中継のように、パケットを指定したコネクタからコネクタへ転送するというのは、フローエントリの代表的な使い方の一つだからです。</p>
</div>
<div class="paragraph">
<p>OpenFlowで実装したパッチパネルは<a href="#openflow_patch_panel">図 6-2</a> のようになります。OpenFlowスイッチをパッチパネルに見立てて、接続を中継したいデバイス(ホストまたはスイッチ)をつなげます。コントローラはパケット転送のルールをフローエントリとしてOpenFlowスイッチに書き込むことで、仮想的なパッチを作ります。</p>
</div>
<div id="openflow_patch_panel" class="imageblock">
<div class="content">
<img src="images/patch_panel/openflow_patch_panel.png" alt="openflow patch panel">
</div>
<div class="title">図 6-2: OpenFlowで実現するパッチパネルの仕組み</div>
</div>
<div class="paragraph">
<p>たとえば<a href="#openflow_patch_panel">図 6-2</a> のように、ポート1番と5番をつなげる場合を考えましょう。必要なフローエントリは次の2つです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ポート1番に入力したパケットをポート5番に出力する</p>
</li>
<li>
<p>ポート5番に入力したパケットをポート1番に出力する</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>フローエントリの構成要素には、「こういうパケットが届いたとき」というマッチフィールドと、「こうする」というアクションがあるのでした。パッチパネルの場合、「ポートx番に入力」がマッチフィールドで、「ポートy番に出力」がアクションです。</p>
</div>
<div class="paragraph">
<p>それでは仕組みがわかったところで、パッチパネルコントローラを動かしてみましょう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_3">6.3. 実行してみよう</h3>
<div class="paragraph">
<p>パッチパネルのソースコードはGitHubのtrema/patch_panelリポジトリ (<a href="https://github.com/trema/patch_panel" class="bare">https://github.com/trema/patch_panel</a>) からダウンロードできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/patch_panel.git</pre>
</div>
</div>
<div class="paragraph">
<p>ダウンロードしたソースツリー上で <code>bundle install --binstubs</code> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd patch_panel
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>以上でパッチパネルとTremaのセットアップは完了です。</p>
</div>
<div class="paragraph">
<p>パッチパネルのソースコードで主なファイルは次の 3 つです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lib/patch_panel.rb</code>: パッチパネル本体</p>
</li>
<li>
<p><code>patch_panel.conf</code>: 仮想ネットワーク設定ファイル</p>
</li>
<li>
<p><code>bin/patch_panel</code>: パッチパネルの操作コマンド</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_仮想ネットワークの設定">6.3.1. 仮想ネットワークの設定</h4>
<div class="paragraph">
<p>仮想ネットワーク設定ファイル <code>patch_panel.conf</code> では、パッチパネルの動作テストのためにパケットを送受信できる仮想ホストを定義しています。<code>vhost</code> で始まる行が仮想ホスト、そして <code>link</code> で始まる行がスイッチやホストをつなげるための仮想リンクです。</p>
</div>
<div class="listingblock">
<div class="title">patch_panel.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch(<span class="string"><span class="delimiter">'</span><span class="content">patch_panel</span><span class="delimiter">'</span></span>) { datapath_id <span class="integer">0xabc</span> }

vhost (<span class="string"><span class="delimiter">'</span><span class="content">host1</span><span class="delimiter">'</span></span>) { ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.1</span><span class="delimiter">'</span></span> }
vhost (<span class="string"><span class="delimiter">'</span><span class="content">host2</span><span class="delimiter">'</span></span>) { ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.2</span><span class="delimiter">'</span></span> }
vhost (<span class="string"><span class="delimiter">'</span><span class="content">host3</span><span class="delimiter">'</span></span>) { ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.3</span><span class="delimiter">'</span></span> }

link <span class="string"><span class="delimiter">'</span><span class="content">patch_panel</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host1</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">patch_panel</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host2</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">patch_panel</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host3</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この設定ファイルでは仮想スイッチ <code>0xabc</code> に 3 つの仮想ホスト <code>host1</code>, <code>host2</code>, <code>host3</code> を接続しています (<a href="#patch_panel_configuration">図 6-3</a>)。仮想スイッチと仮想ホストの接続は、仮想リンク (<code>link</code> で始まる行) によって記述できます。<code>link</code> を書いた順で、それぞれのホストはスイッチのポート 1 番、ポート 2 番、ポート 3 番、&#8230;&#8203; に接続されます。</p>
</div>
<div id="patch_panel_configuration" class="imageblock">
<div class="content">
<img src="images/patch_panel/configuration.png" alt="configuration">
</div>
<div class="title">図 6-3設定ファイル patch_panel.conf の仮想ネットワーク構成</div>
</div>
<div class="paragraph">
<p>パッチパネルをこの仮想ネットワーク内で実行するには、仮想ネットワーク設定ファイルを <code>trema run</code> の <code>-c</code> オプションに渡します。次のように <code>trema run</code> コマンドでパッチパネルコントローラを起動してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/patch_panel.rb -c patch_panel.conf</pre>
</div>
</div>
<div class="paragraph">
<p>パッチパネルは起動しただけではまだパッチングされていないので、ホスト間でのパケットは通りません。これを確認するために、<code>trema send_packets</code> コマンドを使ってhost1とhost2の間でテストパケットを送ってみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1</pre>
</div>
</div>
<div class="paragraph">
<p>正常に動いていれば、それぞれのホストでの受信パケット数は0になっているはずです。これを確認できるのが <code>trema show_stats</code> コマンドです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p><code>trema show_stats</code> コマンドは引数として渡したホストの送受信パケットを表示します。host1 と host2 の両ホストともパケットを 1 つ送信していますが、どちらにもパケットは届いていません。</p>
</div>
<div class="paragraph">
<p>パッチパネルの設定は <code>./bin/patch_panel</code> コマンドで指定できます。たとえば、スイッチ 0xabc のポート 1 番とポート 2 番をつなぐには次のコマンドを実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/patch_panel create 0xabc 1 2</pre>
</div>
</div>
<div class="paragraph">
<p>これで、host1 と host2 が通信できるはずです。もういちどパケットの送受信を試してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1
$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 2 packets
Packets received:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 2 packets
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p>たしかにパケットが届いています。パッチパネルの動作イメージがわかったところで、ソースコードを見ていきます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ソースコード解説_3">6.4. ソースコード解説</h3>
<div class="paragraph">
<p>パッチパネルのソースコードは<a href="#patch_panel.rb">lib/patch_panel.rb</a>です。</p>
</div>
<div id="patch_panel.rb" class="listingblock">
<div class="title">lib/patch_panel.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Software patch-panel.</span>
<span class="keyword">class</span> <span class="class">PatchPanel</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">start</span>(_args)
    <span class="instance-variable">@patch</span> = <span class="constant">Hash</span>.new([].freeze)
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
    <span class="instance-variable">@patch</span>[dpid].each <span class="keyword">do</span> |port_a, port_b|
      delete_flow_entries dpid, port_a, port_b
      add_flow_entries dpid, port_a, port_b
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">create_patch</span>(dpid, port_a, port_b)
    add_flow_entries dpid, port_a, port_b
    <span class="instance-variable">@patch</span>[dpid] += [port_a, port_b].sort
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">delete_patch</span>(dpid, port_a, port_b)
    delete_flow_entries dpid, port_a, port_b
    <span class="instance-variable">@patch</span>[dpid] -= [port_a, port_b].sort
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">add_flow_entries</span>(dpid, port_a, port_b)
    send_flow_mod_add(dpid,
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_a),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_b))
    send_flow_mod_add(dpid,
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_b),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_a))
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">delete_flow_entries</span>(dpid, port_a, port_b)
    send_flow_mod_delete(dpid, <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_a))
    send_flow_mod_delete(dpid, <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_b))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>今までに学んだ知識で、このコードをできるだけ解読してみましょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>パッチパネルの本体はPatchPanelという名前の小さなクラスである</p>
</li>
<li>
<p>このクラスには<a href="#hello_trema">3 章「Hello, Trema!」</a>で学んだ <code>switch_ready</code> ハンドラが定義してあり、この中で <code>delete_flow_entries</code> と <code>add_flow_entries</code> いうプライベートメソッドを呼んでいる。どうやらこれがパッチ処理の本体だ</p>
</li>
<li>
<p><code>create_patch</code> と <code>delete_patch</code> というメソッドが定義してある。これらがパッチの作成と削除に対応していると予想できる</p>
</li>
<li>
<p><code>add_flow_entries</code> メソッドでは <code>send_flow_mod_add</code> を2回呼んでいる。1つのパッチを作るのに2つのフローエントリが必要なので、2回呼んでいるのだろうと推測できる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ここまでわかればしめたものです。あらかじめパッチパネルの仕組みを押さえていたので、ソースコードを読むのも簡単です。それでは、各部分のソースコードを詳しく見ていきましょう。</p>
</div>
<div class="sect3">
<h4 id="_startハンドラ_2">6.4.1. startハンドラ</h4>
<div class="paragraph">
<p>startハンドラではコントローラを初期化します。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#start (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(_args)
  <span class="instance-variable">@patch</span> = <span class="constant">Hash</span>.new([].freeze)
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@patch</code> は現在のパッチング情報を入れておくハッシュテーブル (後述) です。このハッシュテーブルは、キーにスイッチの Datapath ID、バリューに現在のパッチ情報を持ちます。たとえば、スイッチ 0x1 のポート 1 番と 4 番をパッチングし、スイッチ 0x2 のポート 1 番と 2 番、および 3 番と 4 番をパッチングした場合、<code>@patch</code> の中身は次のようになります。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datapath ID (キー)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パッチ情報 (バリュー)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[[1, 4]]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[[1, 2], [3, 4]]</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Rubyのイディオム <code>Hash.new([].freeze)</code></div>
<div class="paragraph">
<p><code>Hash.new</code> の引数 (バリューの初期値) である <code>[].freeze</code> はハッシュテーブルの初期値が変わらないようにするための Ruby のイディオムです。もしも、<code>.freeze</code> していない初期値 <code>[]</code> に対して <code>&lt;&lt;</code> などの破壊的な操作をすると、次のように初期値が壊れてしまいます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hash = Hash.new([])

p hash[1]          #=&gt; []
p hash[1] &lt;&lt; "bar" #=&gt; ["bar"]
p hash[1]          #=&gt; ["bar"]

p hash[2]          #=&gt; ["bar"] #初期値が ["bar"] になってしまった</pre>
</div>
</div>
<div class="paragraph">
<p>そこで、初期値を <code>.freeze</code> することで破壊的操作を禁止できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hash = Hash.new([].freeze)
hash[0] += [0] #破壊的でないメソッドはOK
hash[1] &lt;&lt; 1
# エラー `&lt;&lt;': can't modify frozen array (TypeError)</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ハッシュテーブル">6.4.2. ハッシュテーブル</h4>
<div class="paragraph">
<p><strong>ハッシュテーブル</strong>は中カッコで囲まれた (<code>{}</code>) 辞書です。辞書とは「言葉をその定義に対応させたデータベース」です。Rubyでは、この対応を <code>:</code> という記号で次のように表します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">animals = { <span class="key">armadillo</span>: <span class="string"><span class="delimiter">'</span><span class="content">アルマジロ</span><span class="delimiter">'</span></span>, <span class="key">boar</span>: <span class="string"><span class="delimiter">'</span><span class="content">イノシシ</span><span class="delimiter">'</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>たとえば ”boar” を日本語で言うと何だろう? と辞書で調べたくなったら、次のようにして辞書を引きます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">animals[<span class="symbol">:boar</span>] <span class="comment">#=&gt; &quot;イノシシ&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この辞書を引くときに使う言葉 (この場合は <code>:boar</code>) をキーと言います。そして、見つかった定義 (この場合はイノシシ) をバリューと言います。</p>
</div>
<div class="paragraph">
<p>新しい動物を辞書に加えるのも簡単です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">animals[<span class="symbol">:cow</span>] = <span class="string"><span class="delimiter">'</span><span class="content">ウシ</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rubyのハッシュテーブルはとても高機能なので、文字列だけでなく好きなオブジェクトを格納できます。たとえば、パッチパネルでは Datapath ID をキーとして、パッチング情報 (配列) をバリューにします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="instance-variable">@patch</span>[<span class="integer">0x1</span>] = [[<span class="integer">1</span>, <span class="integer">2</span>], [<span class="integer">3</span>, <span class="integer">4</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>実は、すでにいろんなところでハッシュテーブルを使ってきました。たとえば、<code>send_flow_mod_add</code> などの省略可能なオプションは、コロン (<code>:</code>) を使っていることからもわかるように実はハッシュテーブルなのです。Rubyでは、引数の最後がハッシュテーブルである場合、その中カッコを次のように省略できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">flow_mod</span>(message, port_no)
  send_flow_mod_add(
    message.datapath_id,
    <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(message),
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no)
  )
<span class="keyword">end</span>

<span class="comment"># これと同じ</span>

<span class="keyword">def</span> <span class="function">flow_mod</span>(message, port_no)
  send_flow_mod_add(
    message.datapath_id,
    { <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(message),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no) }
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_switch_readyハンドラ">6.4.3. switch_readyハンドラ</h4>
<div class="paragraph">
<p><code>switch_ready</code> ハンドラは、起動してきたスイッチに対してパッチング用のフローエントリを書き込みます。すでにパッチ情報 <code>@patch</code> にフローエントリ情報が入っていた場合(スイッチがいったん停止して再接続した場合など)のみ、フローエントリを入れ直します。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#switch_ready (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
  <span class="instance-variable">@patch</span>[dpid].each <span class="keyword">do</span> |port_a, port_b| <i class="conum" data-value="1"></i><b>(1)</b>
    delete_flow_entries dpid, port_a, port_b <i class="conum" data-value="2"></i><b>(2)</b>
    add_flow_entries dpid, port_a, port_b <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@patch[dpid].each</code> はパッチング設定を 1 つずつ処理するイテレータ (後述)。仮引数は <code>port_a</code> と <code>port_b</code> の2つで、それぞれにパッチでつなぐポート番号が 1 つずつ入る</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>プライベートメソッド <code>delete_flow_entries</code> は古いフローエントリを消す。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>プライベートメソッド <code>add_flow_entries</code> がパッチング追加処理の本体。起動してきたスイッチのDatapath ID、およびパッチングするポート番号2つを引数に取る</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_イテレータ">6.4.4. イテレータ</h4>
<div class="paragraph">
<p><strong>イテレータ</strong>とは繰り返すものという意味で、繰り返し処理を短く書きたいときに使います。イテレータは一般に次の形をしています。</p>
</div>
<div class="listingblock">
<div class="title">よくあるイテレータの使用例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">fruits = [<span class="string"><span class="delimiter">&quot;</span><span class="content">バナナ</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">みかん</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">りんご</span><span class="delimiter">&quot;</span></span>]

fruits.each <span class="keyword">do</span> |each|
  puts each
<span class="keyword">end</span>

<span class="key">実行結果</span>:
バナナ
みかん
りんご</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは配列 <code>fruits</code> の <code>each</code> というイテレータで <code>fruits</code> の各要素をプリントアウトしています。<code>do</code> のあとにある <code>each</code> は fruits の各要素が入る仮引数です。この <code>each</code> にバナナ・みかん・りんごが順にセットされ、続くブロック (<code>do&#8230;&#8203;end</code>) が呼び出されます。</p>
</div>
<div class="paragraph">
<p>イテレータの利点は、同じ繰り返し処理をループで書いた場合よりもずっと簡単に書けることです。</p>
</div>
<div class="listingblock">
<div class="title">C 言語っぽい for ループで書いた場合</div>
<div class="content">
<pre>for (int i = 0; i &lt; 3; i++) {
  puts fruits[i];
}</pre>
</div>
</div>
<div class="paragraph">
<p>このように for ループで書くと、配列の要素にアクセスするための変数 <code>i</code> やループの終了条件 <code>i &lt; 3</code> などが必要になります。一方、イテレータはこうした煩雑なものを抽象化で見えなくしてくれるので、プログラマは各要素についてやりたいことだけをブロックに書けば動きます。</p>
</div>
<div class="paragraph">
<p>実は、<a href="#cbench">5 章「マイクロベンチマークCbench」</a>で登場した次のコードもイテレータです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># start_worker_thread メソッドを 10 回実行</span>
<span class="integer">10</span>.times { start_worker_thread }

<span class="comment"># または、下のようにも書ける</span>

<span class="comment"># n には 1〜10 が入る。ただしここでは n は使っていない</span>
<span class="integer">10</span>.times { |n| start_worker_thread }</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>times</code> がイテレータで、続くブロックの内容を 10 回実行します。もし仮引数を使わない場合は書かなくても OK です。これによって、「<code>10.times { start_worker_thread }</code> (10 回 start_worker_thread を呼ぶ)」といったふうに繰り返しを非常に直感的に書けます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_add_flow_entriesメソッド">6.4.5. add_flow_entriesメソッド</h4>
<div class="paragraph">
<p>1つのパッチ(2つのフローエントリ)を実際に書き込むのが <code>add_flow_entries</code> プライベートメソッドです。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#add_flow_entries (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_flow_entries</span>(dpid, port_a, port_b)
  send_flow_mod_add(dpid,
                    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_a),
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_b))
  send_flow_mod_add(dpid,
                    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_b),
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_a))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>add_flow_entries</code> の中で2回呼び出している <code>send_flow_mod_add</code> のうち、最初の呼び出し部分を詳しく見てみましょう。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#add_flow_entries (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_flow_mod_add(dpid,
                  <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_a),
                  <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは、ポート <code>port_a</code> 番へ上がってきたパケットをポート <code>port_b</code> 番へ出力するフローエントリを書き込んでいます。ここでは次の2つのオプションを指定しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>match</code>: 「入力ポート(<code>:in_port</code>)が <code>port_a</code> であった場合」という <code>Match</code> オブジェクト</p>
</li>
<li>
<p><code>actions</code>: 「ポート <code>port_b</code> 番へ出力する」という <code>SendOutPort</code> アクション</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_delete_flow_entriesメソッド">6.4.6. delete_flow_entriesメソッド</h4>
<div class="paragraph">
<p><code>delete_flow_entries</code> は古いフローエントリを消すメソッドです。<code>add_flow_entries</code> でフローエントリを足す前に、いったん <code>delete_flow_entries</code> で古いフローエントリを消すことでフローエントリが重複しないようにします。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#delete_flow_entries (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">delete_flow_entries</span>(dpid, port_a, port_b)
  send_flow_mod_delete(dpid, <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_a))
  send_flow_mod_delete(dpid, <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: port_b))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで呼び出している <code>send_flow_mod_delete</code> は <code>send_flow_mod_add</code> とは逆のメソッドで、<code>match:</code> に対応するフローエントリを削除します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_create_patch_delete_patchメソッド">6.4.7. create_patch, delete_patchメソッド</h4>
<div class="paragraph">
<p><code>create_patch</code> と <code>delete_patch</code> メソッドは、<code>bin/patch_panel</code> コマンドからパッチの作成と削除を行うためのAPIです。</p>
</div>
<div class="paragraph">
<p><code>create_patch</code> メソッドは、<code>add_flow_entries</code> メソッドでフローエントリを追加し、パッチ設定 <code>@patch</code> にパッチ情報を追加します。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#create_patch (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">create_patch</span>(dpid, port_a, port_b)
  add_flow_entries dpid, port_a, port_b
  <span class="instance-variable">@patch</span>[dpid] += [port_a, port_b].sort
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>逆に <code>delete_patch</code> メソッドはフローエントリを削除しパッチ設定からパッチ情報を削除します。</p>
</div>
<div class="listingblock">
<div class="title">PatchPanel#delete_patch (lib/patch_panel.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">delete_patch</span>(dpid, port_a, port_b)
  delete_flow_entries dpid, port_a, port_b
  <span class="instance-variable">@patch</span>[dpid] -= [port_a, port_b].sort
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bin_patch_panel_コマンド">6.4.8. bin/patch_panel コマンド</h4>
<div class="paragraph">
<p><code>PatchPanel</code> クラスの操作コマンドが <code>bin/patch_panel</code> です。<code>PatchPanel</code> クラスの <code>create_patch</code> と <code>delete_patch</code> メソッドを呼び出します。<code>patch_panel create</code> と <code>patch_panel delete</code> という 2 つのサブコマンドを持っています。</p>
</div>
<div class="paragraph">
<p>サブコマンドの実装には gli (<a href="https://github.com/davetron5000/gli" class="bare">https://github.com/davetron5000/gli</a>) というRubyライブラリを使っています。gli を使うと、<code>patch_panel create</code> や <code>patch_panel delete</code> といったサブコマンド体系、いわゆるコマンドスイートを簡単に実装できます。詳細は gli のドキュメントにゆずりますが、書きかたを簡単に紹介しておきます。</p>
</div>
<div id="patch_panel_command" class="listingblock">
<div class="title">bin/patch_panel</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="doctype">#!/usr/bin/env ruby</span>

require <span class="string"><span class="delimiter">'</span><span class="content">rubygems</span><span class="delimiter">'</span></span>
require <span class="string"><span class="delimiter">'</span><span class="content">bundler</span><span class="delimiter">'</span></span>
<span class="constant">Bundler</span>.setup <span class="symbol">:default</span>

require <span class="string"><span class="delimiter">'</span><span class="content">gli</span><span class="delimiter">'</span></span>
require <span class="string"><span class="delimiter">'</span><span class="content">trema</span><span class="delimiter">'</span></span>

<span class="comment"># patch_panel command</span>
<span class="keyword">module</span> <span class="class">PatchPanelApp</span>
  extend <span class="constant">GLI</span>::<span class="constant">App</span>

  desc <span class="string"><span class="delimiter">'</span><span class="content">Creates a new patch</span><span class="delimiter">'</span></span> <i class="conum" data-value="1"></i><b>(1)</b>
  arg_name <span class="string"><span class="delimiter">'</span><span class="content">dpid port#1 port#2</span><span class="delimiter">'</span></span>
  command <span class="symbol">:create</span> <span class="keyword">do</span> |c|
    c.desc <span class="string"><span class="delimiter">'</span><span class="content">Location to find socket files</span><span class="delimiter">'</span></span>
    c.flag [<span class="symbol">:S</span>, <span class="symbol">:socket_dir</span>], <span class="key">default_value</span>: <span class="constant">Trema</span>::<span class="constant">DEFAULT_SOCKET_DIR</span>

    c.action <span class="keyword">do</span> |_global_options, options, args|
      dpid = args[<span class="integer">0</span>].hex
      port1 = args[<span class="integer">1</span>].to_i
      port2 = args[<span class="integer">2</span>].to_i
      <span class="constant">Trema</span>.trema_process(<span class="string"><span class="delimiter">'</span><span class="content">PatchPanel</span><span class="delimiter">'</span></span>, options[<span class="symbol">:socket_dir</span>]).controller.
        create_patch(dpid, port1, port2)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  desc <span class="string"><span class="delimiter">'</span><span class="content">Deletes a patch</span><span class="delimiter">'</span></span> <i class="conum" data-value="2"></i><b>(2)</b>
  arg_name <span class="string"><span class="delimiter">'</span><span class="content">dpid port#1 port#2</span><span class="delimiter">'</span></span>
  command <span class="symbol">:delete</span> <span class="keyword">do</span> |c|
    c.desc <span class="string"><span class="delimiter">'</span><span class="content">Location to find socket files</span><span class="delimiter">'</span></span>
    c.flag [<span class="symbol">:S</span>, <span class="symbol">:socket_dir</span>], <span class="key">default_value</span>: <span class="constant">Trema</span>::<span class="constant">DEFAULT_SOCKET_DIR</span>

    c.action <span class="keyword">do</span> |_global_options, options, args|
      dpid = args[<span class="integer">0</span>].hex
      port1 = args[<span class="integer">1</span>].to_i
      port2 = args[<span class="integer">2</span>].to_i
      <span class="constant">Trema</span>.trema_process(<span class="string"><span class="delimiter">'</span><span class="content">PatchPanel</span><span class="delimiter">'</span></span>, options[<span class="symbol">:socket_dir</span>]).controller.
        delete_patch(dpid, port1, port2)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  exit run(<span class="predefined-constant">ARGV</span>)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>create</code> サブコマンドの実装</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>delete</code> サブコマンドの実装</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>gli を使ったサブコマンドの実装は、<code>command サブコマンド名 do &#8230;&#8203; end</code> のブロックを記述するだけです。それぞれのブロック内で、サブコマンドに渡されたオプションの処理と実際の動作を記述します。</p>
</div>
<div class="listingblock">
<div class="title">create サブコマンドの実装</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">desc <span class="string"><span class="delimiter">'</span><span class="content">Creates a new patch</span><span class="delimiter">'</span></span> <i class="conum" data-value="1"></i><b>(1)</b>
arg_name <span class="string"><span class="delimiter">'</span><span class="content">dpid port#1 port#2</span><span class="delimiter">'</span></span> <i class="conum" data-value="2"></i><b>(2)</b>
command <span class="symbol">:create</span> <span class="keyword">do</span> |c|
  c.desc <span class="string"><span class="delimiter">'</span><span class="content">Location to find socket files</span><span class="delimiter">'</span></span> <i class="conum" data-value="3"></i><b>(3)</b>
  c.flag [<span class="symbol">:S</span>, <span class="symbol">:socket_dir</span>], <span class="key">default_value</span>: <span class="constant">Trema</span>::<span class="constant">DEFAULT_SOCKET_DIR</span> <i class="conum" data-value="4"></i><b>(4)</b>

  c.action <span class="keyword">do</span> |_global_options, options, args|
    dpid = args[<span class="integer">0</span>].hex <i class="conum" data-value="5"></i><b>(5)</b>
    port1 = args[<span class="integer">1</span>].to_i <i class="conum" data-value="5"></i><b>(5)</b>
    port2 = args[<span class="integer">2</span>].to_i <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="constant">Trema</span>.trema_process(<span class="string"><span class="delimiter">'</span><span class="content">PatchPanel</span><span class="delimiter">'</span></span>, options[<span class="symbol">:socket_dir</span>]).controller.
      create_patch(dpid, port1, port2) <i class="conum" data-value="6"></i><b>(6)</b>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>create</code> サブコマンドの説明</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>オプションの説明</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>-S</code> (<code>--socket_dir</code>) オプションの説明</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>-S</code> (<code>--socket_dir</code>) オプションとデフォルト値の定義</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>オプションのパース</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>PatchPanel</code> クラスの <code>create_patch</code> メソッドの呼び出し</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ポイントは、サブコマンド定義内での <code>PatchPanel</code> クラスのメソッド呼び出し部分です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="constant">Trema</span>.trema_process(<span class="string"><span class="delimiter">'</span><span class="content">PatchPanel</span><span class="delimiter">'</span></span>, options[<span class="symbol">:socket_dir</span>]).controller.create_patch(dpid, port1, port2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>Trema.trema_process.controller</code> メソッドは、現在動いているコントローラオブジェクト(<code>PatchPanel</code> クラスオブジェクト)を返します。そしてその返り値に対して <code>create_patch</code> などのメソッドを呼び出すことで、コントローラのメソッドを呼び出せます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_6">6.5. まとめ</h3>
<div class="paragraph">
<p>フローを使ってパケットを転送する方法の入門編として、OpenFlowで実現するインテリジェント・パッチパネルを書きました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仮想スイッチに仮想ホストを接続してテストパケットを送信する方法を学んだ</p>
</li>
<li>
<p>フローエントリの削除方法を学んだ</p>
</li>
<li>
<p>コントローラ操作用の外部コマンドの書き方を学んだ</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>実は、今回作ったOpenFlow版パッチパネルはSDNの一種です。なぜならば、OpenFlow版パッチパネルを使えばホストの所属するネットワークをソフトウェア的に切り替えられるからです。これは、物理ネットワークの上にそれぞれ独立したネットワークをいくつも作れるという意味で、もっとも単純なネットワーク仮想化に他なりません。</p>
</div>
<div class="paragraph">
<p>続く章では、これまで使ってきた 3 つの重要な OpenFlow メッセージである Flow Mod, Packet In, Packet Out を組み合わせてイーサネットスイッチ作りに挑戦です。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="learning_switch">7. すべての基本、ラーニングスイッチ</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>データセンターのような複雑に入り組んだネットワークも、もしケーブルを抜いてバラバラにできたなら、スイッチやサーバなどの意外とシンプルな部品に分解できます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/learning_switch/learn.png" alt="learn">
</div>
</div>
<div class="sect2">
<h3 id="_ラーニングスイッチとは何か">7.1. ラーニングスイッチとは何か</h3>
<div class="paragraph">
<p>OpenFlowの世界では、コントローラとしてソフトウェア実装したイーサネットスイッチをよく<strong>ラーニングスイッチ</strong>と呼びます。なぜ、ラーニング（学習）スイッチと呼ぶのでしょうか。それは、イーサネットスイッチが次のように動くからです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>学習：ホストから出たパケットに含まれる、ネットワーク上でのホストの位置情報を学習する</p>
</li>
<li>
<p>転送：今まで学習してきた位置情報を使って、パケットを宛先のホストまで転送する</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この「学習し、転送する」というラーニングスイッチの仕組みは応用が広く効きます。たとえば後半で紹介するいくつかのデータセンターネットワークも、基本はラーニングスイッチと同じく「学習し、転送する」という動作をします。自宅ネットワークであろうが最新鋭のデータセンターであろうが、基本的な考え方は同じなのです。</p>
</div>
<div class="paragraph">
<p>ラーニングスイッチを作れるようになれば、それをベースに改造することでいろいろなアプリケーションを作れるようになります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ルータ (<a href="#router_part1">12章</a>,<a href="#router_part2">13章</a>,<a href="#router13">14章</a>)</p>
</li>
<li>
<p>ルーティングスイッチ (<a href="#routing_switch">16章</a>)</p>
</li>
<li>
<p>ネットワークスライス (<a href="#sliceable_switch">17章</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ではさっそく、ネットワークの基本部品であるラーニングスイッチをTremaで実装してみましょう。まずは一般的なイーサネットスイッチの動作原理を理解し、次にOpenFlowでの実現方法を見ていきます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_イーサネットスイッチの仕組み">7.2. イーサネットスイッチの仕組み</h3>
<div class="paragraph">
<p>簡単なネットワークを例にしてイーサネットスイッチの動作を説明します(<a href="#switch_network">図 7-1</a>)。</p>
</div>
<div id="switch_network" class="imageblock">
<div class="content">
<img src="images/learning_switch/switch_network.png" alt="switch network">
</div>
<div class="title">図 7-1: イーサネットスイッチ1台とホスト2台からなるネットワークとFDBの内容</div>
</div>
<div class="paragraph">
<p>イーサネットスイッチのポート1番と5番に、ホスト1と2をそれぞれ接続しています。また、それぞれのホストのネットワークカードは図に示したMACアドレスを持つとします。</p>
</div>
<div class="paragraph">
<p>イーサネットスイッチはホストから届いたパケットを宛先のホストまで転送するために、イーサネットスイッチにつながる各ホストの位置情報をためておくデータベースを持っています。これをフォワーディングデータベース(FDB)と呼び、FDBは「ホストのMACアドレス」+「ポート番号」の組を保持します。</p>
</div>
<div class="paragraph">
<p>ここでホスト2がホスト1へパケットを送信すると、イーサネットスイッチは<a href="#host2to1">図 7-2</a>のようにパケットをホスト1まで転送します。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>届いたパケットの宛先MACアドレス(00:11:11:11:11:11)を見て、このMACアドレスを持つホストがつながるポート番号をFDBから探す</p>
</li>
<li>
<p>FDBには「MACアドレス00:11:11:11:11:11=ポート1」と学習しているので、ポート1にパケットを出力する</p>
</li>
</ol>
</div>
<div id="host2to1" class="imageblock">
<div class="content">
<img src="images/learning_switch/host2to1.png" alt="host2to1">
</div>
<div class="title">図 7-2: FDBの情報からパケットをホスト1に届ける</div>
</div>
<div class="paragraph">
<p>ここまでの仕組みがわかれば、イーサネットスイッチの機能を実現するコントローラ (ラーニングスイッチ) をOpenFlowで実現するのは簡単です。</p>
</div>
</div>
<div class="sect2">
<h3 id="_openflow版イーサネットスイッチ_ラーニングスイッチ_の仕組み">7.3. OpenFlow版イーサネットスイッチ(ラーニングスイッチ)の仕組み</h3>
<div class="paragraph">
<p>OpenFlowによるイーサネットスイッチの構成は<a href="#switch_network_openflow">図 7-3</a>のようになります。一般的なイーサネットスイッチとの違いは次の2つです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FDBをソフトウェアとして実装し、コントローラがFDBを管理する</p>
</li>
<li>
<p>パケットの転送は、コントローラがフローテーブルにフローエントリを書き込むことで制御する</p>
</li>
</ul>
</div>
<div id="switch_network_openflow" class="imageblock">
<div class="content">
<img src="images/learning_switch/switch_network_openflow.png" alt="switch network openflow">
</div>
<div class="title">図 7-3: OpenFlowによるイーサネットスイッチ(ラーニングスイッチ)の構成</div>
</div>
<div class="paragraph">
<p>なお、初期状態でのFDBとフローテーブルの中身はどちらも空です。</p>
</div>
<div class="sect3">
<h4 id="_packet_inからホストの位置情報を学習">7.3.1. Packet Inからホストの位置情報を学習</h4>
<div class="paragraph">
<p>この状態でホスト1がホスト2へパケットを送信すると、コントローラは次のようにホスト1のネットワーク上での位置情報を学習します(<a href="#host1to2_openflow">図 7-4</a>)。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>フローテーブルはまだ空なので、パケットはPacket Inとしてコントローラまで上がる</p>
</li>
<li>
<p>コントローラはPacket Inメッセージからパケットの送信元MACアドレスとパケットの入ってきたポート番号を調べ、「ポート1番にはMACアドレスが00:11:11:11:11:11のホストがつながっている」とFDBに保存する</p>
</li>
</ol>
</div>
<div id="host1to2_openflow" class="imageblock">
<div class="content">
<img src="images/learning_switch/host1to2_openflow.png" alt="host1to2 openflow">
</div>
<div class="title">図 7-4: Packet Inの送信元MACアドレスとスイッチのポート番号をFDBに学習する</div>
</div>
</div>
<div class="sect3">
<h4 id="_packet_outでパケットを転送_フラッディング">7.3.2. Packet Outでパケットを転送(フラッディング)</h4>
<div class="paragraph">
<p>学習が終わると次はパケットの転送です。もちろん、パケットの宛先はまだ学習していないので、コントローラは次のようにパケットをばらまくことで宛先まで届けます。このばらまく処理をフラッディングと呼びます(<a href="#host1to2_flood_openflow">図 7-5</a>)。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>コントローラはPacket Inメッセージの宛先MACアドレスを調べ、FDBから送出先のポート番号を探す。しかし、ホスト2のMACアドレスとポート番号はまだFDBに入っていないのでわからない</p>
</li>
<li>
<p>コントローラは出力ポートをフラッディングに指定したPacket Outメッセージでパケットをばらまくようにスイッチに指示する。その結果、ポート5につながるホスト2にパケットが届く</p>
</li>
</ol>
</div>
<div id="host1to2_flood_openflow" class="imageblock">
<div class="content">
<img src="images/learning_switch/host1to2_flood_openflow.png" alt="host1to2 flood openflow">
</div>
<div class="title">図 7-5: 出力ポートがFDBから見つからないため、出力ポートをフラッディングに指定したPacket Outメッセージでパケットをばらまく</div>
</div>
</div>
<div class="sect3">
<h4 id="_再び学習と転送_flow_modとpacket_out">7.3.3. 再び学習と転送(Flow ModとPacket Out)</h4>
<div class="paragraph">
<p>この状態でホスト2がホスト1へパケットを送信すると次のようになります(<a href="#host2to1_openflow">図 7-6</a>)。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>フローテーブルが空なためコントローラまで再びPacket Inメッセージが上がる</p>
</li>
<li>
<p>コントローラはこのPacket Inメッセージから「ポート5番にはMACアドレスが00:22:22:22:22:22のホストがつながっている」とFDBに保存する</p>
</li>
<li>
<p>Packet Inの宛先MACアドレスとFDBを照らし合わせ、出力先のポート番号を探す。すでに「ポート1=MACアドレス00:11:11:11:11:11」と学習しているので、出力ポートは1と決定できる</p>
</li>
<li>
<p>「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエントリをFlow Modメッセージでフローテーブルに書き込む。加えて、Packet Outメッセージ(出力ポート = 1)でPacket Inを起こしたパケットをポート1へ出力する</p>
</li>
</ol>
</div>
<div id="host2to1_openflow" class="imageblock">
<div class="content">
<img src="images/learning_switch/host2to1_openflow.png" alt="host2to1 openflow">
</div>
<div class="title">図 7-6: ホスト2のMACアドレスとポート番号をFDBに学習し、フローエントリを書き込むとともにパケットをホスト1に届ける</div>
</div>
<div class="paragraph">
<p>さて、ここまでの段階でフローテーブルには「ホスト2からホスト1へのパケットはポート1へ出力せよ」というフローエントリが入りました。もし、ホスト2がホスト1へ再びパケットを送信すると、今度はPacket Inがコントローラまで上がることはなく、スイッチ側だけでパケットを転送します。</p>
</div>
<div class="paragraph">
<p>残りのホスト1からホスト2へのフローエントリはどうでしょう。すでにFDBはすべてのホストのMACアドレスとポート番号を学習しています。もし、再びホスト1からホスト2へパケットを送信すると、<a href="#host2to1_openflow">図 7-6</a>と同様にコントローラが「ホスト1からホスト2へのパケットはポート5へ出力せよ」というフローエントリを書き込みます。もちろん、それ以降の通信ではPacket Inはまったく上がらずにすべてスイッチ側だけでパケットを処理します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_4">7.4. 実行してみよう</h3>
<div class="paragraph">
<p>今回も仮想ネットワークを使ってラーニングスイッチを起動してみます。ソースコードと仮想ネットワークの設定ファイルはGitHubのtrema/learning_switchリポジトリ (<a href="https://github.com/trema/learning_switch" class="bare">https://github.com/trema/learning_switch</a>) からダウンロードできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/learning_switch.git</pre>
</div>
</div>
<div class="paragraph">
<p>ダウンロードしたソースツリー上で <code>bundle install --binstubs</code> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd learning_switch
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>GitHubから取得したラーニングスイッチのソースリポジトリ内に、仮想スイッチ1台、仮想ホスト2台の構成を持つ設定ファイル <code>trema.conf</code> が入っています。</p>
</div>
<div class="listingblock">
<div class="title">trema.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch(<span class="string"><span class="delimiter">'</span><span class="content">lsw</span><span class="delimiter">'</span></span>) {
  datapath_id <span class="integer">0xabc</span>
}

vhost (<span class="string"><span class="delimiter">'</span><span class="content">host1</span><span class="delimiter">'</span></span>) {
  ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.1</span><span class="delimiter">'</span></span>
}

vhost (<span class="string"><span class="delimiter">'</span><span class="content">host2</span><span class="delimiter">'</span></span>) {
  ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.2</span><span class="delimiter">'</span></span>
}

link <span class="string"><span class="delimiter">'</span><span class="content">lsw</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host1</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">lsw</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host2</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>次のように <code>trema run</code> の <code>-c</code> オプションにこの設定ファイルを渡してラーニングスイッチを実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/learning_switch.rb -c trema.conf</pre>
</div>
</div>
<div class="paragraph">
<p>別ターミナルを開き、<code>trema send_packets</code> コマンドを使ってhost1とhost2の間でテストパケットを送ってみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source host1 --dest host2
$ ./bin/trema send_packets --source host2 --dest host1</pre>
</div>
</div>
<div class="paragraph">
<p><code>trema show_stats</code> コマンドでhost1とhost2の受信パケット数をチェックし、それぞれでパケットを受信していれば成功です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
Packets received:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p>ラーニングスイッチの動作イメージがわかったところで、ソースコードの解説に移りましょう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ラーニングスイッチのソースコード">7.5. ラーニングスイッチのソースコード</h3>
<div class="paragraph">
<p>ラーニングスイッチのソースコードは <a href="#learning_switch.rb">lib/learning_switch.rb</a> と <a href="#fdb.rb">lib/fdb.rb</a> の 2 つからなります。まずはメインのソースコード (<a href="#learning_switch.rb">lib/learning_switch.rb</a>) をざっと眺めてみましょう。 とくに、<code>private</code> の行よりも上のパブリックなメソッドに注目してください。</p>
</div>
<div id="learning_switch.rb" class="listingblock">
<div class="title">lib/learning_switch.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">require <span class="string"><span class="delimiter">'</span><span class="content">fdb</span><span class="delimiter">'</span></span>

<span class="comment"># An OpenFlow controller that emulates an ethernet switch.</span>
<span class="keyword">class</span> <span class="class">LearningSwitch</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  timer_event <span class="symbol">:age_fdb</span>, <span class="key">interval</span>: <span class="integer">5</span>.sec

  <span class="keyword">def</span> <span class="function">start</span>(_argv)
    <span class="instance-variable">@fdb</span> = <span class="constant">FDB</span>.new
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
    <span class="comment"># Drop BPDU frames</span>
    send_flow_mod_add(
      datapath_id,
      <span class="key">priority</span>: <span class="integer">100</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">destination_mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">01:80:C2:00:00:00</span><span class="delimiter">'</span></span>)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_in</span>(_datapath_id, packet_in)
    <span class="instance-variable">@fdb</span>.learn packet_in.source_mac, packet_in.in_port
    flow_mod_and_packet_out packet_in
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">age_fdb</span>
    <span class="instance-variable">@fdb</span>.age
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">flow_mod_and_packet_out</span>(packet_in)
    port_no = <span class="instance-variable">@fdb</span>.lookup(packet_in.destination_mac)
    flow_mod(packet_in, port_no) <span class="keyword">if</span> port_no
    packet_out(packet_in, port_no || <span class="symbol">:flood</span>)
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">flow_mod</span>(packet_in, port_no)
    send_flow_mod_add(
      packet_in.datapath_id,
      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_out</span>(packet_in, port_no)
    send_packet_out(
      packet_in.datapath_id,
      <span class="key">packet_in</span>: packet_in,
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no)
    )
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>今までの知識だけでも、このソースコードからいろいろなことがわかります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ラーニングスイッチの本体は <code>LearningSwitch</code> という名前のクラス</p>
</li>
<li>
<p>起動時に呼ばれる <code>start</code> ハンドラでFDBのインスタンス変数を作っている。FDBの実装は別ファイル <code>lib/fdb.rb</code> に分かれている</p>
</li>
<li>
<p>スイッチ接続時に呼ばれる <code>swtich_ready</code> ハンドラでは、宛先 MAC アドレスが <code>01:80:C2:00:00:00</code> のパケットを落とすフローエントリを打ち込んでいる</p>
</li>
<li>
<p><code>packet_in</code> ハンドラで呼ぶ <code>flow_mod_and_packet_out</code> メソッドの中では、<code>@fdb</code> を使ってポート番号を調べたり、<code>flow_mod</code> と <code>packet_out</code> メソッドでそれぞれFlow ModとPacket Outメッセージを送っている。また、先述した「パケットをばらまく(フラッディング)」処理に対応する <code>:flood</code> も見つかる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ラーニングスイッチの心臓部は <code>packet_in</code> ハンドラだけで、その中身もたった 3 行のみと単純です。ラーニングスイッチの仕組みを思い出しながら、ソースコードを詳しく読み解いていきましょう。今回のポイントとなるのは、Packet In ハンドラでの次の処理です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FDBの更新とポート番号の検索</p>
</li>
<li>
<p>ポート番号が見つかった場合の、Flow ModとPacket Outの処理</p>
</li>
<li>
<p>ポート番号が見つからなかった場合の、フラッディング処理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>それでは、最初にPacket Inハンドラの内容から見ていきましょう。</p>
</div>
<div class="sect3">
<h4 id="_未知のパケット_packet_in_の処理">7.5.1. 未知のパケット(Packet In)の処理</h4>
<div class="paragraph">
<p>知らないパケットがPacket Inとして入ってきたとき、ラーニングスイッチは次のようにFDBにホストの位置情報を学習し、宛先のポート番号を調べます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>パケットの送信元MACアドレスとパケットが入ってきたポート番号をPacket Inメッセージから取り出し、FDB (<code>@fdb</code>) に保存する</p>
</li>
<li>
<p>パケットの宛先MACアドレスとFDBから、パケットを出力するポート番号を調べる (<code>@fdb.lookup</code> メソッド)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">LearningSwitch#packet_in, LearningSwitch#flow_mod_and_packet_out (lib/learning_switch.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(_datapath_id, packet_in)
  <span class="instance-variable">@fdb</span>.learn packet_in.source_mac, packet_in.in_port
  flow_mod_and_packet_out packet_in
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">flow_mod_and_packet_out</span>(packet_in)
  port_no = <span class="instance-variable">@fdb</span>.lookup(packet_in.destination_mac)
  flow_mod(packet_in, port_no) <span class="keyword">if</span> port_no
  packet_out(packet_in, port_no || <span class="symbol">:flood</span>)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_宛先ポート番号が見つかった場合_flowmodとpacket_out">宛先ポート番号が見つかった場合(FlowModとPacket Out)</h5>
<div class="paragraph">
<p>もし宛先ポートが見つかった場合、以降は同じパケットは同様に転送せよ、というフローエントリをスイッチに書き込みます (<code>flow_mod</code> メソッド)。また、Packet Inを起こしたパケットも忘れずにそのポートへ出力します (<code>packet_out</code> メソッド)。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch#flow_mod_and_packet_out (lib/learning_switch.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">flow_mod_and_packet_out</span>(packet_in)
  port_no = <span class="instance-variable">@fdb</span>.lookup(packet_in.destination_mac)
  flow_mod(packet_in, port_no) <span class="keyword">if</span> port_no
  packet_out(packet_in, port_no || <span class="symbol">:flood</span>)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>flow_mod</code> メソッドと <code>packet_out</code> メソッドはそれぞれ <code>send_flow_mod_add</code> (<a href="#cbench">5 章「マイクロベンチマークCbench」</a>で紹介) および <code>send_packet_out</code> (Packet Outの送信) メソッドを次のように呼び出します。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch#flow_mod, LearningSwitch#packet_out (lib/learning_switch.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">flow_mod</span>(packet_in, port_no)
  send_flow_mod_add(
    packet_in.datapath_id,
    <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no)
  )
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">packet_out</span>(packet_in, port_no)
  send_packet_out(
    packet_in.datapath_id,
    <span class="key">packet_in</span>: packet_in,
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no)
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_packet_out_api">7.5.2. Packet Out API</h4>
<div class="paragraph">
<p>Packet OutはOpenFlowメッセージの1つで、スイッチの指定したポートからパケットを出力させるためのものです。TremaでPacket Outを送るためのメソッド <code>send_packet_out</code> は、次の2つの引数を取ります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_packet_out(datapath_id, options)</code></pre>
</div>
</div>
<div class="paragraph">
<p>それぞれの引数の意味は次のとおりです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>datapath_id</code></dt>
<dd>
<p>Packet Outメッセージの届け先となるスイッチのDatapath ID</p>
</dd>
<dt class="hdlist1"><code>options</code></dt>
<dd>
<p>Packet Outメッセージの中身を決めるためのオプション。アクションによるパケットの書き換えや出力するポートをハッシュテーブルで指定する。それぞれのオプションにはデフォルト値が設定されているので、必要なオプションのみを指定すればよい</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Packet Outの使い道は、Packet Inメッセージとして入ってきたパケットをそのままスイッチのポートから送り出す場合がほとんどです。この場合、パケットの送信にスイッチのバッファを使う場合と使わない場合とで呼び出し方が変わります。</p>
</div>
<div class="sect4">
<h5 id="_スイッチのバッファを使ってpacket_outする場合">スイッチのバッファを使ってPacket Outする場合</h5>
<div class="paragraph">
<p>パケットのデータがスイッチのバッファに乗っていることが期待できる場合には、次のように <code>buffer_id</code> オプションでバッファに乗っているパケットデータのIDを指定してやることでPacket Outできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_packet_out(
  datapath_id,
  <span class="key">buffer_id</span>: packet_in.buffer_id,
  <span class="key">raw_data</span>: packet_in.raw_data,
  <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_number)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>この場合コントローラからスイッチへのパケットデータのコピーが起こらないため、若干のスピードアップが期待できます。ただし、<a href="#openflow_spec">2 章「OpenFlow の仕様」</a>のコラムで説明したとおり、バッファの中身は観測不能でデータがいつ消えるかもわからないため、この方法は推奨しません。</p>
</div>
</div>
<div class="sect4">
<h5 id="_スイッチのバッファを使わずにpacketoutする場合">スイッチのバッファを使わずにPacketOutする場合</h5>
<div class="paragraph">
<p>スイッチのバッファを使わずに Packet Out する場合、次のように <code>raw_data</code> オプションでパケットのデータを指定する必要があります。バッファに乗っているいないにかかわらず Packet Out できるので、若干遅くはなりますが安全です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_packet_out(
  datapath_id,
  <span class="key">raw_data</span>: packet_in.raw_data,
  <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_number)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、次のように <code>packet_in</code> オプションを使うことで若干短くできます (<code>.raw_data</code> を書かなくてよくなります)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">send_packet_out(
  datapath_id,
  <span class="key">packet_in</span>: packet_in,
  <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_number)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_主なオプション一覧">7.5.3. 主なオプション一覧</h4>
<div class="paragraph">
<p><code>options</code> に指定できる主なオプションは次のとおりです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>buffer_id</code></dt>
<dd>
<p>スイッチでバッファされているパケットの ID を指定する。この値を使うと、スイッチでバッファされているパケットを指定して Packet Out できるので効率が良くなる (ただし、スイッチにバッファされていない時はエラーになる)</p>
</dd>
<dt class="hdlist1"><code>raw_data</code></dt>
<dd>
<p>Packet Out するパケットの中身を指定する。もし <code>buffer_id</code> オプションが指定されておりスイッチにバッファされたパケットを Packet Out する場合、この値は使われない</p>
</dd>
<dt class="hdlist1"><code>packet_in</code></dt>
<dd>
<p><code>raw_data</code> および <code>in_port</code> オプションを指定するためのショートカット。Packet In ハンドラの引数として渡される Packet In メッセージを指定する</p>
</dd>
<dt class="hdlist1"><code>actions</code></dt>
<dd>
<p>Packet Out のときに実行したいアクションの配列を指定する。アクションが 1 つの場合は配列でなくてかまわない</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="_宛先ポート番号が見つからなかった場合_フラッディング">宛先ポート番号が見つからなかった場合 (フラッディング)</h5>
<div class="paragraph">
<p>もし宛先ポートが見つからなかった場合、コントローラは Packet In したパケットをフラッディングしてばらまきます。これをやるのが <code>flow_mod_and_packet_out</code> メソッドで、ポート番号に予約ポート番号の <code>:flood</code> を指定して <code>packet_out</code> メソッドを呼び出します。<code>:flood</code> を指定した Packet Out メッセージをスイッチが受け取ると、Packet In したパケットをフラッディングします。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch#flow_mod_and_packet_out (lib/learning_switch.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">flow_mod_and_packet_out</span>(packet_in)
  port_no = <span class="instance-variable">@fdb</span>.lookup(packet_in.destination_mac)
  flow_mod(packet_in, port_no) <span class="keyword">if</span> port_no
  packet_out(packet_in, port_no || <span class="symbol">:flood</span>)
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fdb_の実装">7.5.4. FDB の実装</h4>
<div class="paragraph">
<p>learning_switch.rb の一行目の <code>require 'fdb'</code> は、同じディレクトリ内の fdb.rb を読み込みます。<code>require</code> はちょうど、C の <code>#include</code> や Java の <code>import</code> みたいなものと思ってください。Ruby では、たとえば fdb.rb というファイルを読み込みたいときは、拡張子の .rb を外して <code>require 'fdb'</code> と書きます。読み込む対象のファイルは、lib/ ディレクトリを起点とした相対パスで書きます。たとえば lib/learning_switch/extensions.rb を読み込みたいときには <code>require 'learning_switch/extensions'</code> と書きます。</p>
</div>
<div class="paragraph">
<p>fdb.rb もざっと目を通しておきましょう。このファイルは FDB の機能をカプセル化する <code>FDB</code> クラスを提供します。</p>
</div>
<div class="listingblock">
<div class="title">lib/fdb.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># A database that keeps pairs of a MAC address and a port number</span>
<span class="keyword">class</span> <span class="class">FDB</span>
  <span class="comment"># Forwarding database (FDB) entry.</span>
  <span class="keyword">class</span> <span class="class">Entry</span>
    <span class="constant">DEFAULT_AGE_MAX</span> = <span class="integer">300</span>

    attr_reader <span class="symbol">:mac</span>
    attr_reader <span class="symbol">:port_no</span>

    <span class="keyword">def</span> <span class="function">initialize</span>(mac, port_no, age_max = <span class="constant">DEFAULT_AGE_MAX</span>)
      <span class="instance-variable">@mac</span> = mac
      <span class="instance-variable">@port_no</span> = port_no
      <span class="instance-variable">@age_max</span> = age_max
      <span class="instance-variable">@last_update</span> = <span class="constant">Time</span>.now
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">update</span>(port_no)
      <span class="instance-variable">@port_no</span> = port_no
      <span class="instance-variable">@last_update</span> = <span class="constant">Time</span>.now
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">aged_out?</span>
      <span class="constant">Time</span>.now - <span class="instance-variable">@last_update</span> &gt; <span class="instance-variable">@age_max</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">initialize</span>
    <span class="instance-variable">@db</span> = {}
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">lookup</span>(mac)
    entry = <span class="instance-variable">@db</span>[mac]
    entry &amp;&amp; entry.port_no
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">learn</span>(mac, port_no)
    entry = <span class="instance-variable">@db</span>[mac]
    <span class="keyword">if</span> entry
      entry.update port_no
    <span class="keyword">else</span>
      <span class="instance-variable">@db</span>[mac] = <span class="constant">Entry</span>.new(mac, port_no)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">age</span>
    <span class="instance-variable">@db</span>.delete_if { |_mac, entry| entry.aged_out? }
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>FDB</code> クラスは3つのメソッド <code>lookup</code>・<code>learn</code>・<code>age</code> を持ちます。<code>lookup</code> メソッドを使うと MAC アドレスからポート番号を検索できます。逆に <code>learn</code> メソッドでは MAC アドレスとポート番号の組を学習できます。タイマで定期的に呼ばれる <code>age</code> メソッドでは、FDB に入っているすべてのエントリをエージングし、寿命を過ぎたもの (<code>FDB::Entry#aged_out?</code> で判定) を消します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_不要なパケットを転送しない">7.5.5. 不要なパケットを転送しない</h4>
<div class="paragraph">
<p><code>switch_ready</code> ハンドラでは宛先 MAC アドレスが <code>01:80:C2:00:00:00</code> のパケットを落とすフローエントリを打ち込んでいました。</p>
</div>
<div class="listingblock">
<div class="title">lib/learning_switch.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
  <span class="comment"># Drop BPDU frames</span>
  send_flow_mod_add(
    datapath_id,
    <span class="key">priority</span>: <span class="integer">100</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">destination_mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">01:80:C2:00:00:00</span><span class="delimiter">'</span></span>)
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>コードコメントにもあるように、ここで落としているのはスパニングツリーの制御フレームである BPDU フレームです。OpenFlow ではスイッチを集中制御できるため、ループを防ぎたい場合には分散アルゴリズムの一種であるスパニングツリーは不要だからです。OpenFlow でループを防ぐ方法について詳しくは、<a href="#routing_switch">16 章「たくさんのスイッチを制御する」</a>で解説します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_7">7.6. まとめ</h3>
<div class="paragraph">
<p>実用的なOpenFlowアプリケーションのベースとなるラーニングスイッチの動作と作り方を学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>コントローラは、Packet Inメッセージから送信元ホストのMACアドレスとホストのつながるスイッチポート番号をFDBに学習する</p>
</li>
<li>
<p>Packet Inの転送先がFDBからわかる場合、Flow Modで以降の転送情報をスイッチに書き込みPacketOutする</p>
</li>
<li>
<p>Packet Inの転送先がFDBからわからない場合は、入力ポート以外のすべてのポートにPacket Outでフラッディングする</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>続く章ではこのラーニングスイッチを OpenFlow 1.3 のマルチプルテーブル機能を使って実装します。パケットの処理内容ごとにフローテーブルを分けることで、コントローラをすっきりと設計できます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="learning_switch13">8. OpenFlow1.3版ラーニングスイッチ</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>ラーニングスイッチを OpenFlow1.3 で実装し、OpenFlow1.0版のラーニングスイッチの欠点を解消します。</p>
</div>
<div class="sect2">
<h3 id="_openflow1_0版ラーニングスイッチの問題点">8.1. OpenFlow1.0版ラーニングスイッチの問題点</h3>
<div class="paragraph">
<p><a href="#learning_switch">7章</a>で実装したラーニングスイッチには、実は以下の問題点があります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">フローテーブルが煩雑になる</dt>
<dd>
<p>OpenFlow1.0では同時に使えるフローテーブルは 1 つという制限があります。このため、ラーニングスイッチのようにBPDUフレームなどのフィルタリング用のフローエントリとパケット転送用のフローエントリが一つのフローテーブルに混在すると、後から見たときに解読が大変です。</p>
</dd>
<dt class="hdlist1">起動時の大量のPacketInを防げない</dt>
<dd>
<p>OpenFlow1.0ではフローエントリにマッチしないパケットはすべてPacket Inします。このため、<code>switch_ready</code> ハンドラでフィルタリング用のフローエントリを設定するよりも前にパケットがコントローラへ大量に到着すると、<code>packet_in</code> ハンドラの大量呼び出しによりコントローラがパンクしてしまいます。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_マルチプルテーブル_2">8.2. マルチプルテーブル</h3>
<div class="paragraph">
<p>フローテーブルは 1 つという OpenFlow1.0 の制限は、OpenFlow1.3 でなくなっています。OpenFlow1.3 では 1 つのパケットの処理を複数のフローテーブルを使って処理できます。このようなパケット処理をパイプライン処理と呼びます。ちょうどCPUの命令パイプラインのように、パケット処理を「フィルタリング」→「書き換え」→ &#8230;&#8203; →「転送」とステージごとに進めていくイメージです。フローテーブルごとに役割を明確にできるので、プログラマから見てフローエントリを整理しやすいというメリットがあります。</p>
</div>
<div id="pipeline" class="imageblock">
<div class="content">
<img src="images/learning_switch13/pipeline.png" alt="pipeline">
</div>
<div class="title">図 8-1: OpenFlow1.3でのマルチプルテーブルによるパイプライン処理</div>
</div>
<div class="sect3">
<h4 id="_テーブルの移動">8.2.1. テーブルの移動</h4>
<div class="paragraph">
<p>このパイプライン処理は、テーブル ID が 0 のテーブルから始まり GotoTable インストラクションによって次のテーブルに移動することで進みます。パイプライン処理の入口となるテーブル、つまり Packet In したときに最初に入るテーブルの ID は 0 と決まっています。現在のテーブルから次のテーブルへと処理を移行するには GotoTable インストラクションに次のテーブル ID を指定します。このとき指定するテーブル ID は、現在のテーブル ID よりも大きい必要があります。</p>
</div>
<div id="pipeline_goto" class="imageblock">
<div class="content">
<img src="images/learning_switch13/pipeline_goto.png" alt="pipeline goto">
</div>
<div class="title">図 8-2: テーブル ID 0 から始まり GotoTable インストラクションで次のテーブルへ処理を移動</div>
</div>
</div>
<div class="sect3">
<h4 id="_openflow1_3_のアクション">8.2.2. OpenFlow1.3 のアクション</h4>
<div class="paragraph">
<p>さて「GotoTable インストラクション」という用語を今まで断りなく使ってきましたが、OpenFlow1.3 ではパケットに対する処理を「アクション」と「インストラクション」に分けて書きます。まずはアクションから説明しましょう。</p>
</div>
<div class="paragraph">
<p>アクションの1つの用途はパケットの書き換えです。書き換えアクションの種類は OpenFlow1.0 に比べて大幅に増えており、マッチフィールドで指定できるフィールドの書き換えや VLAN ヘッダの操作に加え、TTL や MPLS, IPv6 パケット等への操作が追加されています (<a href="#actions1.3_modify_fields">表8-1</a>)。</p>
</div>
<table id="actions1.3_modify_fields" class="tableblock frame-all grid-all spread">
<caption class="title">Table 18. OpenFlow 1.3 で使えるアクション一覧 (パケットのフィールド書き換え)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">アクションのクラス名</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SetField</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">マッチ条件で指定できるフィールドをパケットにセットする</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CopyTtlOut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2番目に外側のTTLの値を一番外側のTTLにコピーする</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CopyTtlIn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一番外側のTTLの値を1つ内側のTTLにコピーする</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SetMplsTtl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPLSシムヘッダのTTLをセットする</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DecrementMplsTtl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPLSシムヘッダのTTLを1つ減らす</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PushVlanHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新しいVLANヘッダをパケットに追加する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PopVlanHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一番外側のVLANヘッダをパケットから取り除く</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PushMpls</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新しいMPLSシムヘッダをパケットに追加する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PopMpls</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一番外側のMPLSタグまたはシムヘッダをパケットから取り除く</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Group</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したグループテーブルでパケットを処理する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SetIpTtl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4のTTLまたはIPv6のhop limitをセットする</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DecrementIpTtl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4のTTLまたはIPv6のhop limitを1つ減らす</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PushPbb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新しいPBBサービスインスタンスヘッダ (I-TAG TCI) をパケットに追加する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PopPbb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一番外側のPBBサービスインスタンスヘッダ (I-TAG TCI) をパケットから取り除く</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>もう1つのアクションの用途はパケットの出力です。指定したポートへ出力したり、ポートに関連付けられたキューにパケットを追加するのに使います (<a href="#actions1.3_output">表8-2</a>)。</p>
</div>
<table id="actions1.3_output" class="tableblock frame-all grid-all spread">
<caption class="title">Table 19. OpenFlow 1.3 で使えるアクション一覧 (パケットの出力)</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">アクションのクラス名</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SendOutPort</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したスイッチの (論理) ポートにパケットを出力する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SetQueue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SendOutPort</code> で指定したポートの指定したキューにパケットを追加する</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_インストラクション_2">8.2.3. インストラクション</h4>
<div class="paragraph">
<p>インストラクションはアクションよりも一段上の処理で、フローテーブルの移動とアクションの実行方法を記述できます。たとえば GotoTable インストラクションは、次のように Flow Mod の <code>instructions</code> パラメータに指定しておくことで、マッチしたパケットが到着するとそのパケット処理を指定したフローテーブルへと続けます。</p>
</div>
<div class="listingblock">
<div class="title">GotoTable インストラクションの指定方法</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># テーブル 0 番から 1 番へ GotoTable</span>
send_flow_mod_add(
  datapath_id,
  <span class="key">table_id</span>: <span class="integer">0</span>,
    ...
  <span class="key">instructions</span>: <span class="constant">GotoTable</span>.new(<span class="integer">1</span>)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>インストラクションのもう1つの用途は、アクションを適用するタイミングの指定です。指定方法は次の 2 通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Apply</code> 指定したアクションを直ちにパケットへ適用する</p>
</li>
<li>
<p><code>WriteActions</code> 指定したアクションを後で適用するために、パケットに関連付ける</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Apply</code> を使うと指定したアクションを直ちにパケットへ適用できます。これはちょうど、OpenFlow1.0 の Flow Mod で <code>actions</code> を指定した場合と同じ効果を持ちます。</p>
</div>
<div class="listingblock">
<div class="title">Apply で指定したアクションをパケットへ直ちに適用</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># ポート 1 番へ出力</span>
send_flow_mod_add(
  datapath_id,
    ...
  <span class="key">instructions</span>: <span class="constant">Apply</span>.new(<span class="constant">SendOutPort</span>.new(<span class="integer">1</span>))
)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WriteActions</code> は指定したアクションを後でまとめて適用するために使います。GotoTable でテーブルを移動しながら、パケットに <code>WriteActions</code> で指定したアクションを「後で適用するアクション」に追加していきます。そして GotoTable を含まないフローエントリにパケットがマッチしたタイミングで、そのパケットの「後で適用するアクション」をまとめて適用します。</p>
</div>
<div id="pipeline_write_actions" class="imageblock">
<div class="content">
<img src="images/learning_switch13/pipeline_write_actions.png" alt="pipeline write actions">
</div>
<div class="title">図 8-3: WriteActions でアクションを後でまとめて適用</div>
</div>
<div class="paragraph">
<p>「この後で適用するアクション」を<strong>アクションセット</strong>と呼びます。アクションセットはいわゆる集合なので、同じアクションを複数入れることはできません。<code>WriteActions</code> 以外にも、アクションセットを空にする <code>Clear</code> インストラクションがあります。ここまでのインストラクションを含めてインストラクション一覧を紹介しましょう。</p>
</div>
<table id="instructions1.3" class="tableblock frame-all grid-all spread">
<caption class="title">Table 20. OpenFlow 1.3 で使えるインストラクション一覧</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">インストラクションのクラス名</th>
<th class="tableblock halign-left valign-top">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GotoTable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">マッチしたパケットの処理を指定したテーブルに引き継ぐ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Apply</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定したアクションを実行する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WriteActions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">アクションセットに指定したアクションを追加する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Clear</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">アクションセットを空にする</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WriteMetadata</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">テーブル間で引き継げる 64bit のメタデータをセット</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Meter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">パケットを指定したメーターに適用する</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_openflow1_3_での_packet_in">8.3. OpenFlow1.3 での Packet In</h3>
<div class="paragraph">
<p>OpenFlow1.3では、フローエントリにマッチしないパケットはPacket Inしません。このため OpenFlow1.0 で問題となった、フローエントリの設定前にパケットが大量に到着しうるという問題を解決できます。OpenFlow1.3でPacketInを起こすためには、アクションに <code>SendOutPort.new(:controller)</code> (コントローラへパケットを送り PacketIn を起こす) を指定したフローエントリを明示的に追加します。</p>
</div>
</div>
<div class="sect2">
<h3 id="_openflow1_3版ラーニングスイッチの仕組み">8.4. OpenFlow1.3版ラーニングスイッチの仕組み</h3>
<div class="paragraph">
<p>OpenFlow1.3版ラーニングスイッチでは、役割の異なる2つのフローテーブルを用いてイーサネットスイッチを実現します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">フィルタリングテーブル</dt>
<dd>
<p>転送しないパケットをドロップする。それ以外のパケットは転送テーブルに送る</p>
</dd>
<dt class="hdlist1">転送テーブル</dt>
<dd>
<p>学習したMACアドレスを使ってパケットを転送する。宛先MACアドレスが見つからない場合にはフラッディングする</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ソースコード解説_4">8.5. ソースコード解説</h3>
<div class="paragraph">
<p>OpenFlow1.3版パッチパネルのソースコードは<a href="#learning_switch13.rb">lib/learning_switch13.rb</a>になります。</p>
</div>
<div id="learning_switch13.rb" class="listingblock">
<div class="title">lib/learning_switch13.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">require <span class="string"><span class="delimiter">'</span><span class="content">fdb</span><span class="delimiter">'</span></span>

<span class="comment"># An OpenFlow controller that emulates an ethernet switch.</span>
<span class="keyword">class</span> <span class="class">LearningSwitch13</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  timer_event <span class="symbol">:age_fdb</span>, <span class="key">interval</span>: <span class="integer">5</span>.sec

  <span class="constant">INGRESS_FILTERING_TABLE_ID</span> = <span class="integer">0</span>
  <span class="constant">FORWARDING_TABLE_ID</span> = <span class="integer">1</span>

  <span class="constant">AGING_TIME</span> = <span class="integer">180</span>

  <span class="keyword">def</span> <span class="function">start</span>(_args)
    <span class="instance-variable">@fdb</span> = <span class="constant">FDB</span>.new
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> started.</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
    add_bpdu_drop_flow_entry(datapath_id)
    add_default_broadcast_flow_entry(datapath_id)
    add_default_flooding_flow_entry(datapath_id)
    add_default_forwarding_flow_entry(datapath_id)
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_in</span>(_datapath_id, packet_in)
    <span class="instance-variable">@fdb</span>.learn(packet_in.source_mac, packet_in.in_port)
    add_forwarding_flow_and_packet_out(packet_in)
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">age_fdb</span>
    <span class="instance-variable">@fdb</span>.age
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">add_forwarding_flow_and_packet_out</span>(packet_in)
    port_no = <span class="instance-variable">@fdb</span>.lookup(packet_in.destination_mac)
    add_forwarding_flow_entry(packet_in, port_no) <span class="keyword">if</span> port_no
    packet_out(packet_in, port_no || <span class="symbol">:flood</span>)
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add_forwarding_flow_entry</span>(packet_in, port_no)
    send_flow_mod_add(
      packet_in.datapath_id,
      <span class="key">table_id</span>: <span class="constant">FORWARDING_TABLE_ID</span>,
      <span class="key">idle_timeout</span>: <span class="constant">AGING_TIME</span>,
      <span class="key">priority</span>: <span class="integer">2</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: packet_in.in_port,
                       <span class="key">destination_mac_address</span>: packet_in.destination_mac,
                       <span class="key">source_mac_address</span>: packet_in.source_mac),
      <span class="key">instructions</span>: <span class="constant">Apply</span>.new(<span class="constant">SendOutPort</span>.new(port_no))
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">packet_out</span>(packet_in, port_no)
    send_packet_out(
      packet_in.datapath_id,
      <span class="key">packet_in</span>: packet_in,
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_no)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add_default_broadcast_flow_entry</span>(datapath_id)
    send_flow_mod_add(
      datapath_id,
      <span class="key">table_id</span>: <span class="constant">FORWARDING_TABLE_ID</span>,
      <span class="key">idle_timeout</span>: <span class="integer">0</span>,
      <span class="key">priority</span>: <span class="integer">3</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">destination_mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">ff:ff:ff:ff:ff:ff</span><span class="delimiter">'</span></span>),
      <span class="key">instructions</span>: <span class="constant">Apply</span>.new(<span class="constant">SendOutPort</span>.new(<span class="symbol">:flood</span>))
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add_default_flooding_flow_entry</span>(datapath_id)
    send_flow_mod_add(
      datapath_id,
      <span class="key">table_id</span>: <span class="constant">FORWARDING_TABLE_ID</span>,
      <span class="key">idle_timeout</span>: <span class="integer">0</span>,
      <span class="key">priority</span>: <span class="integer">1</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new,
      <span class="key">instructions</span>: <span class="constant">Apply</span>.new(<span class="constant">SendOutPort</span>.new(<span class="symbol">:controller</span>))
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add_bpdu_drop_flow_entry</span>(datapath_id)
    send_flow_mod_add(
      datapath_id,
      <span class="key">table_id</span>: <span class="constant">INGRESS_FILTERING_TABLE_ID</span>,
      <span class="key">idle_timeout</span>: <span class="integer">0</span>,
      <span class="key">priority</span>: <span class="integer">2</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">destination_mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">01:80:C2:00:00:00</span><span class="delimiter">'</span></span>)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add_default_forwarding_flow_entry</span>(datapath_id)
    send_flow_mod_add(
      datapath_id,
      <span class="key">table_id</span>: <span class="constant">INGRESS_FILTERING_TABLE_ID</span>,
      <span class="key">idle_timeout</span>: <span class="integer">0</span>,
      <span class="key">priority</span>: <span class="integer">1</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new,
      <span class="key">instructions</span>: <span class="constant">GotoTable</span>.new(<span class="constant">FORWARDING_TABLE_ID</span>)
    )
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_switch_ready_ハンドラ">8.5.1. switch_ready ハンドラ</h4>
<div class="paragraph">
<p><code>switch_ready</code> ハンドラでは、まだ学習していないパケットのデフォルト処理を新しく起動したスイッチのフローテーブルに書き込みます。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch13#switch_ready (lib/learning_switch13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(datapath_id)
  add_bpdu_drop_flow_entry(datapath_id)
  add_default_broadcast_flow_entry(datapath_id)
  add_default_flooding_flow_entry(datapath_id)
  add_default_forwarding_flow_entry(datapath_id)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最初に呼び出す <code>add_bpdu_drop_flow_entry</code> では、不要なスパニングツリーの BPDU フレームをドロップするフローエントリを書き込みます。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch13#add_bpdu_drop_flow_entry (lib/learning_switch13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_bpdu_drop_flow_entry</span>(datapath_id)
  send_flow_mod_add(
    datapath_id,
    <span class="key">table_id</span>: <span class="constant">INGRESS_FILTERING_TABLE_ID</span>,
    <span class="key">idle_timeout</span>: <span class="integer">0</span>,
    <span class="key">priority</span>: <span class="integer">2</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">destination_mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">01:80:C2:00:00:00</span><span class="delimiter">'</span></span>)
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Flow Mod に指定するパラメータのうち、ポイントとなるのは次の 3 つです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>table_id</code></dt>
<dd>
<p>スイッチに入ってきたパケットの種類を見てドロップするかどうかを最初にフィルタリングする必要があるので、<code>table_id</code> には 0 (<code>INGRESS_FILTERING_TABLE_ID</code>) を指定します。</p>
</dd>
<dt class="hdlist1"><code>idle_timeout</code></dt>
<dd>
<p>BPDU フレームのドロップはスイッチの起動中はずっと有効なので、<code>idle_timeout</code> には 0 (フローエントリを消さない) を指定します。</p>
</dd>
<dt class="hdlist1"><code>priority</code></dt>
<dd>
<p>ドロップ処理は入ってきたパケットに対して最初に行うフィルタリングなので、テーブルID = 0 のフローエントリのうち最大優先度にします。ここでは 2 を指定します。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>続く <code>add_default_forwarding_flow_entry</code> では、BPDU フレーム以外のパケットを <code>FORWARDING_TABLE_ID</code> で処理します。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch13#add_default_forwarding_flow_entry (lib/learning_switch13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_default_forwarding_flow_entry</span>(datapath_id)
  send_flow_mod_add(
    datapath_id,
    <span class="key">table_id</span>: <span class="constant">INGRESS_FILTERING_TABLE_ID</span>,
    <span class="key">idle_timeout</span>: <span class="integer">0</span>,
    <span class="key">priority</span>: <span class="integer">1</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new,
    <span class="key">instructions</span>: <span class="constant">GotoTable</span>.new(<span class="constant">FORWARDING_TABLE_ID</span>)
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで重要なパラメータは次の 3 つです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>priority</code></dt>
<dd>
<p>優先度を 1 に設定することで、より優先度の高いBPDUフレーム処理 (優先度 = 2) が終わったあとにこの処理を行う</p>
</dd>
<dt class="hdlist1"><code>match</code></dt>
<dd>
<p>空のマッチを指定することで、BPDUフレームでないパケットをすべてこのフローエントリで拾う</p>
</dd>
<dt class="hdlist1"><code>instructions</code></dt>
<dd>
<p><code>GotoTable(FORWARDING_TABLE_ID)</code> を指定することで、以降の処理をテーブル 1 に移す</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>最後の <code>add_default_flooding_flow_entry</code> では、宛先 MAC アドレスをまだ学習していない場合のデフォルト処理をフローテーブルに書き込みます。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch13#add_default_flooding_flow_entry (lib/learning_switch13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_default_flooding_flow_entry</span>(datapath_id)
  send_flow_mod_add(
    datapath_id,
    <span class="key">table_id</span>: <span class="constant">FORWARDING_TABLE_ID</span>,
    <span class="key">idle_timeout</span>: <span class="integer">0</span>,
    <span class="key">priority</span>: <span class="integer">1</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new,
    <span class="key">instructions</span>: <span class="constant">Apply</span>.new(<span class="constant">SendOutPort</span>.new(<span class="symbol">:controller</span>))
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>table_id</code></dt>
<dd>
<p>ここで追加するフローエントリは、直前の GotoTable でテーブル ID <code>INGRESS_FILTERING_TABLE_ID</code> から <code>FORWARDING_TABLE_ID</code> に移動した後に処理さる。このため、<code>table_id</code> には <code>FORWARDING_TABLE_ID</code> を指定する</p>
</dd>
<dt class="hdlist1"><code>priority</code></dt>
<dd>
<p>フラッディング処理は宛先 MAC アドレスをまだ学習していなかった場合のデフォルト処理なので、優先度は低めの 1 を指定する</p>
</dd>
<dt class="hdlist1"><code>instructions</code></dt>
<dd>
<p>フラッディングのための <code>SendOutPort.new(:flood)</code> アクションと、Packet In を起こするための <code>SendOutPort.new(:controller)</code> を <code>Apply</code> インストラクションで適用する</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_packet_in_ハンドラ">8.5.2. packet_in ハンドラ</h4>
<div class="paragraph">
<p><code>packet_in</code> ハンドラでは、Packet In したパケットの送信元 MAC アドレス + In Port の組を学習します。学習した組はテーブル ID が FORWARDING_TABLE_ID であるフローテーブルにフローエントリとして追加します。</p>
</div>
<div class="listingblock">
<div class="title">LearningSwitch13#switch_ready (lib/learning_switch13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(_datapath_id, packet_in)
  <span class="instance-variable">@fdb</span>.learn(packet_in.source_mac, packet_in.in_port)
  add_forwarding_flow_and_packet_out(packet_in)
<span class="keyword">end</span>

private

<span class="keyword">def</span> <span class="function">add_forwarding_flow_and_packet_out</span>(packet_in)
  port_no = <span class="instance-variable">@fdb</span>.lookup(packet_in.destination_mac)
  add_forwarding_flow_entry(packet_in, port_no) <span class="keyword">if</span> port_no
  packet_out(packet_in, port_no || <span class="symbol">:flood</span>)
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">add_forwarding_flow_entry</span>(packet_in, port_no)
  send_flow_mod_add(
    packet_in.datapath_id,
    <span class="key">table_id</span>: <span class="constant">FORWARDING_TABLE_ID</span>,
    <span class="key">idle_timeout</span>: <span class="constant">AGING_TIME</span>,
    <span class="key">priority</span>: <span class="integer">2</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: packet_in.in_port,
                     <span class="key">destination_mac_address</span>: packet_in.destination_mac,
                     <span class="key">source_mac_address</span>: packet_in.source_mac),
    <span class="key">instructions</span>: <span class="constant">Apply</span>.new(<span class="constant">SendOutPort</span>.new(port_no))
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでの Flow Mod パラメータのポイントは次のとおりです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>priority</code></dt>
<dd>
<p>優先度を <code>FORWARDING_TABLE_ID</code> の他のフローエントリ (フラッディング) よりも高くすることで、このフローエントリにマッチしない場合だけフラッディングするようにする</p>
</dd>
<dt class="hdlist1"><code>idle_timeout</code></dt>
<dd>
<p>フローエントリの寿命を指定しておくことで、OpenFlow1.0 版のラーニングスイッチで行ったタイマによるエイジングと同じ効果を出せる</p>
</dd>
<dt class="hdlist1"><code>match</code>, <code>instructions</code></dt>
<dd>
<p>宛先が Packet In の送信元 MAC アドレスと同じだったら、Packet In の <code>in_port</code> から入ったパケットをそちらに送る、というエントリを入れる</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_8">8.6. まとめ</h3>
<div class="paragraph">
<p>ラーニングスイッチを OpenFlow1.3 で実装することで、OpenFlow1.0 版での問題点を解決しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>マルチプルテーブルを使うことで、フローテーブルごとにパケット処理を分けデバッグしやすくできる</p>
</li>
<li>
<p><code>GotoTable</code> インストラクションを使うことで、1つのパケットを複数のフローテーブルで処理できる</p>
</li>
<li>
<p>OpenFlow1.3 ではデフォルトで Packet In が起こらない。このため、OpenFlow1.0 で問題となるフローエントリ設定前の <code>packet_in</code> ハンドラの大量呼び出しが起こらない</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>続く章ではアジャイル開発手法を使って、コントローラを反復的に開発する手法を紹介します。テストコードを書きながら徐々に機能を追加していくことで、バグの少ないコントローラを着実に開発できます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tdd">9. Trema でテスト駆動開発</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>ソフトウェアテストは総合的なスキルを必要とする最高峰の奥義です。「テストを書き、コードを直す」この正確なくりかえしを身に付ければ、将来的にプロジェクトに豊富な見返りをもたらします。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tdd/yutaro_test.png" alt="yutaro test">
</div>
</div>
<div class="sect2">
<h3 id="_仕様書としてのテストコード">9.1. 仕様書としてのテストコード</h3>
<div class="paragraph">
<p>きちんと整備したテストコードは、元のコードの仕様書のようなものです。ふつうの仕様書は読むだけですが、テストコードは実行してみることでソフトウェアの動作をチェックできます。</p>
</div>
<div class="paragraph">
<p>OpenFlowネットワークとコントローラの保守をまかされたとしましょう。もし前任者からテストコードをもらえなければ、コントローラを何度も実行しながら苦労して解読しなければなりません。逆に、テストさえもらえればコード本体を理解しやすくなりますし、気楽にリファクタリングや修正ができます。とくにOpenFlowではスイッチとコントローラが複雑に絡み合い、しかもそれぞれがステートを持つので、ソフトウェアで自動化したテストがないとやってられません。</p>
</div>
<div class="paragraph">
<p>TremaはOpenFlowコントローラ開発のためのテストツールが充実しています。たとえばアジャイル開発者の大事な仕事道具、<strong>テスト駆動開発</strong>もTremaはサポートしています。本章ではテスト駆動を使ったコントローラの開発風景を紹介します。要点をつかみやすくするため、動作の単純なリピータハブを取り上げます。ではさっそく実際のテスト駆動開発の流れを見て行きましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">テスト駆動開発とテストファーストの違いは？</div>
<div class="paragraph">
<p>テスト駆動開発やテストファーストなど似たような用語に混乱している人も多いと思います。この2つの違いは何でしょうか。</p>
</div>
<div class="paragraph">
<p><strong>テストファースト</strong>はテスト駆動開発のステップの一部なので、テスト駆動開発のほうがより大きな概念になります。テスト駆動開発では、まずは失敗する見込みでテストを書き (このステップがテストファースト)、次にこのテストを通すためのコードを書きます。最後にコードをリファクタリングして、クリーンにします。この3ステップを数分間隔で何度も回しながら開発するのがテスト駆動開発です。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_リピータハブの動き">9.2. リピータハブの動き</h3>
<div class="paragraph">
<p>まずは、リピータハブがどのように動くか見て行きましょう。リピータハブにホスト 3 台をつなげた<a href="#repeater_hub">図 9-1</a>のネットワークを考えてください。ホスト 1 からホスト 2 へパケットを送信すると、リピータハブは入ってきたパケットを複製し他のすべてのホストにばらまきます。つまり、通信に関係のないホスト 3 もホスト 2 宛のパケットを受信します。このように、リピータハブはラーニングスイッチ (<a href="#learning_switch">7 章「すべての基本、ラーニングスイッチ」</a>) のような MAC アドレスの学習は行わず、とにかくすべてのホストへパケットを送ってしまうので、バカハブとかダムハブとも呼びます。</p>
</div>
<div id="repeater_hub" class="imageblock">
<div class="content">
<img src="images/tdd/repeater_hub.png" alt="repeater hub">
</div>
<div class="title">図 9-1: ホスト 3 台をつなげたリピータハブの動作</div>
</div>
<div class="paragraph">
<p>これを OpenFlow で実装すると<a href="#repeater_hub_openflow">図 9-2</a>のようになります。ホスト 1 がパケットを送信すると、スイッチからコントローラに Packet In が起こります。ここでコントローラは「今後は同様のパケットを他の全ポートへばらまけ (フラッディング)」という Flow Mod を打ちます。また、Packet In を起こしたホスト 1 からのパケットを他の全ポートへ Packet Out でフラッディングします。</p>
</div>
<div id="repeater_hub_openflow" class="imageblock">
<div class="content">
<img src="images/tdd/repeater_hub_openflow.png" alt="repeater hub openflow">
</div>
<div class="title">図 9-2: OpenFlow 版リピータハブ</div>
</div>
</div>
<div class="sect2">
<h3 id="_どこまでテストするか">9.3. どこまでテストするか？</h3>
<div class="paragraph">
<p>おおまかな仕組みはわかったので、テストを書き始める前にテスト戦略を決めます。テスト戦略とは言い換えると「どこまでテストするか？」ということです。これは経験が必要なむずかしい問題なので、ソフトウェアテスト界の賢人達の言葉を借りることにしましょう。</p>
</div>
<div class="paragraph">
<p>テスト駆動開発の第一人者、ケント・ベックは stackoverflow.com の「どこまでテストするか？」というトピック <sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnote_14" title="View footnote.">14</a>]</sup> に次の投稿をしています。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>私はテストコードではなく動くコードに対してお金をもらっているので、ある程度の確信が得られる最低限のテストをするというのが私の主義だ (このレベルは業界水準からすると高いのではと思うが、ただの思い上がりかもしれない)。ふつうある種のミスを自分は犯さないとわかっていれば (コンストラクタで間違った変数をセットするとか)、そのためのテストはしない。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Ruby on Rails の作者として有名な David Heinemeier Hansson 氏 (以下、DHH) は、彼の勤める Basecamp 社のブログ <sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnote_15" title="View footnote.">15</a>]</sup> で次のように語っています。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>コードのすべての行にはコストがかかる。テストを書くのにも、更新するのにも、読んで理解するのにも時間がかかる。したがってテストを書くのに必要なコストよりも、テストから得られる利益を大きくしなければいけない。テストのやりすぎは当然ながら間違っている。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>2人の言葉をまとめるとこうなります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>目的はテストコードではなく、コードが正しく動くこと</p>
</li>
<li>
<p>正しく動くと確信が得られる、最低限のテストコードを書こう</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>リピータハブのテスト戦略もこれに従いましょう。最低限のテストシナリオはこうなるはずです。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ホスト 1・ホスト 2・ホスト 3 をスイッチにつなげ、</p>
</li>
<li>
<p>リピータハブのコントローラを起動したとき、</p>
</li>
<li>
<p>ホスト 1 がホスト 2 へパケットを送ると、</p>
</li>
<li>
<p>ホスト 2・ホスト 3 がパケットを受け取る</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>それぞれのステップを順にテストコードに起こしていきます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_テストに使うツール">9.4. テストに使うツール</h3>
<div class="paragraph">
<p>コントローラのテストには次の 3 つのツールを使います。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Cucumber<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnote_16" title="View footnote.">16</a>]</sup></dt>
<dd>
<p>受け入れテストの定番ツール。ブラックボックステストをシナリオ形式で簡潔に記述できる</p>
</dd>
<dt class="hdlist1">Aruba<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnote_17" title="View footnote.">17</a>]</sup></dt>
<dd>
<p>コマンドラインツールのテストツール。コマンドの起動と出力、終了ステータスなどのテストができる</p>
</dd>
<dt class="hdlist1">trema/cucumber_step_definitions<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnote_18" title="View footnote.">18</a>]</sup></dt>
<dd>
<p>ArubaのTrema用ライブラリ。コントローラの起動やパケットの送受信といった、コントローラのテストを記述できる</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_パケット受信をテストする">9.5. パケット受信をテストする</h3>
<div class="paragraph">
<p>では、リピータハブの動作を Cucumber の受け入れテストにしていきます。最初のテストシナリオを思い出してください。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ホスト 1・ホスト 2・ホスト 3 をスイッチにつなげ、</p>
</li>
<li>
<p>リピータハブのコントローラを起動したとき、</p>
</li>
<li>
<p>ホスト 1 がホスト 2 へパケットを送ると、</p>
</li>
<li>
<p>ホスト 2・ホスト 3 がパケットを受け取る</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>テストシナリオを Cucumber の受け入れテストに置き換えるには、シナリオの各ステップを<strong>Given(前提条件)</strong>・<strong>When(〜したとき)</strong>・<strong>Then(こうなる)</strong>の3つに分類します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Given:</strong> ホスト 1・ホスト 2・ホスト 3 をスイッチにつなげ、リピータハブのコントローラを起動したとき、</p>
</li>
<li>
<p><strong>When:</strong> ホスト 1 がホスト 2 へパケットを送ると、</p>
</li>
<li>
<p><strong>Then:</strong> ホスト 2・ホスト 3 がパケットを受け取る。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>では、まずは最初の Given ステップを Cucumber のコードに直します。</p>
</div>
<div class="sect3">
<h4 id="_given_仮想ネットワークでリピータハブを動かす">9.5.1. Given: 仮想ネットワークでリピータハブを動かす</h4>
<div class="paragraph">
<p>シナリオの前提条件 (Given) には、まずはコントローラにつなげるスイッチとホスト 3 台のネットワーク構成 (<a href="#repeater_hub">図 9-1</a>) を記述します。Cucumber のテストファイル <code>features/repeater_hub.feature</code> はこうなります:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Given a file named "trema.conf" with:
  """
  vswitch('repeater_hub') { datapath_id 0xabc }

  vhost('host1') {
    ip '192.168.0.1'
    promisc true
  }
  vhost('host2') {
    ip '192.168.0.2'
    promisc true
  }
  vhost('host3') {
    ip '192.168.0.3'
    promisc true
  }

  link 'repeater_hub', 'host1'
  link 'repeater_hub', 'host2'
  link 'repeater_hub', 'host3'
  """</code></pre>
</div>
</div>
<div class="paragraph">
<p>最初の行 <code>Given a file named "trema.conf" with: &#8230;&#8203;</code> は、「&#8230;&#8203; という内容のファイル <code>trema.conf</code> があったとき、」を表すテストステップです。このように、Cucumber では英語 (自然言語) でテストステップを記述できます。</p>
</div>
<div class="paragraph">
<p>それぞれの仮想ホストで <code>promisc</code> オプション (プロミスキャスモード。自分宛でないパケットも受け取れるようにするモード) を <code>true</code> にしていることに注意してください。リピータハブはパケットをすべてのポートにばらまくので、こうすることでホストがどんなパケットでも受信できるようにしておきます。</p>
</div>
<div class="paragraph">
<p>続いて、この仮想ネットワーク上でコントローラを起動する Given ステップを次のように書きます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、シェル上で次のコマンドを実行するのと同じです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/trema run lib/repeater_hub.rb -c trema.conf -d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given が書けたところですぐに実行してみます。まだ <code>lib/repeater_hub.rb</code> ファイルを作っていないのでエラーになることはわかりきっていますが、エラーを確認するためにあえて実行します。次のコマンドを実行すると、受け入れテストファイル <code>features/repeater_hub.feature</code> を実行しテスト結果を表示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/cucumber features/repeater_hub.feature
Feature: Repeater Hub example
  @sudo
  Scenario: Run
    Given a file named "trema.conf" with:
      """
      vswitch('repeater_hub') { datapath_id 0xabc }

      vhost('host1') {
        ip '192.168.0.1'
        promisc true
      }
      vhost('host2') {
        ip '192.168.0.2'
        promisc true
      }
      vhost('host3') {
        ip '192.168.0.3'
        promisc true
      }

      link 'repeater_hub', 'host1'
      link 'repeater_hub', 'host2'
      link 'repeater_hub', 'host3'
      """
&lt;&lt;-STDERR
/home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/lib/trema/command.rb:40:in `load': cannot load such file -- ../../lib/repeater_hub.rb (LoadError)
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/lib/trema/command.rb:40:in `run'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:54:in `block (2 levels) in &lt;module:App&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/command_support.rb:126:in `call'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/command_support.rb:126:in `execute'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:296:in `block in call_command'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:309:in `call'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:309:in `call_command'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/gli-2.13.2/lib/gli/app_support.rb:83:in `run'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:252:in `&lt;module:App&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:14:in `&lt;module:Trema&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/gems/trema-0.7.1/bin/trema:12:in `&lt;top (required)&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/trema:23:in `load'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/trema:23:in `&lt;main&gt;'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `eval'
        from /home/yasuhito/.rvm/gems/ruby-2.2.0/bin/ruby_executable_hooks:15:in `&lt;main&gt;'

STDERR
    And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"
      expected "trema run ../../lib/repeater_hub.rb -c trema.conf -d" to be successfully executed (RSpec::Expectations::ExpectationNotMetError)
      ./features/step_definitions/trema_steps.rb:41:in `/^I trema run "([^"]*)"( interactively)? with the configuration "([^"]*)"$/'
      features/repeater_hub.feature:27:in `And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"'

Failing Scenarios:
cucumber features/repeater_hub.feature:5 # Scenario: Run as a daemon

1 scenario (1 failed)
3 steps (1 failed, 1 skipped, 1 passed)
0m8.113s</code></pre>
</div>
</div>
<div class="paragraph">
<p>予想通り、<code>trema run</code> の箇所でエラーになりました。エラーメッセージによると <code>lib/repeater_hub.rb</code> というファイルが無いと言っています。このエラーを直すために、とりあえず空のファイルを作ります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ mkdir lib
$ touch lib/repeater_hub.rb
$ ./bin/cucumber features/repeater_hub.feature</code></pre>
</div>
</div>
<div class="paragraph">
<p>再びテストを実行すると、今度は次のエラーメッセージが出ます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/cucumber features/repeater_hub.feature
(中略)
&lt;&lt;-STDERR
error: No controller class is defined.

STDERR
    And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf" # features/step_definitions/trema_steps.rb:30
      expected "trema run ../../lib/repeater_hub.rb -c trema.conf -d" to be successfully executed (RSpec::Expectations::ExpectationNotMetError)
      ./features/step_definitions/trema_steps.rb:41:in `/^I trema run "([^"]*)"( interactively)? with the configuration "([^"]*)"$/'
      features/repeater_hub.feature:27:in `And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>repeater_hub.rb にコントローラクラスが定義されていない、というエラーです。エラーを修正するために、<code>RepeaterHub</code> クラスの定義を追加してみます。エラーを修正できればいいので、クラスの中身はまだ書きません。</p>
</div>
<div class="listingblock">
<div class="title">lib/repeater_hub.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">RepeaterHub</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再びテストを実行してみます。今度はパスするはずです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/cucumber features/repeater_hub.feature
(中略)
1 scenario (1 passed)
3 steps (3 passed)
0m18.207s</code></pre>
</div>
</div>
<div class="paragraph">
<p>やりました! これで Given ステップは動作しました。</p>
</div>
<div class="paragraph">
<p>このようにテスト駆動開発では、最初にテストを書き、わざとエラーを起こしてからそれを直すためのコードをちょっとだけ追加します。テスト実行結果からのフィードバックを得ながら「テストを書き、コードを直す」を何度もくりかえしつつ最終的な完成形に近づけていくのです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_when_パケットの送信">9.5.2. When: パケットの送信</h4>
<div class="paragraph">
<p>When には「〜したとき」というきっかけになる動作を記述します。ここでは、Given で定義したホスト host1 から host2 にパケットを送る処理を書きます。パケットを送るコマンドは、trema send_packets でした。Cucumber (Aruba) では、実行したいコマンドを次のように <code>I run &#8230;&#8203;</code> で直接書けます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>When I run `trema send_packets --source host1 --dest host2`</pre>
</div>
</div>
<div class="paragraph">
<p>テストを一行追加しただけですが、念のため実行しておきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/cucumber features/repeater_hub.feature
(中略)
1 scenario (1 passed)
4 steps (4 passed)
0m21.910s</code></pre>
</div>
</div>
<div class="paragraph">
<p>問題なくテストが通りました。次は Then に進みます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_then_受信したパケットの数">9.5.3. Then: 受信したパケットの数</h4>
<div class="paragraph">
<p>Then には「最終的にこうなるはず」というテストを書きます。ここでは、「ホスト 2・ホスト 3 がパケットを受け取るはず」というステップを書けばよいですね。これは次のように書けます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Then the number of packets received by "host2" should be:
  |      source | #packets |
  | 192.168.0.1 |        1 |
And the number of packets received by "host3" should be:
  |      source | #packets |
  | 192.168.0.1 |        1 |</code></pre>
</div>
</div>
<div class="paragraph">
<p>このステップはテーブル形式をしており、ホスト 2・ホスト 3 それぞれについて、送信元 IP アドレス 192.168.0.1 からパケットを 1 つ受信するはず、ということを表しています。</p>
</div>
<div class="paragraph">
<p>ではさっそく実行してみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/cucumber features/repeater_hub.feature
(中略)
    When I run `trema send_packets --source host1 --dest host2`
&lt;&lt;-STDERR

STDERR
    Then the number of packets received by "host2" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

      expected: 1
           got: 0

      (compared using ==)
       (RSpec::Expectations::ExpectationNotMetError)
      ./features/step_definitions/show_stats_steps.rb:52:in `block (2 levels) in &lt;top (required)&gt;'
      ./features/step_definitions/show_stats_steps.rb:50:in `each'
      ./features/step_definitions/show_stats_steps.rb:50:in `/^the number of packets received by "(.*?)" should be:$/'
      features/repeater_hub.feature:30:in `Then the number of packets received by "host2" should be:'
    And the number of packets received by "host3" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

Failing Scenarios:
cucumber features/repeater_hub.feature:5 # Scenario: Run as a daemon

1 scenario (1 failed)
6 steps (1 failed, 1 skipped, 4 passed)
0m20.198s</code></pre>
</div>
</div>
<div class="paragraph">
<p>host2 に 1 つ届くはずだったパケットが届いておらず、失敗しています。<code>RepeaterHub</code> クラスはまだ何も機能を実装していないので当然です。</p>
</div>
<div class="paragraph">
<p>フラッディングをする Flow Mod を打ち込むコードを <code>RepeaterHub</code> クラスに追加して、もう一度テストしてみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">RepeaterHub</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
    send_flow_mod_add(
      datapath_id,
      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="symbol">:flood</span>)
    )
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ./bin/cucumber features/repeater_hub.feature
(中略)
    Then the number of packets received by "host2" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

      expected: 1
           got: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>失敗してしまいました。まだ host2 がパケットを受信できていません。そういえば、Flow Modしただけではパケットは送信されないので、明示的に Packet Out してやらないといけないのでした。そこで次のように Packet Out を追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">RepeaterHub</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
    send_flow_mod_add(
      datapath_id,
      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="symbol">:flood</span>)
    )
    send_packet_out(
      datapath_id,
      <span class="key">raw_data</span>: packet_in.raw_data,
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="symbol">:flood</span>)
    )
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再び実行してみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ bundle exec cucumber features/repeater_hub.feature
Rack is disabled
Feature: "Repeater Hub" example

  @sudo
  Scenario: Run as a daemon
    Given a file named "trema.conf" with:
      """
      vswitch('repeater_hub') { datapath_id 0xabc }

      vhost('host1') {
        ip '192.168.0.1'
        promisc true
      }
      vhost('host2') {
        ip '192.168.0.2'
        promisc true
      }
      vhost('host3') {
        ip '192.168.0.3'
        promisc true
      }

      link 'repeater_hub', 'host1'
      link 'repeater_hub', 'host2'
      link 'repeater_hub', 'host3'
      """
    And I trema run "lib/repeater_hub.rb" with the configuration "trema.conf"
    When I run `trema send_packets --source host1 --dest host2`
    Then the number of packets received by "host2" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |
    And the number of packets received by "host3" should be:
      | source      | #packets |
      | 192.168.0.1 | 1        |

1 scenario (1 passed)
6 steps (6 passed)
0m20.976s</code></pre>
</div>
</div>
<div class="paragraph">
<p>すべてのテストに通りました! 次はテスト駆動開発で欠かせないステップであるリファクタリングに進みます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_リファクタリング">9.6. リファクタリング</h3>
<div class="paragraph">
<p>リファクタリングとは、テストコードによってソフトウェアの振る舞いを保ちつつ、理解や修正が簡単になるようにソースコードを改善することです。Rubyにはリファクタリング用の便利なツールがたくさんあります。中でもよく使うツールは次の 4 つです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">reek<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnote_19" title="View footnote.">19</a>]</sup></dt>
<dd>
<p>Rubyコードの臭いを自動的に検知し、改善すべき場所を教えてくれる便利なツール</p>
</dd>
<dt class="hdlist1">flog<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnote_20" title="View footnote.">20</a>]</sup></dt>
<dd>
<p>すべてのメソッドの複雑度 (これが大きいほど複雑でテストしづらい) を客観的なポイントで表示</p>
</dd>
<dt class="hdlist1">flay<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnote_21" title="View footnote.">21</a>]</sup></dt>
<dd>
<p>メソッドのコピペなど、重複するコードを探して容赦なく指摘してくれる</p>
</dd>
<dt class="hdlist1">rubocop<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnote_22" title="View footnote.">22</a>]</sup></dt>
<dd>
<p>コードが標準的な Ruby のコーディングスタイルに沿っているかチェックしてくれる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>RepeaterHub</code> クラスは十分簡潔ですが、念のためこの 4 つを使ってチェックしておきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/reek lib/repeater_hub.rb

$ ./bin/flog lib/repeater_hub.rb
     9.0: flog total
     4.5: flog/method average

     5.6: RepeaterHub#packet_in            lib/repeater_hub.rb:7

$ ./bin/flay lib/repeater_hub.rb
Total score (lower is better) = 0

$ ./bin/rubocop lib/repeater_hub.rb
Inspecting 1 file
.

1 file inspected, no offenses detected</pre>
</div>
</div>
<div class="paragraph">
<p><code>reek</code>・<code>flog</code>・<code>flay</code>・<code>rubocop</code> コマンドすべてで、エラーメッセージは出ていません。ただし <code>flog</code> は複雑度を表示するだけなので、リファクタリングするかどうかは自分で判断する必要があります。今回のように、目安として複雑度が10ポイント以下であれば、リファクタリングの必要はありません。</p>
</div>
<div class="paragraph">
<p>もしもここでエラーメッセージが出た場合には、コントローラをリファクタリングします。エラーメッセージには修正のヒントが入っているので、それに従えば機械的に修正できます。動くテストコードがあるので、リファクタリングの最中に誤ってコードを壊してしまっても、すぐにミスしたことがわかります。</p>
</div>
<div class="paragraph">
<p>以上でコントローラとテストコードの一式が完成しました!</p>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_9">9.7. まとめ</h3>
<div class="paragraph">
<p>Tremaのユニットテストフレームワークを使ってリピータハブを作り、コントローラをテスト駆動開発する方法を学びました。今回学んだことは次の2つです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cucumber・Aruba・trema/cucumber_step_definitionsを使うと、コントローラを起動して仮想ホストの受信パケット数などをテストできる</p>
</li>
<li>
<p>テストをGiven・When・Thenの3ステップに分けて分析し設計する方法を学んだ。それぞれのステップをCucumberのテストコードに置き換えることで、テストコードが完成する</p>
</li>
<li>
<p>テストが通ったら必ずリファクタリングすること。<code>reek</code>・<code>flog</code>・<code>flay</code>・<code>rubocop</code> を使うと、コードの問題点を客観的に洗い出してくれる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本書で紹介するすべてのサンプルコードには、テストコード (<code>features/</code> 以下) が付属しています。本格的にテストコードを書く人は、参考にしてください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考文献_2">9.8. 参考文献</h3>
<div class="ulist">
<ul>
<li>
<p>『テスト駆動開発入門』(Kent Beck著／ピアソン・エデュケーション) テスト駆動開発のバイブルです。もったいないことに日本語版は訳がまずく、意味の通らないところがたくさんあります。もし英語が苦でなければ、原著の英語版で読むことをおすすめします。</p>
</li>
<li>
<p>『リファクタリング』(Martin Fowler著／ピアソン・エデュケーション) この本の最大の功績は、コードのまずい兆候を「コードの臭い」と表現したことです。粗相をした赤ちゃんのおむつのように臭うコードには改善が必要で、この本にはそのためのレシピがそろっています。この本はJavaですが、Ruby版(『リファクタリング：Rubyエディション』Jay Fields、Shane Harvie、Martin Fowler、Kent Beck著／アスキー・メディアワークス)もあります。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="one_way_bridge">10. 生活ネットワークをOpenFlowに移行する</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>あとは実践あるのみ!今までの知識を総動員し、自宅や職場のネットワークをOpenFlow化していろいろ実験してみましょう。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/one_way_bridge/bicycle.png" alt="bicycle">
</div>
</div>
<div class="sect2">
<h3 id="_どんどん規模を広げていこう">10.1. どんどん規模を広げていこう</h3>
<div class="paragraph">
<p>ここまでOpenFlowのプロトコルや動作モデル、そしてTremaを使ったOpenFlowプログラミングを学んできました。一人前のOpenFlowエンジニアとしてやっていくために必要な基礎知識はすでにひととおり身についたと言えます。</p>
</div>
<div class="paragraph">
<p>あとはひたすら実践するだけです。今まで手に入れた知識を実際に道具として使い、いま生活しているネットワーク上でOpenFlowを実際に動かしてみるのが一番です。まずは自宅のネットワークをOpenFlowで置き換えましょう。これがうまくいき物足りなくなったら、こんどは職場で小規模にOpenFlowネットワークを作りましょう。このように徐々に規模を広げて行くのです。</p>
</div>
<div class="paragraph">
<p>実際にその環境で暮らしてみて、はじめて見えてくるニーズやアイデア、改善案があります。初めて自転車に乗ったときのことを思い出してください。補助輪をはずしただけで最初は派手に転びますが、多少はケガをしつつもあきらめずに練習を繰り返しているうち誰でも乗りこなせるようになります。自転車に乗れれば、隣りの街やそのまた隣りと行動範囲は一気に広がります。しかし補助輪をはずさずにただ考えているだけではどこにも行けません。</p>
</div>
</div>
<div class="sect2">
<h3 id="_大ケガしないためのヘルメット">10.2. 大ケガしないためのヘルメット</h3>
<div class="paragraph">
<p>「でも、いきなりOpenFlowに移行してもし大失敗したら……」。そう考えるのが人情です。家のネットワークはともかく、もし職場のネットワークを止めて同僚に迷惑をかけてしまったらどうしよう……。管理者や上司に注意されたらどうしよう……。</p>
</div>
<div class="paragraph">
<p>本章ではそうした大失敗を防ぐための<strong>ヘルメット</strong>を紹介します。筆者らは、OpenFlowが登場したころから職場のネットワークで実験を始め、それこそ数え切れないほどの失敗を繰り返してきました。とにかく何度も怒られましたが、その経験からうまくやる方法をアドバイスできます。私たちは既存のネットワークを穏便にOpenFlowに移行するテクニックを持っています。ちょっとしたOpenFlowコントローラを書くだけで、移行の際に起こりがちなネットワーク障害を簡単に防げるのです。</p>
</div>
<div class="paragraph">
<p>まずは、私たちの失敗談を振り返らせてください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_私たちの失敗談">10.3. 私たちの失敗談</h3>
<div class="paragraph">
<p>OpenFlowが登場したばかりのころ、私たちはさっそくスイッチングハブ相当のOpenFlowコントローラを書いて小さなOpenFlowネットワークを職場に構築してみました。「おお、ちゃんと動くじゃん!」気を良くした私たちは、こともあろうにこのOpenFlowネットワークと職場ネットワークとをいきなりつないでしまいました。まあ大丈夫だろうと楽観的に考えていたのです。</p>
</div>
<div class="paragraph">
<p>しかしすぐにネットワーク障害が起こり、異常に気づいたネットワーク管理者からお叱りのメールを受け取ることになりました。障害時のセットアップを単純化すると<a href="#buggy_controller_setup">図10-1</a>のようになります。</p>
</div>
<div id="buggy_controller_setup" class="imageblock">
<div class="content">
<img src="images/one_way_bridge/buggy_controller_setup.png" alt="buggy controller setup">
</div>
<div class="title">図 10-1: 障害を起こしたときのネットワーク構成を単純化したもの</div>
</div>
<div class="paragraph">
<p>職場ネットワーク（レガシーネットワークとします）のスイッチにはホストを2台つないでおり、スイッチのポート3番をOpenFlowスイッチのポート1番と接続しました。このOpenFlowスイッチは、私たちが書いたスイッチングハブ相当のOpenFlowコントローラ(仮にBuggyControllerとします)で制御していました。</p>
</div>
<div class="sect3">
<h4 id="_障害報告_host_flappingが起こっている">10.3.1. 障害報告：Host Flappingが起こっている</h4>
<div class="paragraph">
<p>ネットワーク管理者から届いた障害報告メールには次のようにありました「レガシーネットワークのホストどうしが通信できなくなった。スイッチはHost Flapping警告を出している」</p>
</div>
<div class="paragraph">
<p>Host Flappingとは、1つのホストがいくつかのポートの間で高速で移動しているように見えるという障害です。「なんでそんなことが起こるんだろう？」われわれはすぐにOpenFlowネットワークを切断し、そしてもちろんネットワーク管理者にはごめんなさいメールを出してから、原因の分析にとりかかりました。</p>
</div>
</div>
<div class="sect3">
<h4 id="_障害原因が判明">10.3.2. 障害原因が判明</h4>
<div class="paragraph">
<p>分析の結果、<a href="#failure_analysis">図10-2</a>のようなシナリオが起こっているという結論に至りました。</p>
</div>
<div id="failure_analysis" class="imageblock">
<div class="content">
<img src="images/one_way_bridge/failure_analysis.png" alt="failure analysis">
</div>
<div class="title">図10-2レガシーネットワークで起こった障害のシナリオ</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>host1がhost2へパケットを送信する</p>
</li>
<li>
<p>BuggyControllerはOpenFlowスイッチポート1番からのPacket Inを受け取り、OpenFlowスイッチのスイッチポート1番にhost1がつながっていると学習する</p>
</li>
<li>
<p>レガシーネットワークスイッチが覚えている host1 の情報がエージアウトし消える <sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnote_23" title="View footnote.">23</a>]</sup></p>
</li>
<li>
<p>host2がhost1へパケットを送信する</p>
</li>
<li>
<p>BuggyControllerはスイッチポート1番から宛先＝host1のPacket Inを受け取る。ここで、host1はOpenFlowスイッチのスイッチポート1番にあると学習しているので、スイッチポート1番にPacket Outする</p>
</li>
<li>
<p>結果的に、host1はポート2と3の両方から同じパケットを受け取る。レガシーネットワークのスイッチから見ると、host2がスイッチポート2番と3番を高速に移動しているように見える</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>つまり、BuggyControllerがレガシーネットワークにパケットを逆流させたおかげでネットワークが大混乱し、通信できない状況が起きたのです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_教訓_これをやってはいけない">10.3.3. 教訓：これをやってはいけない</h4>
<div class="paragraph">
<p>振り返ると、失敗した原因は2つありました。</p>
</div>
<div class="paragraph">
<p>1つは、OpenFlowネットワークをいきなりレガシーネットワークとつないでしまったことです。OpenFlowネットワーク単体では動いていたのに、というのは言い訳にはなりません。若気の至りや経験不足から来る青いミスです。もう1つは、BuggyControllerがPacket Inと同じポートにPacket Outするという通常あり得ない動作をしていたことです。要所要所で <code>assert</code> を入れるといった防御的プログラミングや、ソフトウェアテスト(<a href="#tdd">9章「Trema でテスト駆動開発」</a>を参照)を徹底していれば防げるバグでしたが、当時の私たちは動かすことに精いっぱいでそこまで気が回りませんでした。</p>
</div>
<div class="paragraph">
<p>というわけで、大障害を起こして始めて気付くという最悪のパターンになってしまったわけです。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_openflowへの移行パターン">10.4. OpenFlowへの移行パターン</h3>
<div class="paragraph">
<p>大失敗をやらかしてしまった筆者たちは、OpenFlow移行のための作戦を練りなおさざるを得なくなりました。いろいろな方向から考えなおしたところ、OpenFlowへの移行方法には次の3つのパターンがあることがわかりました。もちろん、それぞれでメリット／デメリットや危険度が異なります。</p>
</div>
<div class="sect3">
<h4 id="_独立ネットワークパターン">10.4.1. 独立ネットワークパターン</h4>
<div class="paragraph">
<p>最初のパターンは、既存のレガシーネットワークにまったく手を加えずに、それとは独立したもう1つのOpenFlowネットワークを構築する方法です(<a href="#pattern1">図10-3</a>)。それぞれのネットワーク間でパケットの行き来はなく、お互いに完全に独立しています。</p>
</div>
<div id="pattern1" class="imageblock">
<div class="content">
<img src="images/one_way_bridge/pattern1.png" alt="pattern1">
</div>
<div class="title">図 10-3: レガシーネットワークとは独立したOpenFlowネットワークを構築し、徐々に拡大する</div>
</div>
<div class="paragraph">
<p>この状態から、レガシーネットワーク内のサーバや端末を徐々にOpenFlowネットワークに移動することで移行していきます。</p>
</div>
<div class="paragraph">
<p>それぞれのネットワーク間ではパケットが行き来できないので、OpenFlowネットワークがレガシーネットワークに悪影響を及ぼす可能性はまずありません。ただし、OpenFlowネットワークに移行する際には関連する機器同士（ファイルサーバとクライアント群など）を一度に移行する必要があります。これはトラブルを起こす可能性が高いため、レガシーネットワークの規模が大きい場合には移行が難しいという問題があります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_いきなり接続パターン">10.4.2. いきなり接続パターン</h4>
<div class="paragraph">
<p>次のパターンは、私たちがやったようにレガシーネットワークとOpenFlowネットワークをいきなりつなげてしまう方法です（<a href="#pattern2">図10-4</a>）。</p>
</div>
<div id="pattern2" class="imageblock">
<div class="content">
<img src="images/one_way_bridge/pattern2.png" alt="pattern2">
</div>
<div class="title">図 10-4: レガシーネットワークとOpenFlowネットワークを直結してしまう</div>
</div>
<div class="paragraph">
<p>この方法だと、相互に通信できるのでネットワーク間でのサーバや端末の移動は自由にできます。このため、独立ネットワークパターンに比べて移行の手間はずっと小さいと言えます。</p>
</div>
<div class="paragraph">
<p>ただしこの方法は、私たちが失敗したようにとてもリスクの高い方法です。OpenFlowネットワークのコントローラが完璧に作られていれば、このようにいきなりつなげても問題はありませんが、完璧を期するのはなかなかむずかしいものです。というのも、実際のトラフィックをコントローラに流し込んでみて初めて見つかるバグもあるからです。よって、この方法は自宅ネットワークなど他人に迷惑のかからないネットワーク以外では推奨できません。</p>
</div>
</div>
<div class="sect3">
<h4 id="_フィルタ経由で接続パターン">10.4.3. フィルタ経由で接続パターン</h4>
<div class="paragraph">
<p>最後のパターンは、今までに挙げてきた2つのパターンのいいとこどりです。2つのネットワークを接続するのですが、そのときに<strong>逆流防止フィルタ</strong>となるOpenFlowスイッチを間にはさむことでパケットの逆流が起きないようにします（<a href="#pattern3">図10-5</a>）。</p>
</div>
<div id="pattern3" class="imageblock">
<div class="content">
<img src="images/one_way_bridge/pattern3.png" alt="pattern3">
</div>
<div class="title">図 10-5: レガシーネットワークとOpenFlowネットワークの間での逆流を防止する</div>
</div>
<div class="paragraph">
<p>この逆流防止フィルタはたとえば、レガシーネットワーク→OpenFlow ネットワークのような一方向のパケットは通しますが、同じパケットがレガシー側に戻ることを防ぎます。逆方向も同様です。</p>
</div>
<div class="paragraph">
<p>この方法の利点は、逆流を防ぐだけで今回のケースも含めたかなりの障害を未然に防げることです。また、使い勝手はいきなり接続した場合と同じなのでOpenFlowへの移行も楽です。ただし、2つのネットワーク間にもう1つフィルタ用のOpenFlowスイッチをはさまなければならないという手間はかかります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_逆流防止フィルタ">10.5. 逆流防止フィルタ</h3>
<div class="paragraph">
<p>検討の結果、逆流防止フィルタを使ったパターンが一番良さそうでした。フィルタを動かすためのサーバもちょうど余っていましたし、何よりコントローラとして簡単に実装できそうだったからです。前置きが長くなりましたが、さっそくTremaで実装してみましょう。</p>
</div>
<div class="paragraph">
<p>逆流防止フィルタは1つのPacket Inに対して2つのフローエントリを設定します。1つは順方向のフローエントリで、入ってきたパケットをもう1つのスイッチポートに転送します。もう1つは逆方向のフローエントリで、同じパケットが逆方向に流れてきたときにこのパケットを落とします。</p>
</div>
<div class="sect3">
<h4 id="_ソースコード">10.5.1. ソースコード</h4>
<div class="paragraph">
<p>逆流防止フィルタ（OneWayBridge コントローラ）のソースコードは GitHub の trema/one_way_bridge リポジトリ (<a href="https://github.com/trema/one_way_bridge" class="bare">https://github.com/trema/one_way_bridge</a>) からダウンロードできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/one_way_bridge.git</pre>
</div>
</div>
<div class="paragraph">
<p>ダウンロードしたソースツリー上で <code>bundle install --binstubs</code> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd one_way_bridge
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>このコントローラは、Packet In と Flow Removed のハンドラだけを定義したとてもシンプルなものです。</p>
</div>
<div class="listingblock">
<div class="title">lib/one_way_bridge.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Safety-net controller bridging legacy and OpenFlow networks.</span>
<span class="keyword">class</span> <span class="class">OneWayBridge</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="keyword">def</span> <span class="function">packet_in</span>(datapath_id, packet_in)
    out_port = { <span class="integer">1</span> =&gt; <span class="integer">2</span>, <span class="integer">2</span> =&gt; <span class="integer">1</span> }.fetch(packet_in.in_port)
    add_flow datapath_id, packet_in.source_mac, packet_in.in_port, out_port
    send_packet datapath_id, packet_in, out_port
    add_drop_flow datapath_id, packet_in.source_mac, out_port
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">flow_removed</span>(datapath_id, packet_in)
    delete_flow datapath_id, packet_in.match.source_mac_address
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">add_flow</span>(datapath_id, source_mac, in_port, out_port)
    send_flow_mod_add(
      datapath_id,
      <span class="key">idle_timeout</span>: <span class="integer">10</span> * <span class="integer">60</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: in_port, <span class="key">source_mac_address</span>: source_mac),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(out_port)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add_drop_flow</span>(datapath_id, source_mac, in_port)
    send_flow_mod_add(
      datapath_id,
      <span class="key">idle_timeout</span>: <span class="integer">10</span> * <span class="integer">60</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: in_port, <span class="key">source_mac_address</span>: source_mac)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">send_packet</span>(datapath_id, packet_in, out_port)
    send_packet_out(
      datapath_id,
      <span class="key">packet_in</span>: packet_in,
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(out_port)
    )
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">delete_flow</span>(datapath_id, source_mac)
    send_flow_mod_delete(
      datapath_id,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">source_mac_address</span>: source_mac)
    )
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>packet_in</code> ハンドラでは、Packet Inしたスイッチポートとは別のポートへパケットを転送するフローエントリを設定し（<code>add_flow</code> メソッド）、Packet Inを起こしたパケットを転送します（<code>send_packet</code> メソッド）。また、同じパケットが逆向きに流れないようにするフローエントリを設定することで逆流を防ぎます（<code>add_drop_flow</code> メソッド）。同じパケットかどうかは送信元のMACアドレスが同じかどうかで判断します。</p>
</div>
<div class="paragraph">
<p><code>flow_removed</code> ハンドラは、順方向または逆方向のフローエントリが消えたときに呼ばれます。これらのフローエントリはどちらも <code>:source_mac_address</code> に同じMACアドレスを指定しているので、<code>delete_flow</code> メソッドでもう片方の対になるフローエントリを消します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_実行してみよう_5">10.5.2. 実行してみよう</h4>
<div class="paragraph">
<p>逆流防止フィルタを実行するには、レガシーネットワークとOpenFlowネットワークの間にOpenFlowスイッチをはさみ、これをOneWayBridgeコントローラで制御します。でも実機のOpenFlowスイッチを準備するのは大変なので、Tremaの仮想ネットワーク機能でやってしまいましょう。NICが2枚挿さったサーバを用意し、仮想ネットワーク内で起動した仮想スイッチ(vswitch)の各ポートとそれぞれのNICを接続します(<a href="#one_way_bridge_setup">図10-6</a>）。</p>
</div>
<div id="one_way_bridge_setup" class="imageblock">
<div class="content">
<img src="images/one_way_bridge/one_way_bridge_setup.png" alt="one way bridge setup">
</div>
<div class="title">図 10-6: 逆流防止フィルタ（OneWayBridgeコントローラ）を実行するための物理構成例</div>
</div>
<div class="paragraph">
<p>この物理構成をTrema設定ファイルにしたものが以下です。仮想リンク（<code>link</code> で始まる行）の端点にインタフェース名eth0、eth1を指定していることに注目してください。</p>
</div>
<div class="listingblock">
<div class="title">逆流防止フィルタ（OneWayBridgeコントローラ）の設定ファイル</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch (<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>) {
  datapath_id <span class="integer">0xabc</span>
}

link <span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">eth0</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">eth1</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>実行するには、この設定ファイルを <code>trema run</code> の <code>-c</code> オプションに渡します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/one-way-bridge.rb -c ./trema.conf</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_職場で使ってみた">10.5.3. 職場で使ってみた</h4>
<div class="paragraph">
<p>さっそくこの逆流防止フィルタを導入したところ、問題は起こらなくなりました。現在、OpenFlowスイッチ5台、ホスト約100台から構成されるOpenFlowネットワークを職場ネットワークと接続して運用しています。このOpenFlowネットワークは現在もどんどん拡大しつつあり、その上でOpenFlowを使ったたくさんのアプリケーションが生まれています。こうした<strong>実践あるのみ</strong>という姿勢から生まれたたくさんのアプリケーション、それを支えるプログラミングフレームワークとして誕生したのがTremaです。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_10">10.6. まとめ</h3>
<div class="paragraph">
<p>職場のネットワークを安全にOpenFlowに移行するためのTipsを学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>レガシーネットワークをOpenFlowに移行するいくつかのパターンを考察。自宅など自由にできるネットワークでは<strong>いきなり接続パターン</strong>で十分だが、職場ネットワークでは<strong>逆流防止パターン</strong>が最適</p>
</li>
<li>
<p>逆流防止フィルタを実現するOpenFlowコントローラを実装。2つのフローエントリを設定するだけで、簡単に逆流を防止できる</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="firewall">11. ファイアウォール</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>ファイアウォールは、外部からの不要なパケットの通過を遮断することで、ネットワークを攻撃から守るネットワーク機器です。そのファイアウォールを OpenFlow を使って作ってみましょう。</p>
</div>
<div class="sect2">
<h3 id="_透過型ファイアウォール">11.1. 透過型ファイアウォール</h3>
<div class="paragraph">
<p>今回実装するファイアウォールはいわゆる<strong>透過型ファイアウォール</strong>です。<a href="#transparent_firewall">図 11-1</a> のようにルータとホストの間にブリッジとしてはさむだけでパケットのフィルタリングが可能です。既存のルータをそのまま使うため、各ホストのネットワーク設定を変更しなくてよいという利点があります。</p>
</div>
<div id="transparent_firewall" class="imageblock">
<div class="content">
<img src="images/transparent_firewall/transparent_firewall.png" alt="transparent firewall">
</div>
<div class="title">図 11-1: 透過型ファイアウォール</div>
</div>
<div class="paragraph">
<p>パケットのフィルタリングはIPv4ヘッダの情報に基づいて行います。今回はフィルタリングのルールが異なる以下の2種類ファイアウォールを実装します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">BlockRFC1918</dt>
<dd>
<p>RFC1918が定義するプライベートアドレスを送信元または宛先とするパケットを遮断するファイアウォール。外側からと内側からの両方のパケットを遮断する。</p>
</dd>
<dt class="hdlist1">PassDelegated</dt>
<dd>
<p>グローバルアドレスからのパケットのみを通すファイアウォール。外側→内側のパケットのみをフィルタする。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_blockrfc1918コントローラ">11.2. BlockRFC1918コントローラ</h3>
<div class="paragraph">
<p>BlockRFC1918コントローラは送信元または宛先 IP アドレスがプライベートアドレスのパケットを遮断します (<a href="#block_rfc1918">図 11-2</a>)。プライベートアドレスは RFC1918 (プライベート網のアドレス割当) が定義する次の 3 つの IP アドレス空間です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>10.0.0.0/8</p>
</li>
<li>
<p>172.16.0.0/12</p>
</li>
<li>
<p>192.168.0.0/16</p>
</li>
</ul>
</div>
<div id="block_rfc1918" class="imageblock">
<div class="content">
<img src="images/transparent_firewall/block_rfc1918.png" alt="block rfc1918">
</div>
<div class="title">図 11-2: BlockRFC1918ファイアウォールはプライベートアドレスからのパケットを遮断</div>
</div>
<div class="sect3">
<h4 id="_実行してみよう_6">11.2.1. 実行してみよう</h4>
<div class="paragraph">
<p>仮想ネットワークを使って BlockRFC1918 コントローラを起動してみます。ソースコードと仮想ネットワークの設定ファイルは GitHub の <code>trema/transparent_firewall</code> リポジトリ (<a href="https://github.com/trema/transparent_firewall" class="bare">https://github.com/trema/transparent_firewall</a>) からダウンロードできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/transparent_firewall.git</pre>
</div>
</div>
<div class="paragraph">
<p>ダウンロードしたソースツリー上で <code>bundle install --binstubs</code> を実行すると、Tremaなどの実行環境一式を自動的にインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd transparent_firewall
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>GitHub から取得したソースリポジトリ内に、仮想スイッチ1台、仮想ホスト3台の構成を持つ設定ファイル <code>trema.conf</code> が入っています (<a href="#firewall_configuration">図 11-3</a>)。</p>
</div>
<div id="firewall_configuration" class="imageblock">
<div class="content">
<img src="images/transparent_firewall/configuration.png" alt="configuration">
</div>
<div class="title">図 11-3: BlockRFC1918 を実行するための仮想ネットワーク構成</div>
</div>
<div class="listingblock">
<div class="title">trema.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch(<span class="string"><span class="delimiter">'</span><span class="content">firewall</span><span class="delimiter">'</span></span>) { datapath_id <span class="integer">0xabc</span> }

vhost(<span class="string"><span class="delimiter">'</span><span class="content">outside</span><span class="delimiter">'</span></span>) { ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.1</span><span class="delimiter">'</span></span> }
vhost(<span class="string"><span class="delimiter">'</span><span class="content">inside</span><span class="delimiter">'</span></span>) { ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.2</span><span class="delimiter">'</span></span> }
vhost(<span class="string"><span class="delimiter">'</span><span class="content">inspector</span><span class="delimiter">'</span></span>) {
  ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.3</span><span class="delimiter">'</span></span>
  promisc <span class="predefined-constant">true</span>
}

link <span class="string"><span class="delimiter">'</span><span class="content">firewall</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">outside</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">firewall</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">inside</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">firewall</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">inspector</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ホスト outside は外側のネットワーク、たとえばインターネット上のホストとして動作します。ホスト inside は内側のネットワークのホストです。ホスト inspector は BlockRFC1918 ファイアウォールが落としたパケットを調べるためのデバッグ用ホストです。inspector は outside または inside 宛のパケットを受け取るので、<code>promisc</code> オプションを有効にすることで自分宛でないパケットも受け取れるようにしておきます。</p>
</div>
<div class="paragraph">
<p>では、いつものように <code>trema run</code> の <code>-c</code> オプションにこの設定ファイルを渡して BlockRFC1918 コントローラを実行してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/block_rfc1918.rb -c trema.conf
0xabc: connected
0xabc: loading finished</pre>
</div>
</div>
<div class="paragraph">
<p>別ターミナルを開き、<code>trema send_packets</code> コマンドを使って outside と inside ホストの間でテストパケットを送ってみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source outside --dest inside
$ ./bin/trema send_packets --source inside --dest outside</pre>
</div>
</div>
<div class="paragraph">
<p>outside と inside はどちらもプライベートアドレスを持つので、BlockRFC1918 コントローラがパケットを落とすはずです。落としたパケットは inspector ホストへ送られます。</p>
</div>
<div class="paragraph">
<p><code>trema show_stats</code> コマンドで outside、inside そして inspector の受信パケット数をチェックしてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema show_stats outside
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats inside
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats inspector
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに、outside と inside の <code>show_stats</code> には <code>Packets received:</code> の項目がないので、どちらにもパケットは届いていません。そして、落としたパケット 2 つはどちらも inspector に届いています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blockrfc1918のソースコード">11.3. BlockRFC1918のソースコード</h3>
<div class="paragraph">
<p>BlockRFC1918のソースコードをざっと眺めてみましょう。やっていることは基本的にフローエントリの設定だけなので、難しい点はありません。</p>
</div>
<div class="listingblock">
<div class="title">lib/block_rfc1918.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># A sample transparent firewall</span>
<span class="keyword">class</span> <span class="class">BlockRFC1918</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="constant">PORT</span> = {
    <span class="key">outside</span>: <span class="integer">1</span>,
    <span class="key">inside</span>: <span class="integer">2</span>,
    <span class="key">inspect</span>: <span class="integer">3</span>
  }

  <span class="constant">PREFIX</span> = [<span class="string"><span class="delimiter">'</span><span class="content">10.0.0.0/8</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">172.16.0.0/12</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">192.168.0.0/16</span><span class="delimiter">'</span></span>].map <span class="keyword">do</span> |each|
    <span class="constant">IPv4Address</span>.new each
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
    <span class="keyword">if</span> <span class="instance-variable">@dpid</span>
      logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content">: ignored</span><span class="delimiter">&quot;</span></span>
      <span class="keyword">return</span>
    <span class="keyword">end</span>
    <span class="instance-variable">@dpid</span> = dpid
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: connected</span><span class="delimiter">&quot;</span></span>
    start_loading
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_disconnected</span>(dpid)
    <span class="keyword">return</span> <span class="keyword">if</span> <span class="instance-variable">@dpid</span> != dpid
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: disconnected</span><span class="delimiter">&quot;</span></span>
    <span class="instance-variable">@dpid</span> = <span class="predefined-constant">nil</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">barrier_reply</span>(dpid, _message)
    <span class="keyword">return</span> <span class="keyword">if</span> dpid != <span class="instance-variable">@dpid</span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: loading finished</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">start_loading</span>
    <span class="constant">PREFIX</span>.each <span class="keyword">do</span> |each|
      block_prefix_on_port <span class="key">prefix</span>: each, <span class="key">in_port</span>: <span class="symbol">:inside</span>, <span class="key">priority</span>: <span class="integer">5000</span>
      block_prefix_on_port <span class="key">prefix</span>: each, <span class="key">in_port</span>: <span class="symbol">:outside</span>, <span class="key">priority</span>: <span class="integer">4000</span>
    <span class="keyword">end</span>
    install_postamble <span class="integer">1500</span>
    send_message <span class="instance-variable">@dpid</span>, <span class="constant">Barrier</span>::<span class="constant">Request</span>.new
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">block_prefix_on_port</span>(<span class="key">prefix</span>:, <span class="key">in_port</span>:, <span class="key">priority</span>:)
    send_flow_mod_add(
      <span class="instance-variable">@dpid</span>,
      <span class="key">priority</span>: priority + <span class="integer">100</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[in_port],
                       <span class="key">ether_type</span>: <span class="integer">0x0800</span>,
                       <span class="key">source_ip_address</span>: prefix),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inspect</span>]))
    send_flow_mod_add(
      <span class="instance-variable">@dpid</span>,
      <span class="key">priority</span>: priority,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[in_port],
                       <span class="key">ether_type</span>: <span class="integer">0x0800</span>,
                       <span class="key">destination_ip_address</span>: prefix),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inspect</span>]))
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">install_postamble</span>(priority)
    send_flow_mod_add(
      <span class="instance-variable">@dpid</span>,
      <span class="key">priority</span>: priority + <span class="integer">100</span>,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:inside</span>]),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:outside</span>]))
    send_flow_mod_add(
      <span class="instance-variable">@dpid</span>,
      <span class="key">priority</span>: priority,
      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]),
      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>スイッチがコントローラに接続すると、<code>switch_ready</code> ハンドラが呼ばれます。<code>switch_ready</code> ハンドラでは、フローエントリを設定する <code>start_loading</code> メソッドを呼びます。</p>
</div>
<div class="listingblock">
<div class="title">BlockRFC1918#switch_ready (lib/block_rfc1918.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
  <span class="keyword">if</span> <span class="instance-variable">@dpid</span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content">: ignored</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">return</span>
  <span class="keyword">end</span>
  <span class="instance-variable">@dpid</span> = dpid
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: connected</span><span class="delimiter">&quot;</span></span>
  start_loading <i class="conum" data-value="1"></i><b>(1)</b>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>フローエントリを設定する <code>start_loading</code> メソッドを呼ぶ</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>start_loading</code> メソッドでは、パケットのドロップと転送用のフローエントリを設定します。まず、RFC1918 が定義する 3 つのプライベートアドレス空間それぞれについて、送信元または宛先 IP アドレスがプライベートアドレスのパケットを <code>inspector</code> ホストに転送するフローエントリを <code>block_prefix_on_port</code> メソッドで設定します。</p>
</div>
<div class="listingblock">
<div class="title">BlockRFC1918#start_loading, BlockRFC1918#block_prefix_on_port (lib/block_rfc1918.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start_loading</span>
  <span class="constant">PREFIX</span>.each <span class="keyword">do</span> |each|
    block_prefix_on_port <span class="key">prefix</span>: each, <span class="key">in_port</span>: <span class="symbol">:outside</span>, <span class="key">priority</span>: <span class="integer">4000</span> <i class="conum" data-value="1"></i><b>(1)</b>
    block_prefix_on_port <span class="key">prefix</span>: each, <span class="key">in_port</span>: <span class="symbol">:inside</span>, <span class="key">priority</span>: <span class="integer">5000</span>  <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="keyword">end</span>
  install_postamble <span class="integer">1500</span>
  send_message <span class="instance-variable">@dpid</span>, <span class="constant">Barrier</span>::<span class="constant">Request</span>.new
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">block_prefix_on_port</span>(<span class="key">prefix</span>:, <span class="key">in_port</span>:, <span class="key">priority</span>:)
  send_flow_mod_add( <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="instance-variable">@dpid</span>,
    <span class="key">priority</span>: priority + <span class="integer">100</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[in_port],
                     <span class="key">ether_type</span>: <span class="integer">0x0800</span>,
                     <span class="key">source_ip_address</span>: prefix),
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inspect</span>]))
  send_flow_mod_add( <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="instance-variable">@dpid</span>,
    <span class="key">priority</span>: priority,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[in_port],
                     <span class="key">ether_type</span>: <span class="integer">0x0800</span>,
                     <span class="key">destination_ip_address</span>: prefix),
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inspect</span>]))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スイッチのポート 1 番 (内側ネットワークと接続) で受信するパケットのフローエントリを設定</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>スイッチのポート 2 番 (外側ネットワークと接続) で受信するパケットのフローエントリを設定</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>送信元 IP アドレスがプライベートアドレスのパケットを <code>inspector</code> ホストに転送するフローエントリを追加</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>宛先 IP アドレスがプライベートアドレスのパケットを <code>inspector</code> ホストに転送するフローエントリを追加</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>送信元 IP アドレスがプライベートアドレスでないパケットは転送を許可します。このフローエントリは <code>install_postamble</code> メソッドで次のように設定します。</p>
</div>
<div class="listingblock">
<div class="title">BlockRFC1918#install_postamble (lib/block_rfc1918.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">install_postamble</span>(priority)
  send_flow_mod_add( <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="instance-variable">@dpid</span>,
    <span class="key">priority</span>: priority + <span class="integer">100</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:inside</span>]),
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:outside</span>]))
  send_flow_mod_add( <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="instance-variable">@dpid</span>,
    <span class="key">priority</span>: priority,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]),
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スイッチのポート 2 番 (内側ネットワーク) で受信した転送 OK なパケットはポート 1 番 (外側ネットワーク) へ転送</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>逆にスイッチのポート 1 番で受信した転送 OK なパケットはポート 2 番へ転送</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後に、すべてのフローエントリがスイッチに反映したことをバリアで確認します。スイッチへ <code>Barrier::Request</code> メッセージを送り、スイッチからの <code>Barrier::Reply</code> メッセージが <code>barrier_reply</code> ハンドラへ届けば、すべてフローエントリの設定は完了です。</p>
</div>
<div class="listingblock">
<div class="title">BlockRFC1918#barrier_reply (lib/block_rfc1918.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">barrier_reply</span>(dpid, _message) <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="keyword">return</span> <span class="keyword">if</span> dpid != <span class="instance-variable">@dpid</span>
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: loading finished</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span>

private

<span class="keyword">def</span> <span class="function">start_loading</span>
  <span class="constant">PREFIX</span>.each <span class="keyword">do</span> |each|
    block_prefix_on_port <span class="key">prefix</span>: each, <span class="key">in_port</span>: <span class="symbol">:outside</span>, <span class="key">priority</span>: <span class="integer">4000</span>
    block_prefix_on_port <span class="key">prefix</span>: each, <span class="key">in_port</span>: <span class="symbol">:inside</span>, <span class="key">priority</span>: <span class="integer">5000</span>
  <span class="keyword">end</span>
  install_postamble <span class="integer">1500</span>
  send_message <span class="instance-variable">@dpid</span>, <span class="constant">Barrier</span>::<span class="constant">Request</span>.new <i class="conum" data-value="1"></i><b>(1)</b>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スイッチに <code>Barrier::Request</code> メッセージを送り、すべてのフローエントリが反映されるのを待つ</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Barrier::Reply</code> が届けば、完了メッセージを <code>logger.info</code> で出す</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_passdelegatedコントローラ">11.4. PassDelegatedコントローラ</h3>
<div class="paragraph">
<p>PassDelegatedコントローラは、外側から内側向きのパケットのうち、送信元 IP アドレスがグローバル IP アドレスのパケットのみを通します (<a href="#pass_delegated">図 11-4</a>)。</p>
</div>
<div id="pass_delegated" class="imageblock">
<div class="content">
<img src="images/transparent_firewall/pass_delegated.png" alt="pass delegated">
</div>
<div class="title">図 11-4: PassDelegatedファイアウォールは外→内側向きのグローバルアドレスからのパケットを通す</div>
</div>
<div class="paragraph">
<p>フローエントリに用いるグローバル IP アドレスには、<code>trema/transparent_firewall</code> リポジトリ内のグローバル IP アドレス空間の一覧リスト (<code>*.txt</code> ファイル) を使います。このテキストファイルは、グローバルアドレスの割り当てなどを行う地域インターネットレジストリが提供するリストから自動生成したものです。たとえば、アジアと太平洋地域を担当する Asia-Pacific Network Information Centre (APNIC) のファイルは次のような 3000 以上の IP アドレス空間からなります。</p>
</div>
<div class="listingblock">
<div class="title">aggregated-delegated-apinic.txt</div>
<div class="content">
<pre>1.0.0.0/8
14.0.0.0/16
14.1.0.0/20
14.1.16.0/21
14.1.32.0/19
14.1.64.0/19
14.1.128.0/17
14.2.0.0/15
14.4.0.0/14
14.8.0.0/13
...</pre>
</div>
</div>
<div class="sect3">
<h4 id="_実行してみよう_7">11.4.1. 実行してみよう</h4>
<div class="paragraph">
<p>PassDelegated コントローラを<a href="#firewall_configuration">図 11-3</a>と同じ <code>trema.conf</code> で起動してみましょう。<code>trema run</code> で実行すると、次のようにすべての *.txt ファイルを読みこみ IP アドレス空間ごとにフローエントリを作ります。グローバル IP アドレス空間は全部で2万以上あるので、すべてのフローエントリの作成には数分かかります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/pass_delegated.rb -c pass_delegated.conf
aggregated-delegated-afrinic.txt: 713 prefixes
aggregated-delegated-apnic.txt: 3440 prefixes
aggregated-delegated-arin.txt: 11342 prefixes
aggregated-delegated-lacnic.txt: 1937 prefixes
aggregated-delegated-ripencc.txt: 7329 prefixes
0xabc: connected
0xabc: loading started
0xabc: loading finished in 241.03 seconds</pre>
</div>
</div>
<div class="paragraph">
<p>コントローラが起動したら、別ターミナルを開き <code>trema send_packets</code> コマンドでoutsideとinsideホストの間でテストパケットを送ってみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source outside --dest inside
$ ./bin/trema send_packets --source inside --dest outside</pre>
</div>
</div>
<div class="paragraph">
<p>PassDelegated コントローラはグローバルアドレス以外の外側から内側へのパケットを遮断します。ホストoutsideはプライベートアドレスを持つので、PassDelegatedコントローラはパケットを落とします。ホストinsideもプライベートアドレスを持ちますが、insideからoutsideへのパケットは通します。<code>trema show_stats</code> コマンドで outside、inside、そして inspector の受信パケット数をチェックしてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema show_stats outside
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats inside
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats inspector
Packets received:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに、outside から inside へのパケットは遮断し、逆向きの inside から outside へのパケットは通しています。そして、outside からの遮断されたパケットは inspector に届いています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_passdelegatedのソースコード">11.5. PassDelegatedのソースコード</h3>
<div class="paragraph">
<p>PassDelegated のソースコードは BlockRFC1918 と似た構造ですが、使うフローエントリの種類が増えています。次の 4 種類のフローエントリを使います。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">フィルタ用 (優先度: 64000)</dt>
<dd>
<p>外側ネットワークのグローバル IP アドレスからのパケットを内側ホストに転送するフローエントリです。3 万以上のエントリがあるため、セットアップは数分かかります。</p>
</dd>
<dt class="hdlist1">バイパス用 (優先度: 65000)</dt>
<dd>
<p>フィルタ用フローエントリをセットアップしている間の数分間だけ有効なエントリです。外側⇔内側のすべてのパケットを通します。</p>
</dd>
<dt class="hdlist1">ドロップ用 (優先度: 1000)</dt>
<dd>
<p>外側ネットワークのグローバル IP アドレス以外からのパケットを inspector ホストに転送するフローエントリです。</p>
</dd>
<dt class="hdlist1">IPv4以外用 (優先度: 900)</dt>
<dd>
<p>外側ネットワークからの IPv4 以外のパケットを内側ネットワークへ転送するフローエントリです。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">lib/pass_delegated.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># A sample transparent firewall</span>
<span class="keyword">class</span> <span class="class">PassDelegated</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  <span class="constant">PORT</span> = {
    <span class="key">outside</span>: <span class="integer">1</span>,
    <span class="key">inside</span>: <span class="integer">2</span>,
    <span class="key">inspect</span>: <span class="integer">3</span>
  }

  <span class="constant">PRIORITY</span> = {
    <span class="key">bypass</span>: <span class="integer">65_000</span>,
    <span class="key">prefix</span>: <span class="integer">64_000</span>,
    <span class="key">inspect</span>: <span class="integer">1000</span>,
    <span class="key">non_ipv4</span>: <span class="integer">900</span>
  }

  <span class="constant">PREFIX_FILES</span> = <span class="string"><span class="delimiter">%w(</span><span class="content">afrinic apnic arin lacnic ripencc</span><span class="delimiter">)</span></span>.map <span class="keyword">do</span> |each|
    <span class="string"><span class="delimiter">&quot;</span><span class="content">aggregated-delegated-</span><span class="inline"><span class="inline-delimiter">#{</span>each<span class="inline-delimiter">}</span></span><span class="content">.txt</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">start</span>(_args)
    <span class="instance-variable">@prefixes</span> = <span class="constant">PREFIX_FILES</span>.reduce([]) <span class="keyword">do</span> |result, each|
      data = <span class="constant">IO</span>.readlines(<span class="constant">File</span>.join __dir__, <span class="string"><span class="delimiter">'</span><span class="content">..</span><span class="delimiter">'</span></span>, each)
      logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>each<span class="inline-delimiter">}</span></span><span class="content">: </span><span class="inline"><span class="inline-delimiter">#{</span>data.size<span class="inline-delimiter">}</span></span><span class="content"> prefixes</span><span class="delimiter">&quot;</span></span>
      result + data
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
    <span class="keyword">if</span> <span class="instance-variable">@dpid</span>
      logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content">: ignored</span><span class="delimiter">&quot;</span></span>
      <span class="keyword">return</span>
    <span class="keyword">end</span>
    <span class="instance-variable">@dpid</span> = dpid
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: connected</span><span class="delimiter">&quot;</span></span>
    start_loading
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">switch_disconnected</span>(dpid)
    <span class="keyword">return</span> <span class="keyword">if</span> <span class="instance-variable">@dpid</span> != dpid
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: disconnected</span><span class="delimiter">&quot;</span></span>
    <span class="instance-variable">@dpid</span> = <span class="predefined-constant">nil</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">barrier_reply</span>(dpid, _message)
    <span class="keyword">return</span> <span class="keyword">if</span> dpid != <span class="instance-variable">@dpid</span>
    finish_loading
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">start_loading</span>
    <span class="instance-variable">@loading_started</span> = <span class="constant">Time</span>.now
    install_preamble_and_bypass
    install_prefixes
    install_postamble
    send_message <span class="instance-variable">@dpid</span>, <span class="constant">Barrier</span>::<span class="constant">Request</span>.new
  <span class="keyword">end</span>

  <span class="comment"># All flows in place, safe to remove bypass.</span>
  <span class="keyword">def</span> <span class="function">finish_loading</span>
    send_flow_mod_delete(<span class="instance-variable">@dpid</span>,
                         <span class="key">strict</span>: <span class="predefined-constant">true</span>,
                         <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:bypass</span>],
                         <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]))
    logger.info(format(<span class="string"><span class="delimiter">'</span><span class="content">%s: loading finished in %.2f second(s)</span><span class="delimiter">'</span></span>,
                       <span class="instance-variable">@dpid</span>.to_hex, <span class="constant">Time</span>.now - <span class="instance-variable">@loading_started</span>))
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">install_preamble_and_bypass</span>
    send_flow_mod_add(<span class="instance-variable">@dpid</span>,
                      <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:bypass</span>],
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:inside</span>]),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:outside</span>]))
    send_flow_mod_add(<span class="instance-variable">@dpid</span>,
                      <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:bypass</span>],
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">install_prefixes</span>
    logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: loading started</span><span class="delimiter">&quot;</span></span>
    <span class="instance-variable">@prefixes</span>.each <span class="keyword">do</span> |each|
      send_flow_mod_add(<span class="instance-variable">@dpid</span>,
                        <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:prefix</span>],
                        <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>],
                                         <span class="key">ether_type</span>: <span class="integer">0x0800</span>,
                                         <span class="key">source_ip_address</span>: <span class="constant">IPv4Address</span>.new(each)),
                        <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="comment"># Deny any other IPv4 and permit non-IPv4 traffic.</span>
  <span class="keyword">def</span> <span class="function">install_postamble</span>
    send_flow_mod_add(<span class="instance-variable">@dpid</span>,
                      <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:inspect</span>],
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>], <span class="key">ether_type</span>: <span class="integer">0x0800</span>),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inspect</span>]))
    send_flow_mod_add(<span class="instance-variable">@dpid</span>,
                      <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:non_ipv4</span>],
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>BlockRFC1918 と同じく、各種フローエントリの設定は <code>start_loading</code> メソッドから始まります。</p>
</div>
<div class="listingblock">
<div class="title">PassDelegated#start_loading (lib/pass_delegated.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start_loading</span>
  <span class="instance-variable">@loading_started</span> = <span class="constant">Time</span>.now
  install_preamble_and_bypass
  install_prefixes
  install_postamble
  send_message <span class="instance-variable">@dpid</span>, <span class="constant">Barrier</span>::<span class="constant">Request</span>.new
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最初に呼び出す <code>install_preamble_and_bypass</code> メソッドは、外側⇔内側のすべてのパケットを通すバイパス用フローエントリを追加します。優先度を他のフローエントリよりも大きくしておくことで、フィルタリング用フローエントリを設定している数分間はすべてのパケットがこのフローエントリにマッチします。このため、フローエントリのセットアップ中でも普通に通信できるようになります。</p>
</div>
<div class="listingblock">
<div class="title">PassDelegated#install_preamble_and_bypass (lib/pass_delegated.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">install_preamble_and_bypass</span>
  send_flow_mod_add(<span class="instance-variable">@dpid</span>, <i class="conum" data-value="1"></i><b>(1)</b>
                    <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:bypass</span>],
                    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:inside</span>]),
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:outside</span>]))
  send_flow_mod_add(<span class="instance-variable">@dpid</span>, <i class="conum" data-value="2"></i><b>(2)</b>
                    <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:bypass</span>],
                    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]),
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>内側→外側のパケットをすべて通すフローエントリを設定</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>外側→内側のパケットをすべて通すフローエントリを設定</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>バイパス用フローエントリの後、大量のフィルタ用フローエントリを設定します。PassDelegated がフィルタするのは外側→内側ネットワークだけなので、それぞれのグローバル IP アドレス空間について 1 つずつのフローエントリを作ります。</p>
</div>
<div class="listingblock">
<div class="title">PassDelegated#install_prefixes (lib/pass_delegated.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">install_prefixes</span>
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@dpid</span>.to_hex<span class="inline-delimiter">}</span></span><span class="content">: loading started</span><span class="delimiter">&quot;</span></span>
  <span class="instance-variable">@prefixes</span>.each <span class="keyword">do</span> |each|
    send_flow_mod_add(<span class="instance-variable">@dpid</span>,
                      <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:prefix</span>],
                      <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>],
                                       <span class="key">ether_type</span>: <span class="integer">0x0800</span>,
                                       <span class="key">source_ip_address</span>: <span class="constant">IPv4Address</span>.new(each)),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>続く <code>install_postamble</code> メソッドでは、ドロップ用と IPv4 以外用の 2 種類のフローエントリを設定します。ドロップ用フローエントリは、外側ネットワークのグローバル IP アドレス以外からのパケットを inspector ホストに転送します。IPv4 以外用フローエントリは、外側ネットワークからの IPv4 以外のパケットをすべて内側ネットワークへ転送します。</p>
</div>
<div class="listingblock">
<div class="title">PassDelegated#install_postamble (lib/pass_delegated.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Deny any other IPv4 and permit non-IPv4 traffic.</span>
<span class="keyword">def</span> <span class="function">install_postamble</span>
  send_flow_mod_add(<span class="instance-variable">@dpid</span>, <i class="conum" data-value="1"></i><b>(1)</b>
                    <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:inspect</span>],
                    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>], <span class="key">ether_type</span>: <span class="integer">0x0800</span>),
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inspect</span>]))
  send_flow_mod_add(<span class="instance-variable">@dpid</span>, <i class="conum" data-value="2"></i><b>(2)</b>
                    <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:non_ipv4</span>],
                    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]),
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="constant">PORT</span>[<span class="symbol">:inside</span>]))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ドロップ用フローエントリの設定</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>IPv4 以外用フローエントリの設定</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後に、すべてのフローエントリが実際にスイッチへ反映されるのをバリアで待った後、外側→内側へのバイパス用フローエントリを削除します。これによって、外側→内側へのグローバルアドレスを持たないホストからのパケットだけをフィルタリング用エントリで遮断できます。</p>
</div>
<div class="listingblock">
<div class="title">PassDelegated#install_postamble (lib/pass_delegated.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">barrier_reply</span>(dpid, _message)
  <span class="keyword">return</span> <span class="keyword">if</span> dpid != <span class="instance-variable">@dpid</span>
  finish_loading
<span class="keyword">end</span>

private

<span class="comment"># All flows in place, safe to remove bypass.</span>
<span class="keyword">def</span> <span class="function">finish_loading</span>
  send_flow_mod_delete(<span class="instance-variable">@dpid</span>,
                       <span class="key">strict</span>: <span class="predefined-constant">true</span>,
                       <span class="key">priority</span>: <span class="constant">PRIORITY</span>[<span class="symbol">:bypass</span>],
                       <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">in_port</span>: <span class="constant">PORT</span>[<span class="symbol">:outside</span>]))
  logger.info(format(<span class="string"><span class="delimiter">'</span><span class="content">%s: loading finished in %.2f second(s)</span><span class="delimiter">'</span></span>,
                     <span class="instance-variable">@dpid</span>.to_hex, <span class="constant">Time</span>.now - <span class="instance-variable">@loading_started</span>))
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_11">11.6. まとめ</h3>
<div class="paragraph">
<p>ネットワーク機器のOpenFlow実装の一環として、2種類の透過型ファイアウォールを作りました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>透過型ファイアウォールはルータとホストの間にはさむだけで使え、各ホストのネットワーク設定を変更しなくてよい</p>
</li>
<li>
<p>Flow Mod がスイッチに反映されたことを保証するには <code>Barrier::Request</code> メッセージを使う</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>続く章では、インターネットを構成する重要なネットワーク機器であるルータをOpenFlowで作ります。今までに学んできたOpenFlowやRubyプログラミングの知識を総動員しましょう。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="router_part1">12. ルータ (前編)</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>今まで学んだ知識を総動員して、ラーニングスイッチよりも高度なルータの実装に挑戦しましょう。まずは、スイッチとルータの違いをきちんと理解することからスタートです。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/router/map.png" alt="map">
</div>
</div>
<div class="sect2">
<h3 id="_ルータとスイッチの違い">12.1. ルータとスイッチの違い</h3>
<div class="paragraph">
<p>ルータとスイッチの一番大きな違いは、パケット転送に使う情報にあります。スイッチはパケットの転送に MAC アドレスを使う一方で、ルータは IP アドレスを使うのです。なぜ、ルータは IP アドレスを使うのでしょうか。MAC アドレスだけでパケットが届くなら、わざわざ IP アドレスを使う必要はありません。実はこれらの違いには、技術的な理由があるのです。</p>
</div>
<div class="paragraph">
<p>MAC アドレスでパケットを転送する LAN をイーサネットと呼びます。ネットワークを実装のレベルで分類すると、イーサネットはハードウェアに近いレベルのネットワークです。なぜかと言うと、イーサネットがパケットの転送に使う MAC アドレスは、ハードウェアであるネットワークカードを識別する情報だからです。この MAC アドレスは、パケットのイーサネットヘッダと呼ばれる部分に入っています。</p>
</div>
<div class="paragraph">
<p>実は、ハードウェアに近いパケット転送方式はイーサネット以外にもいくつもあります。イーサネットは、転送方式のうちのたった 1 つにすぎないのです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ADSL や光ファイバーによるインターネット接続に使う PPP (Point to Point Protocol)。身近に使われている</p>
</li>
<li>
<p>WAN で使われる ATM (Asynchronous Transfer Mode) やフレームリレー。利用は徐々に減りつつある</p>
</li>
<li>
<p>リング型のネットワークを構成する FDDI (Fiber-Distributed Data Interface)。昔は、大学などの計算機室のワークステーションをつなげるためによく使われていた</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらの異なるネットワーク同士をつなぐのが IP (インターネットプロトコル) です。インターネットはその名のとおり、ネットとネットの間 (inter) をつなぐ技術で、イーサネットやその他のネットワークの一段上に属します。ルータはインターネットプロトコルでの識別情報である IP アドレスを使って、より低いレベルのネットワーク同士をつなぐのです。</p>
</div>
</div>
<div class="sect2">
<h3 id="_イーサネットだけならルータは不要">12.2. イーサネットだけならルータは不要？</h3>
<div class="paragraph">
<p>ここで1つの疑問が出てきます。いろいろある転送方式のうち、もしもイーサネットだけを使うのであれば、ルータによる中継は不要なのでしょうか。</p>
</div>
<div class="paragraph">
<p>いいえ、ルータは必要です。もしもルータを使わずに大きなネットワークを作ろうとすると、次の問題が起こります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ブロードキャストの問題</dt>
<dd>
<p>ネットワーク上の情報の発見などのためにブロードキャストパケットを送ると、ネットワーク上のすべてのホストにこのパケットがばらまかれる。もし大きいネットワーク内でみんながブロードキャストを送ってしまうと、ネットワークがパンクしてしまう</p>
</dd>
<dt class="hdlist1">セキュリティの問題</dt>
<dd>
<p>もし全体が 1 つのネットワークでどことでも自由に通信できてしまうと、他人の家や他社のホストと簡単に接続できてしまう。こうなると、プライバシー情報や機密データを守るのが大変になる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>そこで、現実的にはイーサネットだけでネットワークを作る場合にも、家や会社の部署といった単位で小さなネットワークを作り、それらをルータでつなぐ場合が大半です。ルータがネットワーク間の門番としても働き、実際にパケットを転送するかしないかを制御することで、上の 2 つの問題を解決します。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ルータの動作">12.3. ルータの動作</h3>
<div class="paragraph">
<p>ルータの存在意義がわかったところで、一般的なイーサネットでのルータの動作を詳しく見ていきましょう。おおまかに言うと、ルータは複数のイーサネットをつなぐために、1) イーサネット間でのパケットの転送と、2) 正しく届けるのに必要なパケットの書き換え、の 2 つの仕事を行います。</p>
</div>
<div class="sect3">
<h4 id="_パケットを書き換えて転送する">12.3.1. パケットを書き換えて転送する</h4>
<div class="paragraph">
<p><a href="#router_forward_rewrite">図 12-1</a> のホスト A がホスト B にパケットを送る場合を考えます。ホスト A は、送信元 IP アドレスがホスト A、宛先 IP アドレスがホスト B の IP パケットを作ります。</p>
</div>
<div class="paragraph">
<p>このパケットをホスト B に届けるためには、ルータに中継してもらわなくてはなりません。ルータにパケットを渡すために、ホスト A は、パケット中の宛先 MAC アドレスをルータの MAC アドレスに、また送信元をホスト A の MAC アドレスにして、出力します。このときのパケットの中身は、次のようになります。</p>
</div>
<div id="router_forward_rewrite" class="imageblock">
<div class="content">
<img src="images/router/router_forward_rewrite.png" alt="router forward rewrite">
</div>
<div class="title">図 12-1: ルータはパケットを転送するために、パケットのイーサネット部分だけを書き換える</div>
</div>
<div class="paragraph">
<p>ルータは、受け取ったパケットをホスト B に届けるために、MAC アドレスの書き換えを行います。ルータは、パケットの宛先をホスト B の MAC アドレスに、送信元をルータの MAC アドレスに書き換えてから、書き換えたパケットをホスト B へと転送します。</p>
</div>
<div class="paragraph">
<p>このパケットの書き換えと転送のために必要な処理を、1 つひとつ見ていきましょう。</p>
</div>
<div class="sect4">
<h5 id="_ルータの_mac_アドレスを教える">ルータの MAC アドレスを教える</h5>
<div class="paragraph">
<p>ルータがパケットを受け取るためには、ホストはルータの MAC アドレスを知る必要があります。IPアドレスから宛先のMACアドレスの情報を知るためにはARP(Address Resolution Protocol)というプロトコルを使います。ARPにはARPリクエストとARPリプライという2種類のパケットがあります。ホスト A は、パケットを送る前にルータの MAC アドレスを ARP リクエストで調べ、これを宛先 MAC アドレスとしてパケットに指定します。ルータは ARP リクエストを受け取ると、自身の MAC アドレスを ARP リプライとして返します (<a href="#router_arp_reply">図 12-2</a>)。</p>
</div>
<div id="router_arp_reply" class="imageblock">
<div class="content">
<img src="images/router/router_arp_reply.png" alt="router arp reply">
</div>
<div class="title">図 12-2: ルータは ARP リクエストに対し自分の MAC アドレスを応える</div>
</div>
</div>
<div class="sect4">
<h5 id="_宛先ホストの_mac_アドレスを調べる">宛先ホストの MAC アドレスを調べる</h5>
<div class="paragraph">
<p>ルータがパケットを宛先ホストに送るためには、宛先ホストの MAC アドレスを調べる必要があります。そこでルータは、宛先であるホスト B の MAC アドレスを調べるための ARP リクエストをホスト B へ送ります。このとき、ルータは、ホスト B の MAC アドレスを知らないので、ARP リクエストの宛先 MAC アドレスにブロードキャストアドレス (FF:FF:FF:FF:FF:FF) を指定します。</p>
</div>
<div id="router_arp_reequest" class="imageblock">
<div class="content">
<img src="images/router/router_arp_request.png" alt="router arp request">
</div>
<div class="title">図 12-3: 宛先ホストの MAC アドレスを問い合わせる</div>
</div>
<div class="paragraph">
<p>ARP を使って調べた MAC アドレスは、再利用するためにルータ内の ARP テーブルにキャッシュしておきます。これによって、同じホストに対してパケットを繰り返し送る場合、何度も ARP リクエストを送らなくてもすみます。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_いくつものルータを経由して転送する">12.3.2. いくつものルータを経由して転送する</h4>
<div class="paragraph">
<p>ルータが複数あるネットワークでの転送は、少し複雑になります (<a href="#router_network">図 12-4</a>)。たとえば、ホスト A がホスト B にパケットを送るとします。ルータ A は受け取ったパケットを転送する必要がありますが、宛先であるホスト B はルータ A とは直接はつながっていません。そのため、ルータ A はまずルータ B にパケットを転送し、ルータ B がそのパケットをホスト B へと転送します。</p>
</div>
<div id="router_network" class="imageblock">
<div class="content">
<img src="images/router/router_network.png" alt="router network">
</div>
<div class="title">図 12-4: ルータが複数あるネットワークでの転送</div>
</div>
<div class="paragraph">
<p>ルータ A の次の転送先となるルータは、パケットの宛先ごとに異なります。たとえばホスト A からホスト C へパケットを送る場合には、ルータ A はそのパケットをルータ C へと転送します。</p>
</div>
<div class="paragraph">
<p>次の転送先へと正しくパケットを送るために、各ルータは、宛先と次の転送先の対応を記録したルーティングテーブルを持っています。たとえば、ルータ A のルーティングテーブルは、<a href="#router_network">図 12-4</a> に示すようになります。</p>
</div>
<div class="paragraph">
<p>ここまでで、ルータの基本動作の説明はおしまいです。それでは、基本的なルータの機能を実装した、シンプルルータのソースコードを読んでいきましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ソースコード解説_5">12.4. ソースコード解説</h3>
<div class="paragraph">
<p>シンプルルータ (<code>SimpleRouter</code>) のソースコードは、いくつのファイルからなります。紙面の都合上、以下ではメインのソースコード (<code>lib/simple_router.rb</code>) を中心に説明します。ソースコードは GitHub の <code>trema/simple_router</code> リポジトリ (<a href="https://github.com/trema/simple_router" class="bare">https://github.com/trema/simple_router</a>) からダウンロードできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/simple_router.git
$ cd simple_router
$ bundle install --binstubs</pre>
</div>
</div>
<div class="sect3">
<h4 id="_packet_in_ハンドラ_2">12.4.1. Packet In ハンドラ</h4>
<div class="paragraph">
<p>シンプルルータの主な動作は Packet In ハンドラから始まります。ハンドラ <code>packet_in</code> の中身は、次のようになっています。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#packet_in (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(dpid, packet_in)
  <span class="keyword">return</span> <span class="keyword">unless</span> sent_to_router?(packet_in)

  <span class="keyword">case</span> packet_in.data
  <span class="keyword">when</span> <span class="constant">Arp</span>::<span class="constant">Request</span>
    packet_in_arp_request dpid, packet_in.in_port, packet_in.data
  <span class="keyword">when</span> <span class="constant">Arp</span>::<span class="constant">Reply</span>
    packet_in_arp_reply dpid, packet_in
  <span class="keyword">when</span> <span class="constant">Parser</span>::<span class="constant">IPv4Packet</span>
    packet_in_ipv4 dpid, packet_in
  <span class="keyword">else</span>
    logger.debug <span class="string"><span class="delimiter">&quot;</span><span class="content">Dropping unsupported packet type: </span><span class="inline"><span class="inline-delimiter">#{</span>packet_in.data.inspect<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_自分宛のパケットかを判定する">自分宛のパケットかを判定する</h5>
<div class="paragraph">
<p>イーサネットにはルータ以外のホストがつながっている可能性があります。そこで Packet In メッセージが上がってきたときには、まずそのパケットが自分宛かどうかを判断します (<code>sent_to_router?</code> メソッド)。もし自分宛でない場合にはパケットを破棄します。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#sent_to_router? (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">sent_to_router?</span>(packet_in)
  <span class="keyword">return</span> <span class="predefined-constant">true</span> <span class="keyword">if</span> packet_in.destination_mac.broadcast?
  interface = <span class="constant">Interface</span>.find_by(<span class="key">port_number</span>: packet_in.in_port)
  interface &amp;&amp; interface.mac_address == packet_in.destination_mac
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>sent_to_router?</code> メソッドはパケットの宛先 MAC アドレス (<code>packet_in.destination_mac</code>) をチェックします。宛先 MAC アドレスがブロードキャストである場合、もしくは受信ポート (<code>packet_in.in_port</code>) に割り当てられている MAC アドレス (<code>interface.mac_address</code>) と同じである場合、自分宛と判断します。</p>
</div>
</div>
<div class="sect4">
<h5 id="_パケットの種類によって処理を切り替え">パケットの種類によって処理を切り替え</h5>
<div class="paragraph">
<p>自分宛のパケットだとわかると、次にパケットの種類を判別します。シンプルルータが処理するパケットは、ARP のリクエストとリプライ、および IPv4 パケットの 3 種類です。<code>PacketIn#data</code> メソッドはパケットの種類に応じたオブジェクトを返すので、この返り値に応じてハンドラメソッドを呼び出します。</p>
</div>
</div>
<div class="sect4">
<h5 id="_arp_リクエストのハンドル">ARP リクエストのハンドル</h5>
<div class="paragraph">
<p>ARP リクエストパケットを受信すると <code>packet_in_arp_request</code> メソッドを呼びます。ここでは、ARP リプライメッセージを作って Packet Out で ARP リクエストが届いたポートに出力します。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#packet_in_arp_request (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_arp_request</span>(dpid, in_port, arp_request)
  interface =
    <span class="constant">Interface</span>.find_by(<span class="key">port_number</span>: in_port,
                      <span class="key">ip_address</span>: arp_request.target_protocol_address)
  <span class="keyword">return</span> <span class="keyword">unless</span> interface
  send_packet_out(
    dpid,
    <span class="key">raw_data</span>: <span class="constant">Arp</span>::<span class="constant">Reply</span>.new(
      <span class="key">destination_mac</span>: arp_request.source_mac,
      <span class="key">source_mac</span>: interface.mac_address,
      <span class="key">sender_protocol_address</span>: arp_request.target_protocol_address,
      <span class="key">target_protocol_address</span>: arp_request.sender_protocol_address
    ).to_binary,
    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(in_port))
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_arp_リプライのハンドル">ARP リプライのハンドル</h5>
<div class="paragraph">
<p>ARP リプライパケットを受信すると、ARP テーブル (<code>@arp_table</code>) に MAC アドレスを記録します。ここでは <code>PacketIn#sender_protocol</code> メソッドを使って ARP パケット中の送信元 IP アドレスを取り出しています。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#packet_in_arp_reply (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_arp_reply</span>(dpid, packet_in)
  <span class="instance-variable">@arp_table</span>.update(packet_in.in_port,
                    packet_in.sender_protocol_address,
                    packet_in.source_mac)
  flush_unsent_packets(dpid,
                       packet_in.data,
                       <span class="constant">Interface</span>.find_by(<span class="key">port_number</span>: packet_in.in_port))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>そして、<code>flush_unsent_packets</code> メソッドで宛先 MAC アドレスが解決していないパケットを送ります。この処理については後述します。</p>
</div>
</div>
<div class="sect4">
<h5 id="_ipv4_パケットのハンドル">IPv4 パケットのハンドル</h5>
<div class="paragraph">
<p>IPv4 パケットを受信すると、<code>packet_in_ipv4</code> メソッドを呼びます。ルータに届く IPv4 パケットには次の 3 種類があり、それぞれで処理が異なります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>パケットの転送が必要な場合</p>
</li>
<li>
<p>宛先 IP アドレスが自分宛だった場合</p>
</li>
<li>
<p>それ以外だった場合 (パケットを破棄)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#packet_in_ipv4 (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_ipv4</span>(dpid, packet_in)
  <span class="keyword">if</span> forward?(packet_in)
    forward(dpid, packet_in)
  <span class="keyword">elsif</span> packet_in.ip_protocol == <span class="integer">1</span>
    icmp = <span class="constant">Icmp</span>.read(packet_in.raw_data)
    packet_in_icmpv4_echo_request(dpid, packet_in) <span class="keyword">if</span> icmp.icmp_type == <span class="integer">8</span>
  <span class="keyword">else</span>
    logger.debug <span class="string"><span class="delimiter">&quot;</span><span class="content">Dropping unsupported IPv4 packet: </span><span class="inline"><span class="inline-delimiter">#{</span>packet_in.data<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>パケットを転送するかどうかの判定は <code>forward?</code> メソッドです。転送が必要な場合とは、次のようにパケットの宛先 IPv4 アドレスがルータのインタフェースに割り当てた IPv4 アドレスと異なる場合です。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#forward? (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">forward?</span>(packet_in)
  !<span class="constant">Interface</span>.find_by(<span class="key">ip_address</span>: packet_in.destination_ip_address)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>パケットの宛先 IP アドレスがルータである場合、ルータ自身が応答します。シンプルルータでは、ICMP Echo リクエスト (ping) に応答する機能だけ実装しています。<code>packet_in_icmpv4_echo_request</code> メソッドは次のように ICMP Echo リクエストに応答します。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#packet_in_icmpv4_echo_request (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_icmpv4_echo_request</span>(dpid, packet_in)
  icmp_request = <span class="constant">Icmp</span>.read(packet_in.raw_data)
  <span class="keyword">if</span> <span class="instance-variable">@arp_table</span>.lookup(packet_in.source_ip_address)
    send_packet_out(dpid,
                    <span class="key">raw_data</span>: create_icmp_reply(icmp_request).to_binary,
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(packet_in.in_port))
  <span class="keyword">else</span>
    send_later(dpid,
               <span class="key">interface</span>: <span class="constant">Interface</span>.find_by(<span class="key">port_number</span>: packet_in.in_port),
               <span class="key">destination_ip</span>: packet_in.source_ip_address,
               <span class="key">data</span>: create_icmp_reply(icmp_request))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>まず送信元 IP アドレス (<code>packet_in.source_ip_address</code>) に対応する MAC アドレスを ARP テーブルから調べます。MAC アドレスをキャッシュしている場合には、<code>create_icmp_reply</code> で応答メッセージを作り、Packet Out で出力します。MAC アドレスをキャッシュしていない場合には、<code>send_later</code> メソッドで ARP が解決したときに後で転送します。これについても詳細は後述します。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_パケットを書き換えて転送する_2">12.4.2. パケットを書き換えて転送する</h4>
<div class="paragraph">
<p>ルータの動作の核心、パケットを書き換えて転送する部分です。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#forward (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">forward</span>(dpid, packet_in)
  next_hop = resolve_next_hop(packet_in.destination_ip_address)

  interface = <span class="constant">Interface</span>.find_by_prefix(next_hop)
  <span class="keyword">return</span> <span class="keyword">if</span> !interface || (interface.port_number == packet_in.in_port)

  arp_entry = <span class="instance-variable">@arp_table</span>.lookup(next_hop)
  <span class="keyword">if</span> arp_entry
    actions = [<span class="constant">SetSourceMacAddress</span>.new(interface.mac_address),
               <span class="constant">SetDestinationMacAddress</span>.new(arp_entry.mac_address),
               <span class="constant">SendOutPort</span>.new(interface.port_number)]
    send_flow_mod_add(dpid,
                      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in), <span class="key">actions</span>: actions)
    send_packet_out(dpid, <span class="key">raw_data</span>: packet_in.raw_data, <span class="key">actions</span>: actions)
  <span class="keyword">else</span>
    send_later(dpid,
               <span class="key">interface</span>: interface,
               <span class="key">destination_ip</span>: next_hop,
               <span class="key">data</span>: packet_in.data)
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>forward</code> メソッドは、次の 5 つの処理を行います。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ルーティングテーブルを参照し、次の転送先を決める (<code>resolve_next_hop</code>)</p>
</li>
<li>
<p>次の転送先に送るための、出力インタフェースを決める (<code>Interface.find_by_prefix</code>)</p>
</li>
<li>
<p>インタフェースが見つかった場合、ARP アドレスから宛先 MAC アドレスを探す (<code>@arp_table.lookup</code>)</p>
</li>
<li>
<p>MAC アドレスが見つかった場合、転送用のフローエンントリを書き込み、受信パケットを Packet Out する</p>
</li>
<li>
<p>MAC アドレスが見つからなかった場合、<code>send_later</code> メソッドで後で転送する</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>このうち重要なのは 1 と 4 の処理です。1 で次の転送先を決める <code>resolve_next_hop</code> メソッドの詳細については次章で見ていきます。ここでは 4 の処理を詳しく見ていきましょう。</p>
</div>
<div class="sect4">
<h5 id="_パケットの書き換えと転送_flow_mod_と_packet_out">パケットの書き換えと転送 (Flow Mod と Packet Out)</h5>
<div class="paragraph">
<p>ARP テーブルから宛先の MAC アドレスがわかると、パケットを書き換えて宛先へ出力するとともに、同様のパケットをスイッチ側で転送するためのフローエントリを書き込みます。<a href="#forward">図 12-1</a> で説明したように、ルータによるパケットの転送では MAC アドレスを書き換えます。<code>forward</code> メソッド内の変数 <code>actions</code> はこのためのアクションリストで、送信元と宛先 MAC アドレスの書き換え、そして該当するポートからの出力というアクションの配列です。このアクションは Flow Mod と Packet Out メッセージの送信に使います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">actions = [<span class="constant">SetSourceMacAddress</span>.new(interface.mac_address),
           <span class="constant">SetDestinationMacAddress</span>.new(arp_entry.mac_address),
           <span class="constant">SendOutPort</span>.new(interface.port_number)]
send_flow_mod_add(dpid,
                  <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in), <span class="key">actions</span>: actions)
send_packet_out(dpid, <span class="key">raw_data</span>: packet_in.raw_data, <span class="key">actions</span>: actions)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_arp_の解決後にパケットを転送する">12.4.3. ARP の解決後にパケットを転送する</h4>
<div class="paragraph">
<p>ARP が未解決のパケットは転送できないため、解決するまで待つ必要があります。この「ARP 解決後に送る」という処理を行うのが、<code>send_later</code> メソッドです。たとえば ICMP Echo リプライの宛先 MAC アドレスが ARP テーブルからすぐわからない場合、次のように <code>send_later</code> メソッドを呼び出していました。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#packet_in_icmpv4_echo_request (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_icmpv4_echo_request</span>(dpid, packet_in)
  icmp_request = <span class="constant">Icmp</span>.read(packet_in.raw_data)
  <span class="keyword">if</span> <span class="instance-variable">@arp_table</span>.lookup(packet_in.source_ip_address)
    send_packet_out(dpid,
                    <span class="key">raw_data</span>: create_icmp_reply(icmp_request).to_binary,
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(packet_in.in_port))
  <span class="keyword">else</span>
    send_later(dpid,
               <span class="key">interface</span>: <span class="constant">Interface</span>.find_by(<span class="key">port_number</span>: packet_in.in_port),
               <span class="key">destination_ip</span>: packet_in.source_ip_address,
               <span class="key">data</span>: create_icmp_reply(icmp_request))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>send_later</code> メソッドは <code>data:</code> で渡したパケットデータを ARP 解決後に自動的に転送します。転送に使うルータのインタフェースは <code>interface:</code> オプション、また送信先 IP アドレスは <code>destination_ip:</code> オプションでそれぞれ指定します。</p>
</div>
<div class="paragraph">
<p><code>send_later</code> メソッドでは、ARP が未解決なパケットを宛先 IP アドレスごとにキュー (<code>queue</code>) に入れます。キューへの追加後に ARP リクエストを送ることで宛先の MAC アドレスを解決します。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#send_later (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">send_later</span>(dpid, options)
  destination_ip = options.fetch(<span class="symbol">:destination_ip</span>)
  <span class="instance-variable">@unresolved_packet_queue</span>[destination_ip] += [options.fetch(<span class="symbol">:data</span>)]
  send_arp_request(dpid, destination_ip, options.fetch(<span class="symbol">:interface</span>))
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>キューにためたパケットを転送するのは ARP リプライが Packet In したタイミングです。<code>packet_in_arp_reply</code> の最後に呼び出している <code>flush_unsent_packets</code> がこの処理を行います。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#flush_unsent_packets (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">flush_unsent_packets</span>(dpid, arp_reply, interface)
  destination_ip = arp_reply.sender_protocol_address
  <span class="instance-variable">@unresolved_packet_queue</span>[destination_ip].each <span class="keyword">do</span> |each|
    rewrite_mac =
      [<span class="constant">SetDestinationMacAddress</span>.new(arp_reply.sender_hardware_address),
       <span class="constant">SetSourceMacAddress</span>.new(interface.mac_address),
       <span class="constant">SendOutPort</span>.new(interface.port_number)]
    send_packet_out(dpid, <span class="key">raw_data</span>: each.to_binary_s, <span class="key">actions</span>: rewrite_mac)
  <span class="keyword">end</span>
  <span class="instance-variable">@unresolved_packet_queue</span>[destination_ip] = []
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは MAC アドレスが解決したパケットそれぞれに対して、送信元と宛先 MAC アドレスを書き換えるアクションを指定し Packet Out しています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_12">12.5. まとめ</h3>
<div class="paragraph">
<p>従来のネットワーク機器をソフトウェアで実装したシンプルなルータの仕組みを学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ルータはイーサネットよりも一段上の IP レベルでパケットを転送する。異なるイーサネット間でパケットを中継するために、ルータはパケットの MAC アドレスを書き換える</p>
</li>
<li>
<p>宛先ホストの MAC アドレスを調べるために、ルータは ARP エリクエストを送り結果を ARP テーブルにキャッシュする。また、ルータ経由でパケットを送るホストのために、ルータは ARP リクエストに応える必要がある</p>
</li>
<li>
<p>いくつものルータを経由してパケットを転送するために、ルータはルーティングテーブルを使って次の転送先を決める</p>
</li>
<li>
<p>Packet In したパケットの判別や ARP、そして ICMP 等の処理を行うためのヘルパメソッドを、Trema はたくさん提供している</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>続く<a href="#router_part2">13 章</a>では、ルータの動作にとって書かせないルーティングテーブルについて詳しく見たあと、いよいよこのルータを実行してみます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="router_part2">13. ルータ (後編)</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>ルータが持つ重要な機能であるルーティングテーブルの詳細を見ていきましょう。ルータは実に巧妙な仕組みで転送先の情報を管理します。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/router/map.png" alt="map">
</div>
</div>
<div class="sect2">
<h3 id="_宛先ホストをまとめる">13.1. 宛先ホストをまとめる</h3>
<div class="paragraph">
<p>ルータが管理するルーティングテーブルは、宛先ホストが増えるごとに大きくなります。前編の説明では、ルータは宛先ホスト1つごとにルーティングテーブルのエントリを管理していました。しかしこれでは、たとえばインターネットにホストが加わるごとに、インターネット上のルータはルーティングテーブルを更新する必要があります。しかも、インターネット上のホスト数は直線的に増え続け、2016年現在では10億台を超えています。そうなると、宛先ホストごとにエントリを管理する方法は非現実的です。</p>
</div>
<div class="paragraph">
<p>これを解決するために、ルータは同じイーサネット上にあるホストを1つのグループとしてまとめます。そして、ルーティングテーブルの宛先として、ホストではなくこのグループを指定することで、エントリ数を圧縮します。このとき、グループ情報として使うのがネットワークアドレスとネットマスク長です。</p>
</div>
<div id="router_network2" class="imageblock">
<div class="content">
<img src="images/router/router_network2.png" alt="router network2">
</div>
<div class="title">図 13-1: 同じイーサネット上にあるホストを一つの宛先にまとめる</div>
</div>
<div class="paragraph">
<p>宛先ホストのグループ化は次のように行います。たとえば、<a href="#router_network2">図13-1</a>の右側のネットワークは、ネットワークアドレスが192.168.1.0でネットマスク長が24です(これを192.168.1.0/24と表現します)。このネットワーク中にあるホストX,Y,Zには、ネットワークアドレスと上位24ビットが同じとなるように、つまりIPアドレスが192.168.1で始まるようにします。こうすれば、ホストX,Y,Zは同じ1つのグループ192.168.1.0/24に属するとみなせます。</p>
</div>
<div class="paragraph">
<p>このようにアドレスを振ることで、ルータAのルーティングテーブルは、<a href="#router_network2">図13-1</a>のようにシンプルに書けます。ホストX,Y,Z宛てのパケットを192.168.1.0/24グループ宛てと表現することで、エントリを1つにまとめられるのです。</p>
</div>
<div class="paragraph">
<p>このとき、ホストX(192.168.1.1)宛のパケットを受け取ったルータAは次のように動作します。ルーティングテーブルのエントリ192.168.1.0/24と、パケットの宛先192.168.1.1との上位24ビットを比較すると一致します。そこで、ルーティングテーブルから次の転送先はルータBだとわかります。ホストY,Z宛も同様に処理できるので、このエントリ1つでホスト3台分の宛先をカバーできます。</p>
</div>
<div class="sect3">
<h4 id="_宛先ホストがルータと直接つながっているかを調べる">13.1.1. 宛先ホストがルータと直接つながっているかを調べる</h4>
<div class="paragraph">
<p><a href="#router_network2">図13-1</a> では、ルータが宛先ホストに直接接続していない場合について説明しましたが、つながっている/いないはどのように判断するのでしょうか？</p>
</div>
<div class="paragraph">
<p>ルータは、その判断のために、自身のインタフェースに割り当てられた IP アドレスを使います。インタフェースに割り当てる IP アドレスには、ネットワーク中のホストとネットワークアドレスが同じ IP アドレスを用います。<a href="#router_address">図13-2</a> で、ルータ B のインタフェースには、ホスト X, Y, Z と同じネットワークアドレスになるよう、例えばアドレス 192.168.1.254 を割り当てます。</p>
</div>
<div id="router_address" class="imageblock">
<div class="content">
<img src="images/router/router_address.png" alt="router address">
</div>
<div class="title">図 13-2: ルータのインタフェースには、ネットワーク内のホストとネットワークアドレスが同じとなるように IP アドレスを割り当てる</div>
</div>
<div class="paragraph">
<p>ここで <a href="#router_address">図13-2</a> のルータ B が、ホスト X (192.168.1.1) 宛のパケットを受け取った場合について考えます。ルータ B は、パケットの宛先アドレスを参照し、ネットワークアドレスが同じインタフェースを探します。この例では、192.168.1.254 というアドレスがついたインタフェースが見つかります。あとは、このインタフェースを通じて、ARP リクエストによる MAC アドレス問い合わせを行い、ホスト X 宛にパケットを出力します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ネットワーク宛てのエントリをまとめる">13.2. ネットワーク宛てのエントリをまとめる</h3>
<div class="paragraph">
<p>複数のホスト宛てエントリをまとめて出来たエントリは、さらにまとめられる場合もあります。</p>
</div>
<div id="aggregation" class="imageblock">
<div class="content">
<img src="images/router/aggregation.png" alt="aggregation">
</div>
<div class="title">図 13-3: 複数のネットワークへのルーティング情報をまとめる</div>
</div>
<div class="paragraph">
<p>例として、<a href="#aggregation">図 13-3</a>の3つのネットワークに接続するルータBを考えてみましょう。これら3つのネットワークアドレスは、上位16ビットが172.16.0.0で共通です。ここでルータAから見ると、この3つのネットワークへの次の転送先は、いずれもルータBです。そのため、これら3つのネットワークへのルーティング情報は、172.16.0.0/16宛として1つにまとめられます。</p>
</div>
<div class="sect3">
<h4 id="_1つの宛先に複数のエントリがマッチする場合">13.2.1. 1つの宛先に複数のエントリがマッチする場合</h4>
<div class="paragraph">
<p>パケットの宛先 IP アドレスに複数のエントリが該当する場合はどうなるでしょうか？<a href="#longest_match">図13-4</a> のルータ A がホスト X (172.16.3.1) にパケットを送る場合について考えてみましょう。ルータ A が持つルーティングテーブルは、ルータ B につながる 3 つのネットワーク宛のエントリはまとめることで、<a href="#longest_match">図13-4</a>のように 2 つのエントリにできます。しかし、このようにまとめてしまうと、宛先 172.16.3.1 のパケットは、どちらのエントリにもマッチしてしまいます。ルータは、どちらか正しいエントリを選択しなければいけません。</p>
</div>
<div id="longest_match" class="imageblock">
<div class="content">
<img src="images/router/longest_match.png" alt="longest match">
</div>
<div class="title">図 13-4: マスク長が一番長いエントリを選択する</div>
</div>
<div class="paragraph">
<p>複数のエントリにマッチする場合には、ネットマスク長が一番長いエントリを選択するというルールがあります。これをロンゲストマッチと呼びます。ロンゲストマッチにより、ルータAは、ホストX宛のパケットをルータCへと転送し、その結果ホストXへとパケットが届きます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_すべての宛先にマッチするデフォルトルート">13.2.2. すべての宛先にマッチするデフォルトルート</h4>
<div class="paragraph">
<p>すべての宛先をまとめたルーティング情報をデフォルトルートと呼び、その宛先を 0.0.0.0/0 と表します。ネットマスク長は、ルーティング情報をまとめるとき、ネットワークアドレスの共通部分の長さを表していました。デフォルトルートでは、まとめられた宛先には共通部分が全くないため、ネットマスク長は 0 となります。</p>
</div>
<div id="default_route" class="imageblock">
<div class="content">
<img src="images/router/default_route.png" alt="default route">
</div>
<div class="title">図 13-5: 0.0.0.0/0 は、すべての宛先にマッチする</div>
</div>
<div class="paragraph">
<p><a href="#default_route">図13-5</a>のように、インターネットに接続するネットワークでのルーティングテーブルについて考えてみましょう。インターネット上のホスト数は膨大なので、宛先ホストをネットワーク単位にまとめたとしても、数十万エントリを扱う必要があります。しかし、<a href="#default_route">図13-5</a>のようにインターネットへの出口が1か所だけの場合、エントリをデフォルトルート1つにまとめられます。これによって、ルーティングテーブル中のエントリ数を大きく減らせます。</p>
</div>
<div class="paragraph">
<p><a href="#default_route">図13-5</a> のように、インターネットとは別にネットワーク (172.16.3.0/24) があっても、デフォルトルートを使うことに問題はありません。172.16.3.0/24 宛のパケットがルータ A に届いた場合、ルータはロンゲストマッチからルータ C へのエントリを選択します。それ以外のパケットは、デフォルトルートによってルータ B へ転送し、インターネットへと転送します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_routingtable_のソースコード">13.3. RoutingTable のソースコード</h3>
<div class="sect3">
<h4 id="_パケットを書き換えて転送する_再">13.3.1. パケットを書き換えて転送する(再)</h4>
<div class="paragraph">
<p><code>RoutingTable</code> クラスのソースコードを見る前に、パケットの書き換えと転送を行う <code>forward</code> メソッドをもう一度見ていきましょう。<a href="#router_part1">前章</a>で説明したこのメソッドが行う 5 つの処理のうち、次の転送先と出力インタフェースを決める方法を見ていきます。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#forward (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">forward</span>(dpid, packet_in)
  next_hop = resolve_next_hop(packet_in.destination_ip_address)

  interface = <span class="constant">Interface</span>.find_by_prefix(next_hop)
  <span class="keyword">return</span> <span class="keyword">if</span> !interface || (interface.port_number == packet_in.in_port)

  arp_entry = <span class="instance-variable">@arp_table</span>.lookup(next_hop)
  <span class="keyword">if</span> arp_entry
    actions = [<span class="constant">SetSourceMacAddress</span>.new(interface.mac_address),
               <span class="constant">SetDestinationMacAddress</span>.new(arp_entry.mac_address),
               <span class="constant">SendOutPort</span>.new(interface.port_number)]
    send_flow_mod_add(dpid,
                      <span class="key">match</span>: <span class="constant">ExactMatch</span>.new(packet_in), <span class="key">actions</span>: actions)
    send_packet_out(dpid, <span class="key">raw_data</span>: packet_in.raw_data, <span class="key">actions</span>: actions)
  <span class="keyword">else</span>
    send_later(dpid,
               <span class="key">interface</span>: interface,
               <span class="key">destination_ip</span>: next_hop,
               <span class="key">data</span>: packet_in.data)
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>宛先アドレス (<code>packet_in.destination_ip_address</code>) に対する次転送先の決定は、<code>resolve_next_hop</code> メソッドで行います。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#resolve_next_hop (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">resolve_next_hop</span>(destination_ip_address)
  interface = <span class="constant">Interface</span>.find_by_prefix(destination_ip_address)
  <span class="keyword">if</span> interface
    destination_ip_address
  <span class="keyword">else</span>
    <span class="instance-variable">@routing_table</span>.lookup(destination_ip_address)
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>このメソッドでは、まず宛先アドレスと同じネットワークアドレスを持つインタフェースを探します。もし見つかった場合には、次の転送先として宛先アドレスをそのまま返します。見つからなった場合には、ルーティングテーブルから次の転送先を検索します。</p>
</div>
<div class="paragraph">
<p>その後 forward メソッドへ戻り、決定した次の転送先がルータのインタフェースに接続しているかを判定します。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter#forward (lib/simple_router.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">interface = <span class="constant">Interface</span>.find_by_prefix(next_hop)
<span class="keyword">return</span> <span class="keyword">if</span> !interface || (interface.port_number == packet_in.in_port)</code></pre>
</div>
</div>
<div class="paragraph">
<p>この判定は、次の転送先と同一のネットワークアドレスを持つインタフェースがあるかどうかを調べればわかります。もし、該当するインタフェースがない場合、ルータはそのパケットを転送できないので、パケットを破棄して転送処理を終えます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ルーティングテーブル_code_routingtable_code_クラス_の実装">13.3.2. ルーティングテーブル (<code>RoutingTable</code> クラス) の実装</h4>
<div class="paragraph">
<p>次にルーティングテーブルのソースコードを見ていきます。</p>
</div>
<div class="listingblock">
<div class="title">lib/routing_table.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Routing table</span>
<span class="keyword">class</span> <span class="class">RoutingTable</span>
  include <span class="constant">Pio</span>

  <span class="constant">MAX_NETMASK_LENGTH</span> = <span class="integer">32</span>

  <span class="keyword">def</span> <span class="function">initialize</span>(route)
    <span class="instance-variable">@db</span> = <span class="constant">Array</span>.new(<span class="constant">MAX_NETMASK_LENGTH</span> + <span class="integer">1</span>) { <span class="constant">Hash</span>.new }
    route.each { |each| add(each) }
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">add</span>(options)
    netmask_length = options.fetch(<span class="symbol">:netmask_length</span>)
    prefix = <span class="constant">IPv4Address</span>.new(options.fetch(<span class="symbol">:destination</span>)).mask(netmask_length)
    <span class="instance-variable">@db</span>[netmask_length][prefix.to_i] = <span class="constant">IPv4Address</span>.new(options.fetch(<span class="symbol">:next_hop</span>))
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">lookup</span>(destination_ip_address)
    <span class="constant">MAX_NETMASK_LENGTH</span>.downto(<span class="integer">0</span>).each <span class="keyword">do</span> |each|
      prefix = destination_ip_address.mask(each)
      entry = <span class="instance-variable">@db</span>[each][prefix.to_i]
      <span class="keyword">return</span> entry <span class="keyword">if</span> entry
    <span class="keyword">end</span>
    <span class="predefined-constant">nil</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>インスタンス変数 <code>@db</code> はルーティングテーブルで、ネットマスク長ごと (0 〜 32) に経路を管理します。経路情報はネットワークアドレスをキーとし、次の転送先 IP アドレスを値とするハッシュテーブルです。</p>
</div>
<div class="paragraph">
<p>ルーティングテーブルの検索は、<code>lookup</code> メソッドで行います。このメソッドでは、宛先 <code>destination_ip_address</code> に該当する次の転送先 IP アドレスを <code>@db</code> 中から探します。ロンゲストマッチを行うために、ネットマスク長が長い順 (32…0) に <code>@db</code> から次の転送先 IP アドレスを探索します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_コンフィグ">13.3.3. コンフィグ</h4>
<div class="paragraph">
<p>ルータが動作するためには、インタフェースのアドレスとルーティングテーブルの設定が必要です。シンプルルータでは、これらの設定を <code>simple_router.conf</code> に記述します。</p>
</div>
<div class="listingblock">
<div class="title">simple_router.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="comment"># Simple router configuration</span>
<span class="keyword">module</span> <span class="class">Configuration</span>
  <span class="constant">INTERFACES</span> = [
    {
      <span class="key">port</span>: <span class="integer">1</span>,
      <span class="key">mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">01:01:01:01:01:01</span><span class="delimiter">'</span></span>,
      <span class="key">ip_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">192.168.1.1</span><span class="delimiter">'</span></span>,
      <span class="key">netmask_length</span>: <span class="integer">24</span>
    },
    {
      <span class="key">port</span>: <span class="integer">2</span>,
      <span class="key">mac_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">02:02:02:02:02:02</span><span class="delimiter">'</span></span>,
      <span class="key">ip_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">192.168.2.1</span><span class="delimiter">'</span></span>,
      <span class="key">netmask_length</span>: <span class="integer">24</span>
    }
  ]

  <span class="constant">ROUTES</span> = [
    {
      <span class="key">destination</span>: <span class="string"><span class="delimiter">'</span><span class="content">0.0.0.0</span><span class="delimiter">'</span></span>,
      <span class="key">netmask_length</span>: <span class="integer">0</span>,
      <span class="key">next_hop</span>: <span class="string"><span class="delimiter">'</span><span class="content">192.168.1.2</span><span class="delimiter">'</span></span>
    }
  ]
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>インタフェースの設定では、そのインタフェースの MAC アドレス (<code>:mac_address</code>)、IP アドレス (<code>:ip_address</code>)、ネットマスク長 (<code>:netmask_length</code>) と、このインタフェースが OpenFlow スイッチのどのポート (<code>:port</code>) に対応しているかを指定します。</p>
</div>
<div class="paragraph">
<p>ルーティングテーブルの設定では、宛先 (<code>:destination</code>)、ネットマスク長 (<code>:netmask_length</code>) と次の転送先 (<code>:next_hop</code>) を指定します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_8">13.4. 実行してみよう</h3>
<div class="paragraph">
<p>いよいよシンプルルータを動かしてみましょう。いろいろなパケットの送受信を行うために、今回は仮想ホストではなくネットワークネームスペースを使います。今まで使ってきた仮想ホストは簡単なパケット送受信機能とカウンタを備えているので、コントローラの初歩的な導通テストには便利でした。ただしコントローラに ssh や http といった通信を流したりベンチマークを計測する場合など、仮想ホストだけでは機能が不十分な場合もあります。ネットワークネームスペース機能を使えば、ping や iperf といったおなじみのツールをはじめ、任意のアプリケーションを仮想ネットワーク上で動かせます。</p>
</div>
<div id="sample_router_network" class="imageblock">
<div class="content">
<img src="images/router/sample_router_network.png" alt="sample router network">
</div>
<div class="title">図 13-6: シンプルルータを動かすための構成</div>
</div>
<div class="paragraph">
<p>たとえば<a href="#sample_router_network">図 13-6</a> のような IP アドレスとデフォルトルートを持つホスト 2 台をスイッチに接続するには、次のように設定ファイルで <code>vhost</code> の代わりに <code>netns</code> を指定することで、独立した仮想的なネットワーク環境であるネットワークネームスペースを作れます。それぞれの <code>netns</code> のルーティング情報は <code>route</code> で指定できます。</p>
</div>
<div class="listingblock">
<div class="title">trema.conf</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">vswitch(<span class="string"><span class="delimiter">'</span><span class="content">0x1</span><span class="delimiter">'</span></span>) { dpid <span class="integer">0x1</span> }
netns(<span class="string"><span class="delimiter">'</span><span class="content">host1</span><span class="delimiter">'</span></span>) {
  ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.1.2</span><span class="delimiter">'</span></span>
  netmask <span class="string"><span class="delimiter">'</span><span class="content">255.255.255.0</span><span class="delimiter">'</span></span>
  route <span class="key">net</span>: <span class="string"><span class="delimiter">'</span><span class="content">0.0.0.0</span><span class="delimiter">'</span></span>, <span class="key">gateway</span>: <span class="string"><span class="delimiter">'</span><span class="content">192.168.1.1</span><span class="delimiter">'</span></span>
}
netns(<span class="string"><span class="delimiter">'</span><span class="content">host2</span><span class="delimiter">'</span></span>) {
  ip <span class="string"><span class="delimiter">'</span><span class="content">192.168.2.2</span><span class="delimiter">'</span></span>
  netmask <span class="string"><span class="delimiter">'</span><span class="content">255.255.255.0</span><span class="delimiter">'</span></span>
  route <span class="key">net</span>: <span class="string"><span class="delimiter">'</span><span class="content">0.0.0.0</span><span class="delimiter">'</span></span>, <span class="key">gateway</span>: <span class="string"><span class="delimiter">'</span><span class="content">192.168.2.1</span><span class="delimiter">'</span></span>
}
link <span class="string"><span class="delimiter">'</span><span class="content">0x1</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host1</span><span class="delimiter">'</span></span>
link <span class="string"><span class="delimiter">'</span><span class="content">0x1</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">host2</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この設定ファイルを指定し <code>trema run</code> で <code>lib/simple_router.rb</code> を実行すれば、<a href="#sample_router_network">図 13-6</a>のネットワーク環境でシンプルルータが起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/simple-router.rb -c ./trema.conf</pre>
</div>
</div>
<div class="paragraph">
<p>ネットワークネームスペース内で任意のコマンドを起動するためには、<code>trema netns</code> コマンドを使います。たとえば、次のコマンドを実行すると host1 の環境上でシェルを起動できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema netns host1</pre>
</div>
</div>
<div class="paragraph">
<p>起動したシェル上で、ためしに host1 環境のルーティングテーブルを確認してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 host1
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 host1</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに、デフォルトゲートウェイは設定ファイル通り 192.168.1.1 となっています。このように、<code>trema netns</code> で起動したシェル上では通常のコマンドを指定した環境上で実行できます。シェルを終了するには <code>exit</code> または <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>d</kbd></span> です。</p>
</div>
<div class="sect3">
<h4 id="_ping_で動作を確認する">13.4.1. ping で動作を確認する</h4>
<div class="paragraph">
<p>最初は簡単に ping を使ってシンプルルータが正しく動作しているかを順に確認して行きましょう。まずは、シンプルルータが ping に応答するかどうかの確認です。host1 にログインし、次のようにシンプルルータの IP アドレス 192.168.1.1 に ping を打ってみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema netns host1
$ ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=128 time=47.4 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=128 time=15.0 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=128 time=15.0 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=128 time=19.3 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=128 time=14.8 ms
64 bytes from 192.168.1.1: icmp_seq=6 ttl=128 time=14.4 ms
64 bytes from 192.168.1.1: icmp_seq=7 ttl=128 time=15.1 ms
^C
--- 192.168.1.1 ping statistics ---
7 packets transmitted, 7 received, 0% packet loss, time 6008ms
rtt min/avg/max/mdev = 14.425/20.189/47.473/11.245 ms</pre>
</div>
</div>
<div class="paragraph">
<p>ちゃんと ping が返ってきました。次に、シンプルルータをまたいだ二つのホスト間で通信できることも確認してみましょう。host2 の IP アドレス 192.168.2.2 に対して、host1 から ping を送ります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ping 192.168.2.2
PING 192.168.2.2 (192.168.2.2) 56(84) bytes of data.
64 bytes from 192.168.2.2: icmp_seq=1 ttl=64 time=75.5 ms
64 bytes from 192.168.2.2: icmp_seq=2 ttl=64 time=82.3 ms
64 bytes from 192.168.2.2: icmp_seq=3 ttl=64 time=101 ms
64 bytes from 192.168.2.2: icmp_seq=4 ttl=64 time=83.3 ms
64 bytes from 192.168.2.2: icmp_seq=5 ttl=64 time=78.2 ms
64 bytes from 192.168.2.2: icmp_seq=6 ttl=64 time=76.4 ms
64 bytes from 192.168.2.2: icmp_seq=7 ttl=64 time=70.9 ms
^C
--- 192.168.2.2 ping statistics ---
7 packets transmitted, 7 received, 0% packet loss, time 6008ms
rtt min/avg/max/mdev = 70.995/81.159/101.180/9.050 ms</pre>
</div>
</div>
<div class="paragraph">
<p>この場合もちゃんと ping が返ってきています。以上より、シンプルルータのパケット転送を確認できました。</p>
</div>
</div>
<div class="sect3">
<h4 id="_iperf_で動作を確認する">13.4.2. iperf で動作を確認する</h4>
<div class="paragraph">
<p>次は iperf でネットワークスループットを計測してみましょう。まずは iperf をインストールします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo apt-get update
$ sudo apt-get install iperf</pre>
</div>
</div>
<div class="paragraph">
<p>iperf はサーバ・クライアント型のアプリケーションなので、まずは host2 上で次のように iperf のサーバを起動しておきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema netns host2
$ iperf -s --bind 192.168.2.2
------------------------------------------------------------
Server listening on TCP port 5001
Binding to local address 192.168.2.2
TCP window size: 85.3 KByte (default)
------------------------------------------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>host1 上では次のように iperf のクライアントを起動し、ベンチマークを実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema netns host1
$ iperf -c 192.168.2.2 --bind 192.168.1.2
------------------------------------------------------------
Client connecting to 192.168.2.2, TCP port 5001
Binding to local address 192.168.1.2
TCP window size: 85.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.1.2 port 5001 connected with 192.168.2.2 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-16.4 sec   256 KBytes   128 Kbits/sec</pre>
</div>
</div>
<div class="paragraph">
<p>仮想環境上なのでこの数字にはほとんど意味はありませんが、ネットワークネームスペースを使えばこのように iperf や ssh, httpd といったサーバ・クライアント型のアプリケーションも実行できます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_13">13.5. まとめ</h3>
<div class="paragraph">
<p>ルータ編のまとめとして、もっとも重要な機能であるルーティングテーブルを詳しく説明しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ルーティングテーブルの複数のエントリ(宛先がホストのIPアドレス)を1つのエントリ(宛先がネットワークアドレス)にまとめることで、エントリ数を減らせる</p>
</li>
<li>
<p>こうしてまとめられたエントリは、ネットワークアドレスの一部が同じ他のエントリとまとめることで、さらにエントリ数を減らせる</p>
</li>
<li>
<p>パケットの宛先にマッチするエントリがルーティングテーブルに複数ある場合は、ネットマスクがもっとも長いエントリを優先 (ロンゲストマッチ) する</p>
</li>
<li>
<p>ルーティングテーブルの宛先に0.0.0.0/0を指定することで、パケットがエントリにマッチしなかった場合のデフォルトの宛先、つまりデフォルトルートを設定できる</p>
</li>
<li>
<p>ネットワークネームスペースを使えば、任意のアプリケーションを使ってコントローラをテストできる</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="router13">14. ルータ (マルチプルテーブル編)</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>OpenFlow1.3 のマルチプルテーブルを使うことで、ルータの機能の大部分をフローテーブルとして実装してみましょう</p>
</div>
<div class="sect2">
<h3 id="_マルチプルテーブル版ルータのテーブル構成">14.1. マルチプルテーブル版ルータのテーブル構成</h3>
<div class="paragraph">
<p>マルチプルテーブル版ルータは<a href="#router_multiple_tables_overview">図 14-1</a>の 7 つのテーブルで動作します。Ingress テーブルに入ったパケットはその種類が ARP か IPv4 かによって 2 通りのパスを通り、Egress テーブルから出力します。</p>
</div>
<div id="router_multiple_tables_overview" class="imageblock">
<div class="content">
<img src="images/router/router_multiple_tables_overview.png" alt="router multiple tables overview">
</div>
<div class="title">図 14-1: マルチプルテーブル版ルータのテーブル構成</div>
</div>
<div class="paragraph">
<p>それぞれのテーブルの役割とフローエントリを見て行きましょう。</p>
</div>
<div class="sect3">
<h4 id="_ingress_テーブル_protocol_classifier_テーブル">14.1.1. Ingress テーブル、Protocol Classifier テーブル</h4>
<div class="paragraph">
<p>パケットは最初、テーブル ID が 0 番の Ingress テーブルに入ります (<a href="#ingress_and_protocol_classifier_table">図 14-2</a>)。</p>
</div>
<div id="ingress_and_protocol_classifier_table" class="imageblock">
<div class="content">
<img src="images/router/ingress_and_protocol_classifier_table.png" alt="ingress and protocol classifier table">
</div>
<div class="title">図 14-2: パケットは最初にテーブル ID = 0 の Ingress テーブルに入り、そのまま Protocol Classifier テーブルへ渡される</div>
</div>
<div class="paragraph">
<p>見ての通り Ingress テーブルでは何も処理をせず、パケットをそのまま Protocol Classifier テーブルへと渡します。</p>
</div>
<div class="paragraph">
<p>Protocol Classifier テーブルは、Ingress テーブルから入ったパケットをその種類によって仕分けします。パケットの仕分けにはマッチフィールドの <code>ether_type</code> を使います。これが ARP の場合には ARP Responder テーブルへ、IPv4 の場合には Routing Table テーブルへとそれぞれパケット処理を引き継ぎます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_arp_responder_テーブル">14.1.2. ARP Responder テーブル</h4>
<div class="paragraph">
<p>パケットが ARP だった場合、ARP Responder テーブルがパケットを処理します。ARP Responder テーブルは ARP パケットをタイプ別にそれぞれ次のように処理します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">ホストからルータへの ARP Reply</dt>
<dd>
<p>ホストの MAC アドレスを学習する</p>
</dd>
<dt class="hdlist1">ルータのポート宛の ARP Request</dt>
<dd>
<p>ホストの MAC アドレスを学習し、ポートの MAC アドレスを ARP Reply で返す</p>
</dd>
<dt class="hdlist1">それ以外の ARP</dt>
<dd>
<p>パケットを書き換えて適切なポートから転送する</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>ARP Responder テーブルは、前記 3 種類の処理×ポート数分のフローエントリを持ちます。たとえばポートが 2 つの場合には、<a href="#arp_responder_table">図 14-3</a>のようにフローエントリ数は全部で 6 つです。それぞれのフローエントリの具体的な働きについては後述します。</p>
</div>
<div id="arp_responder_table" class="imageblock">
<div class="content">
<img src="images/router/arp_responder_table.png" alt="arp responder table">
</div>
<div class="title">図 14-3: ARP Responder テーブルのフローエントリ例</div>
</div>
</div>
<div class="sect3">
<h4 id="_routing_table_テーブル">14.1.3. Routing Table テーブル</h4>
<div class="paragraph">
<p>パケットが IPv4 だった場合、Routing Table, Interface Lookup そして ARP Table Lookup の 3 つのテーブルによってパケットを処理します。</p>
</div>
<div class="paragraph">
<p>パケットが最初に入る Routing Table テーブルは、パケットのネクストホップをロンゲストマッチで決定します。そして、決定したネクストホップをレジスタ <code>reg0</code> に入れます。それぞれのフローエントリの具体的な働きについては後述します。</p>
</div>
<div id="routing_table_table" class="imageblock">
<div class="content">
<img src="images/router/routing_table_table.png" alt="routing table table">
</div>
<div class="title">図 14-4: ARP Responder テーブルのフローエントリ例</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">コラム: レジスタ</div>
<div class="paragraph">
<p>レジスタはパケットごとに8個まで (reg0〜reg7) の任意の値を設定できる32ビットの変数です。使い道としては、たとえば Routing Table テーブルで見たように IP アドレス (整数表現) などの即値を入れたり、パケットのフィールド値を入れたりできます。そして、セットしたレジスタの値はマッチフィールドの条件として使えるほか、SendOutPortの出力先ポート番号としても使えます。</p>
</div>
<div class="paragraph">
<p>このようにレジスタ機能は非常に柔軟で強力ですが、対応しているスイッチ実装が限られます。レジスタ機能はNicira社による独自拡張であるため、Nicira 拡張に対応した Open vSwitch などの高機能なスイッチでしか使えません。もしこうした拡張機能を使いたい場合には、スイッチのスペックをよく確認しておきましょう。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_interface_lookup_テーブル">14.1.4. Interface Lookup テーブル</h4>
<div class="paragraph">
<p>Interface Lookup テーブルはパケットをどのポートから出力するかを決定します (<a href="#interface_lookup_table">図 14-5</a>)。Routing Table テーブルで設定した <code>reg0</code> のネクストホップを元に、出力先のポート番号を決定し <code>reg1</code> にセットします。そして、パケットの送信元 MAC アドレスをポートの MAC アドレスに書き換えます。この動作はポートごとに異なるため、フローエントリ数はルータのポート数と同じになります。</p>
</div>
<div id="interface_lookup_table" class="imageblock">
<div class="content">
<img src="images/router/interface_lookup_table.png" alt="interface lookup table">
</div>
<div class="title">図 14-5: Interface Lookup テーブルのフローエントリ例</div>
</div>
</div>
<div class="sect3">
<h4 id="_arp_table_lookup_テーブル">14.1.5. ARP Table Lookup テーブル</h4>
<div class="paragraph">
<p>ARP Table Lookup テーブルはパケットの宛先 MAC アドレスを設定します (<a href="#arp_table_lookup_table">図 14-6</a>)。 ネクストホップ (<code>reg0</code>) から、対応するホストの MAC アドレスをパケットの宛先 MAC アドレスとして書き込みます。</p>
</div>
<div class="paragraph">
<p>ルータを起動した直後にはフローエントリ数は 1 つですが、ARP Reply を受け取り新しい MAC アドレスを学習するたびにフローエントリ数が増えます。それぞれのフローエントリの具体的な働きについては後述します。</p>
</div>
<div id="arp_table_lookup_table" class="imageblock">
<div class="content">
<img src="images/router/arp_table_lookup_table.png" alt="arp table lookup table">
</div>
<div class="title">図 14-6: ARP Table Lookup テーブルのフローエントリ例</div>
</div>
</div>
<div class="sect3">
<h4 id="_egress_テーブル">14.1.6. Egress テーブル</h4>
<div class="paragraph">
<p>フローテーブルから出力するパケットはすべて Egress テーブルを通ります (<a href="#egress_table">図 14-7</a>)。Egress テーブルはレジスタ <code>reg1</code> が指すポートにパケットを出力します。</p>
</div>
<div id="egress_table" class="imageblock">
<div class="content">
<img src="images/router/egress_table.png" alt="egress table">
</div>
<div class="title">図 14-7: Egress テーブルはパケットをポート reg1 番へ出力する</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_マルチプルテーブル版ルータの動作例">14.2. マルチプルテーブル版ルータの動作例</h3>
<div class="paragraph">
<p>マルチプルテーブル版ルータの動作例をいくつか、<a href="#sample_router_network_openflow13">図 14-8</a>の構成で詳しく見て行きましょう。</p>
</div>
<div id="sample_router_network_openflow13" class="imageblock">
<div class="content">
<img src="images/router/sample_router_network_openflow13.png" alt="sample router network openflow13">
</div>
<div class="title">図 14-8: マルチプルテーブル版ルータを動かすためのネットワーク構成</div>
</div>
<div class="paragraph">
<p>以降の説明で参照するマルチプルテーブル版ルータのソースコードは、GitHub の trema/simple_router リポジトリに入っています。次のコマンドでソースコードを取得してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/simple_router.git</pre>
</div>
</div>
<div class="paragraph">
<p>依存する gem のインストールは、いつも通り bundle install コマンドです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd simple_router
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>これで準備は完了です。</p>
</div>
<div class="sect3">
<h4 id="_ポート宛の_arp_request_に応答する">14.2.1. ポート宛の ARP Request に応答する</h4>
<div class="paragraph">
<p>host1 がルータのポート 1 番宛に ARP Request を送信した場合、フローテーブルは<a href="#handle_arp_request">図 14-9</a>の 2 つの処理を行います:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>host1 の MAC アドレスの学習</p>
</li>
<li>
<p>ARP Reply を host1 へ送信</p>
</li>
</ol>
</div>
<div id="handle_arp_request" class="imageblock">
<div class="content">
<img src="images/router/handle_arp_request.png" alt="handle arp request">
</div>
<div class="title">図 14-9: host1 がルータのポート 1 宛に ARP Request を送信した場合</div>
</div>
<div class="sect4">
<h5 id="_host1_の_mac_アドレスの学習">host1 の MAC アドレスの学習</h5>
<div class="paragraph">
<p>ポート 1 番に届いた ARP Request は、Ingress テーブルから Protocol Classifier を経て ARP Responder のフローエントリにマッチします (<a href="#handle_arp_request">図 14-9</a> の1)。そして ARP Request を送った host1 の MAC アドレスを学習するため、<code>SendOutPort</code> アクションでコントローラへと Packet In します (<a href="#handle_arp_request">図 14-9</a> の 2)。</p>
</div>
<div class="paragraph">
<p>コントローラでは、Packet In の送信元 IP アドレスと MAC アドレスを学習します。この学習は、ARP Table Lookup テーブルに <code>host1</code> のフローエントリを追加することで行います (<a href="#handle_arp_request">図 14-9</a> の 3)。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter13#add_arp_entry (lib/simple_router13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_arp_entry</span>(ip_address, mac_address, dpid)
  send_flow_mod_add(
    dpid,
    <span class="key">table_id</span>: <span class="constant">ARP_TABLE_LOOKUP_TABLE</span>,
    <span class="key">priority</span>: <span class="integer">2</span>,
    <span class="key">match</span>: <span class="constant">Match</span>.new(<span class="key">ether_type</span>: <span class="constant">EthernetHeader</span>::<span class="constant">EtherType</span>::<span class="constant">IPV4</span>,
                     <span class="key">reg0</span>: <span class="constant">IPv4Address</span>.new(ip_address).to_i),
    <span class="key">instructions</span>: [<span class="constant">Apply</span>.new(<span class="constant">SetDestinationMacAddress</span>.new(mac_address)),
                   <span class="constant">GotoTable</span>.new(<span class="constant">EGRESS_TABLE</span>)]
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_arp_reply_を_host1_へ送信">ARP Reply を host1 へ送信</h5>
<div class="paragraph">
<p>コントローラを使わずにフローテーブルだけで ARP Reply を返すために、届いた ARP Request を ARP Reply へ書き換えます。書き換えに必要なアクションは多いですが、やっていることは単純です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>イーサヘッダの <code>source_mac_address</code> の値を <code>destination_mac_address</code> にコピー</p>
</li>
<li>
<p><code>source_mac_address</code> の値をインタフェースの MAC アドレスの MAC アドレスの値にセット</p>
</li>
<li>
<p>ARP operation の値を ARP Reply にセット</p>
</li>
<li>
<p>ARP の <code>sender_hardware_address</code> (送信元の MAC アドレス) の値を <code>target_hardware_address</code> (宛先の MAC アドレス) にコピー</p>
</li>
<li>
<p>ARP の <code>sender_protocol_address</code> (送信元の IP アドレス) の値を <code>target_protocol_address</code> (宛先の IP アドレス) にコピー</p>
</li>
<li>
<p>ARP の <code>sender_hardware_address</code> をインタフェースの MAC アドレスの値にセット</p>
</li>
<li>
<p>ARP の <code>sender_protocol_address</code> をインタフェースの IP アドレスの値にセット</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>そして最後に、作った ARP Reply の出力先ポート番号 1 (= <code>host1</code> のつながるポート番号) を <code>reg1</code> にセットし、ARP Reply を Egress テーブルへ渡します (<a href="#handle_arp_request">図 14-9</a> の 4)。Egress テーブルはこのポート <code>reg1</code> へ ARP Reply を出力します。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_host1_から_host2_へ_ping_する">14.2.2. host1 から host2 へ ping する</h4>
<div class="paragraph">
<p><a href="#sample_router_network_openflow13">図 14-8</a> においてもう少し複雑な、<code>host1</code> から <code>host2</code> へ ping を打った場合を考えてみましょう。まずはルータが host2 へ ICMP Echo Request を届ける動作をおさらいします。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>host1 が出力した ICMP Echo Request がスイッチのポート 1 番に届く</p>
</li>
<li>
<p>ルータはルーティングテーブルから転送先ポートを 2 番と決定する</p>
</li>
<li>
<p>host2 の MAC アドレスを調べるため、ルータはポート 2 番から ARP Request を出力する</p>
</li>
<li>
<p>host2 は自分の MAC アドレスを乗せた ARP Reply を出力する</p>
</li>
<li>
<p>ルータは ICMP Echo Request の送信元と宛先をそれぞれ書き換えて host2 へ転送する</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>これに対応するフローテーブルの動作を<a href="#send_arp_request">図 14-10</a> で見て行きましょう。ポート 1 番に届いた ICMP Echo Request は、Ingress テーブルから Protocol Classifier を経て Routing Table のフローエントリにマッチします (<a href="#send_arp_request">図 14-10</a> の 1)。Routing Table と Interface Lookup テーブルではロンゲストマッチの処理を行います。</p>
</div>
<div id="send_arp_request" class="imageblock">
<div class="content">
<img src="images/router/send_arp_request.png" alt="send arp request">
</div>
<div class="title">図 14-10: host1 が host2 へ ICMP Echo Request を送信したときに host2 の MAC アドレスを解決するまでの動作</div>
</div>
</div>
<div class="sect3">
<h4 id="_ロンゲストマッチの処理">14.2.3. ロンゲストマッチの処理</h4>
<div class="paragraph">
<p>ロンゲストマッチでは、パケットの宛先 IP アドレスからネクストホップと出力ポート番号を決定します。これを Routing Table と Interface Lookup テーブルの 2 つで行います。Routing Table では、パケットの宛先 IP アドレスがポート 2 のネットワークのフローエントリにマッチします<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnote_24" title="View footnote.">24</a>]</sup>。そこで、ネクストホップ 192.168.2.2 を <code>reg0</code> へ入れます。そして、Interface Lookup テーブルではネクストホップに対応する出力ポート 2 を <code>reg1</code> にセットします。</p>
</div>
</div>
<div class="sect3">
<h4 id="_host2_へ_arp_request_を送る">14.2.4. host2 へ ARP Request を送る</h4>
<div class="paragraph">
<p>次に ARP Table Lookup テーブルで host2 の MAC アドレスを解決します。host2 の MAC アドレスはまだ学習していないので、ARP Request を送るためコントローラへいったんパケットを Packet In します (<a href="#send_arp_request">図 14-10</a> の 2)。</p>
</div>
<div class="paragraph">
<p>コントローラは Packet In を受け取ると、パケットを「ARP 解決待ちパケットキュー」に追加します。そして、host2 の MAC アドレスを解決するために ARP Request をフローテーブルへ Packet Out します (<a href="#send_arp_request">図 14-10</a> の 3)。その際、ARP Request には <code>reg1</code> (出力先ポート) に 2 をセットしておきます。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter13#packet_in_ipv4 (lib/simple_router13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_ipv4</span>(dpid, packet_in)
  dest_ip_address = <span class="constant">IPv4Address</span>.new(packet_in.match.reg0.to_i)
  <span class="instance-variable">@unresolved_packet_queue</span>[dest_ip_address] += [packet_in.raw_data]
  send_packet_out(
    dpid,
    <span class="key">raw_data</span>: <span class="constant">Arp</span>::<span class="constant">Request</span>.new(<span class="key">target_protocol_address</span>: dest_ip_address,
                               <span class="key">source_mac</span>: <span class="string"><span class="delimiter">'</span><span class="content">00:00:00:00:00:00</span><span class="delimiter">'</span></span>,
                               <span class="key">sender_protocol_address</span>: <span class="string"><span class="delimiter">'</span><span class="content">0.0.0.0</span><span class="delimiter">'</span></span>).to_binary,
    <span class="key">actions</span>: [<span class="constant">NiciraRegLoad</span>.new(packet_in.match.reg1, <span class="symbol">:reg1</span>),
              <span class="constant">SendOutPort</span>.new(<span class="symbol">:table</span>)]
  )
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>フローテーブルへ入った ARP Request は、ARP Responder テーブルのフローエントリにマッチします。そして、<code>reg1</code> の値から ARP Request の MAC アドレスと IP アドレスをポート 2 のものにセットしたのち、Egress テーブルから host2 へと転送します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_host2_からの_arp_reply_の処理">14.2.5. host2 からの ARP Reply の処理</h4>
<div class="paragraph">
<p>host2 からの ARP Reply が届くと、コントローラに Packet In します (<a href="#handle_arp_reply">図 14-11</a> の 1, 2)。</p>
</div>
<div id="handle_arp_reply" class="imageblock">
<div class="content">
<img src="images/router/handle_arp_reply.png" alt="handle arp reply">
</div>
<div class="title">図 14-11: host2 の MAC アドレスを学習し ICMP Echo Request を host2 に届けるまでの動作</div>
</div>
<div class="paragraph">
<p>ARP Reply を受け取ったコントローラは次のように動作します。まず、ARP Reply で解決した host2 の MAC アドレス用フローエントリを ARP Table Lookup テーブルに追加します (<a href="#handle_arp_reply">図 14-11</a> の 3)。そして、MAC アドレス未解決で送信待ちになっていたパケットをすべて、Packet Out で再び Ingress テーブルに入れます (<a href="#handle_arp_reply">図 14-11</a> の 4)。</p>
</div>
<div class="listingblock">
<div class="title">SimpleRouter13#packet_in_arp (lib/simple_router13.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in_arp</span>(dpid, packet_in)
  add_arp_entry(packet_in.sender_protocol_address,
                packet_in.sender_hardware_address,
                dpid)
  <span class="instance-variable">@unresolved_packet_queue</span>[packet_in.sender_protocol_address].each <span class="keyword">do</span> |each|
    send_packet_out(dpid, <span class="key">raw_data</span>: each, <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(<span class="symbol">:table</span>))
  <span class="keyword">end</span>
  <span class="instance-variable">@unresolved_packet_queue</span>[packet_in.sender_protocol_address] = []
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>以上で host1 から host2 への ICMP Echo Request が届きます。戻りの host2 からの ICMP Echo Reply についても、同様の動作で host1 へと届きます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_9">14.3. 実行してみよう</h3>
<div class="paragraph">
<p>マルチプルテーブル版ルータ (lib/simple_router13.rb) の使いかたは<a href="#router_part1">12 章</a>、<a href="#router_part2">13 章</a>で紹介したルータと変わりません。ただし OpenFlow1.3 を使うので、<code>trema run</code> の起動オプションに <code>--openflow13</code> を付けるのを忘れないでください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/simple-router.rb -c ./trema.conf --openflow13
SimpleRouter13 started.</pre>
</div>
</div>
<div class="paragraph">
<p>コントローラが起動したら、ためしに <code>host1</code> から <code>host2</code> へ ping を送ってみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ bundle exec trema netns host1 "ping -c1 192.168.2.2"
PING 192.168.2.2 (192.168.2.2) 56(84) bytes of data.
64 bytes from 192.168.2.2: icmp_seq=1 ttl=64 time=132 ms

--- 192.168.2.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 132.738/132.738/132.738/0.000 ms</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに host2 へ届いています。<code>trema dump_flows</code> コマンドでマルチプルテーブルのフローエントリを眺めてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ bundle exec trema dump_flows 0x1
OFPST_FLOW reply (OF1.3) (xid=0x2):
 cookie=0x0, duration=153.160s, table=0, n_packets=21, n_bytes=1546, priority=0 actions=goto_table:1
 cookie=0x0, duration=153.160s, table=1, n_packets=6, n_bytes=296, priority=0,arp actions=goto_table:2
 cookie=0x0, duration=153.160s, table=1, n_packets=4, n_bytes=392, priority=0,ip actions=goto_table:3
 cookie=0x0, duration=153.152s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=1,arp_tpa=192.168.1.1,arp_op=1 actions=move:NXM_OF_ETH_SRC[]-&gt;NXM_OF_ETH_DST[],set_field:01:01:01:01:01:01-&gt;eth_src,set_field:2-&gt;arp_op,move:NXM_NX_ARP_SHA[]-&gt;NXM_NX_ARP_THA[],move:NXM_OF_ARP_SPA[]-&gt;NXM_OF_ARP_TPA[],set_field:01:01:01:01:01:01-&gt;arp_sha,set_field:192.168.1.1-&gt;arp_spa,load:0xffff-&gt;OXM_OF_IN_PORT[],load:0x1-&gt;NXM_NX_REG1[],goto_table:6
 cookie=0x0, duration=153.142s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=1,arp_tpa=192.168.1.1,arp_op=2 actions=CONTROLLER:65535
 cookie=0x0, duration=153.103s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=2,arp_tpa=192.168.2.1,arp_op=1 actions=move:NXM_OF_ETH_SRC[]-&gt;NXM_OF_ETH_DST[],set_field:02:02:02:02:02:02-&gt;eth_src,set_field:2-&gt;arp_op,move:NXM_NX_ARP_SHA[]-&gt;NXM_NX_ARP_THA[],move:NXM_OF_ARP_SPA[]-&gt;NXM_OF_ARP_TPA[],set_field:02:02:02:02:02:02-&gt;arp_sha,set_field:192.168.2.1-&gt;arp_spa,load:0xffff-&gt;OXM_OF_IN_PORT[],load:0x2-&gt;NXM_NX_REG1[],goto_table:6
 cookie=0x0, duration=153.093s, table=2, n_packets=1, n_bytes=42, priority=0,arp,in_port=2,arp_tpa=192.168.2.1,arp_op=2 actions=CONTROLLER:65535
 cookie=0x0, duration=153.130s, table=2, n_packets=1, n_bytes=64, priority=0,arp,reg1=0x1 actions=set_field:01:01:01:01:01:01-&gt;eth_src,set_field:01:01:01:01:01:01-&gt;arp_sha,set_field:192.168.1.1-&gt;arp_spa,goto_table:6
 cookie=0x0, duration=153.083s, table=2, n_packets=1, n_bytes=64, priority=0,arp,reg1=0x2 actions=set_field:02:02:02:02:02:02-&gt;eth_src,set_field:02:02:02:02:02:02-&gt;arp_sha,set_field:192.168.2.1-&gt;arp_spa,goto_table:6
 cookie=0x0, duration=153.064s, table=3, n_packets=2, n_bytes=196, priority=40024,ip,nw_dst=192.168.1.0/24 actions=move:NXM_OF_IP_DST[]-&gt;NXM_NX_REG0[],goto_table:4
 cookie=0x0, duration=153.055s, table=3, n_packets=2, n_bytes=196, priority=40024,ip,nw_dst=192.168.2.0/24 actions=move:NXM_OF_IP_DST[]-&gt;NXM_NX_REG0[],goto_table:4
 cookie=0x0, duration=153.073s, table=3, n_packets=0, n_bytes=0, priority=0,ip actions=load:0xc0a80102-&gt;NXM_NX_REG0[],goto_table:4
 cookie=0x0, duration=153.047s, table=4, n_packets=2, n_bytes=196, priority=0,reg0=0xc0a80100/0xffffff00 actions=load:0x1-&gt;NXM_NX_REG1[],set_field:01:01:01:01:01:01-&gt;eth_src,goto_table:5
 cookie=0x0, duration=153.039s, table=4, n_packets=2, n_bytes=196, priority=0,reg0=0xc0a80200/0xffffff00 actions=load:0x2-&gt;NXM_NX_REG1[],set_field:02:02:02:02:02:02-&gt;eth_src,goto_table:5
 cookie=0x0, duration=122.241s, table=5, n_packets=1, n_bytes=98, priority=2,ip,reg0=0xc0a80202 actions=set_field:1e:36:b3:90:02:e5-&gt;eth_dst,goto_table:6
 cookie=0x0, duration=122.180s, table=5, n_packets=1, n_bytes=98, priority=2,ip,reg0=0xc0a80102 actions=set_field:e6:b6:de:b6:ed:1e-&gt;eth_dst,goto_table:6
 cookie=0x0, duration=153.027s, table=5, n_packets=2, n_bytes=196, priority=1,ip actions=CONTROLLER:65535
 cookie=0x0, duration=153.022s, table=6, n_packets=6, n_bytes=408, priority=0 actions=output:NXM_NX_REG1[]</pre>
</div>
</div>
<div class="paragraph">
<p>それぞれのエントリの <code>table=数字</code> の項目がテーブル ID を指しています。この章のマルチプルテーブル構成と見比べて、実際にどれがどのフローエントリかを確認してみてください。ping などでパケットを送受信しながら、フローエントリごとのパケットカウンタ (<code>n_packets=数字</code>) の値を確認していくと、より理解が深まることでしょう。</p>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_14">14.4. まとめ</h3>
<div class="paragraph">
<p>OpenFlow1.3 のマルチプルテーブルを使うことで、ルータの機能の大部分をフローテーブルとして実装しました。パケットの種類や処理ごとにテーブルを分割することで、ルータのように複雑な機能もマルチプルテーブルとして実装できます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="topology">15. ネットワークトポロジを検出する</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>大規模なネットワークを構築する前準備として、ネットワークトポロジを OpenFlow で検出してみましょう</p>
</div>
<div class="sect2">
<h3 id="_美しい大規模ネットワーク">15.1. 美しい大規模ネットワーク</h3>
<div class="paragraph">
<p>筆者はネットワーク研究者という仕事柄、よくさまざまなネットワークを目にします。その中でいつも「すごい!」とうならされるのが、ネットワークエンジニアの憧れ、ShowNet です。ShowNet はネットワーク系最大の展示会 Interop Tokyo の期間中だけ運用されるネットワークで、最新ネットワーク技術のいわばショーケースと言えます。普段は触れることのできない、ネットワーク界の F1 マシンとも言える最新機器を集めたライブデモンストレーションは圧巻の一言です。</p>
</div>
<div class="paragraph">
<p>ShowNet の魅力をもっともよく伝えてくれるのが、Interop Tokyo で毎年公開される ShowNet のトポロジ図です (<a href="#shownet_topology">図 15-1</a>)。注目すべきは、ShowNet の複雑な情報をたった一枚の図に収めているところです。「この部分は、いったいどんなプロトコルで動いているんだろう?」「実際の詳しいトポロジはどうなっているのかな?」こうした気になる部分が、すべて一枚の図にきれいに収まっています。ネットワークが好きな人であれば、気がつくと何時間でも眺めてしまうほどの魅力を持つトポロジ図なのです。</p>
</div>
<div id="shownet_topology" class="imageblock">
<div class="content">
<img src="images/topology/shownet_topology.jpg" alt="shownet topology">
</div>
<div class="title">図 15-1: 2015 年 Interop Tokyo の ShowNet トポロジ図。引用元: <a href="http://www.interop.jp/2015/shownet/images/topology02.pdf" class="bare">http://www.interop.jp/2015/shownet/images/topology02.pdf</a> Copyright &#169; Interop Tokyo 2015 ShowNet NOC Team Member and NANO OPT Media, Inc. All Rights Reserved.</div>
</div>
<div class="paragraph">
<p>ShowNet のようにいくつものスイッチやルータがつながるネットワークの動作では、トポロジ情報の把握が1つの鍵です。パケットが迷子になったりループしたりせずに正しく目的地まで届くためには、スイッチやルータ同士がどのような接続関係にあるかをお互いに把握しなければなりません。</p>
</div>
<div class="paragraph">
<p>OpenFlow では、コントローラがこのトポロジ情報を管理します。ネットワーク全体を集中管理するコントローラがトポロジを把握することで、パケットを思いのままに転送できます。たとえば、パケットの転送に、最短パスを使うだけではなく、回り道をさせたり、複数のパス (マルチパス) を使うことも自由自在です。</p>
</div>
</div>
<div class="sect2">
<h3 id="_トポロジ検出の仕組み">15.2. トポロジ検出の仕組み</h3>
<div class="paragraph">
<p>コントローラがトポロジ情報を検出するには、スイッチ間のリンクをすべて発見する必要があります。ネットワーク中のスイッチとポート情報は、<code>switch_ready</code> ハンドラや Features Request/Reply メッセージを使えばすべて発見できます。したがって、発見したスイッチ間のリンクがすべて発見できれば、ネットワークトポロジを検出できます。</p>
</div>
<div class="sect3">
<h4 id="_リンクの発見">15.2.1. リンクの発見</h4>
<div class="paragraph">
<p>OpenFlow でリンクを発見する方法として代表的なのは、Link Layer Discovery Protocol (LLDP) パケットを使った方法です (<a href="#lldp_overview">図 15-2</a>)。コントローラはどこにリンクがあるかあたりをつけるために、適当なスイッチ A に LLDP パケットを試しに送ります。もし、スイッチ Aに別のスイッチ B がリンクでつながっていれば、LLDPはそこのリンクを通りスイッチ Bを経由してブーメランのようにコントローラへと戻ってきます。このように LLDP パケットが無事に戻ってくれば、スイッチ A と B はリンクでつながっているとわかります。また、LLDP パケットには通過したリンクの詳しい情報が書き込まれるので、スイッチ A と B がどのポート番号で接続しているかということまでわかります。これを繰り返していけば、最終的にはすべてのリンクを発見できるわけです。</p>
</div>
<div id="lldp_overview" class="imageblock">
<div class="content">
<img src="images/topology/lldp_overview.png" alt="lldp overview">
</div>
<div class="title">図 15-2: LLDP を使ってリンクを発見する</div>
</div>
<div class="paragraph">
<p>「なぜ、LLDP パケットはきちんとリンクを通ってコントローラまで戻ってくるんだろう？スイッチに LLDP 固有のしかけが必要なのかな？」こう思った方もいるかもしれません。実は、LLDPによるリンクは今まで学んできた OpenFlow の仕組みだけを使って実現できます。つまり、OpenFlow に対応したスイッチであれば LLDPでリンクを発見できるのです。</p>
</div>
<div class="paragraph">
<p>LLDP によるリンク発見を OpenFlow で実現する方法を見ていきましょう。<a href="#lldp_openflow">図 15-3</a> のように、スイッチ 0x1 のポート 5 とスイッチ 0x2 のポート 1 が接続されていたとします。このリンクを発見するために、コントローラは次の動作をします。</p>
</div>
<div id="lldp_openflow" class="imageblock">
<div class="content">
<img src="images/topology/lldp_openflow.png" alt="lldp openflow">
</div>
<div class="title">図 15-3: LLDP パケットと OpenFlow の仕組みを使ってリンクを発見する</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>コントローラは、接続関係を調べたいスイッチの Datapath ID 0x1 とポート番号 5 を埋め込んだ Link Layer Discovery Protocol (LLDP) パケットを作る</p>
</li>
<li>
<p>ポート 5 から出力するというアクションを含む Packet Out メッセージを作り、先ほど作った LLDPパケットをスイッチ 0x1 へと送る</p>
</li>
<li>
<p>Packet Out を受け取ったスイッチはアクションに従い、LLDPパケットを指定されたポート 5 から出力する。その結果、LLDP パケットは、ポート 5 の先につながるスイッチ 0x2 へと到着する</p>
</li>
<li>
<p>LLDP パケットを受け取ったスイッチ 0x2 は、自身のフローテーブルを参照し、パケットの処理方法を調べる。このとき LLDP に対するフローエントリはあえて設定していないため、今回受信した LLDPパケットは、Packet In としてコントローラまで戻される</p>
</li>
<li>
<p>コントローラは、受け取った Packet In メッセージを解析することで、リンクの発見を行う。スイッチ 0x2 からは<a href="#lldp_packet_in">図 15-4</a> の Packet In メッセージが送られてくる。この中身を見ることで、スイッチ 0x1 のポート 5 と、スイッチ 0x2 のポート 1 の間にリンクを発見できる</p>
</li>
</ol>
</div>
<div id="lldp_packet_in" class="imageblock">
<div class="content">
<img src="images/topology/lldp_packet_in.png" alt="lldp packet in">
</div>
<div class="title">図 15-5: スイッチ 0x2 から送られてくる Packet In メッセージ</div>
</div>
<div class="paragraph">
<p>このように、Packet Out で送られた LLDP パケットは、リンクを通過し、隣のスイッチから Packet In でコントローラへと戻ってきます。この一連の動作によりコントローラはリンクを発見できます。この方法自体は、OpenFlow 仕様でとくに規定されているわけではありません。それぞれのスイッチは OpenFlow 仕様で定められた動作を行っているだけです。つまり、Packet Out と Packet In をうまく使った “OpenFlow ならでは” のリンク発見方法だと言えます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_トポロジの検出">15.2.2. トポロジの検出</h4>
<div class="paragraph">
<p>このリンク発見方法をネットワーク中のすべてのスイッチのすべてのポートに順に適用していけば、ネットワーク全体のスイッチの接続関係、つまりトポロジを検出できます。たとえば<a href="#topology_before">図 15-5</a>のような 3 台の OpenFlow スイッチからなるネットワークにおいて、どうやってトポロジを検出できるかを見ていきましょう。各 OpenFlow スイッチがコントローラに接続した直後の状態では、コントローラはスイッチ同士がどのように接続されているかを知りません。</p>
</div>
<div id="topology_before" class="imageblock">
<div class="content">
<img src="images/topology/topology_before.png" alt="topology before">
</div>
<div class="title">図 15-5: トポロジ検出前のコントローラ</div>
</div>
<div class="paragraph">
<p>まずスイッチ 0x1 から調べていきます。はじめに Features Request メッセージを送ることで、スイッチ 0x1 が持つポート一覧を取得します。そして、それぞれのポートに対して、前述のリンク発見手順を行います (<a href="#topology_after">図 15-6</a>)。その結果、スイッチ 0x1 からスイッチ 0x2 およびスイッチ 0x3 へと至るリンクそれぞれを発見できます。</p>
</div>
<div id="topology_after" class="imageblock">
<div class="content">
<img src="images/topology/topology_after.png" alt="topology after">
</div>
<div class="title">図 15-6: スイッチ 0x1 から出るリンクを発見</div>
</div>
<div class="paragraph">
<p>あとは同様の手順を、ネットワーク中の各スイッチに対して順に行なっていくだけです。スイッチ 0x2, 0x3 に接続するリンクを順に調べていくことで、ネットワークの完全なトポロジ情報を検出できます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_10">15.3. 実行してみよう</h3>
<div class="paragraph">
<p>このトポロジ検出機能を持つ Topology コントローラを実行してみましょう。ソースコードと仮想ネットワークの設定ファイルは GitHub の trema/topology リポジトリ (<a href="https://github.com/trema/topology" class="bare">https://github.com/trema/topology</a>) からダウンロードできます。今までと同じく、<code>git clone</code> でソースコードを取得し <code>bundle install</code> で必要な gem をインストールしてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/topology.git
$ cd topology
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>ソースコードに含まれる <code>triangle.conf</code> はスイッチ 3 台を三角形に接続したトライアングル型のトポロジです (<a href="#triangle_conf">図 15-7</a>)。</p>
</div>
<div id="triangle_conf" class="imageblock">
<div class="content">
<img src="images/topology/triangle_conf.png" alt="triangle conf">
</div>
<div class="title">図 15-7: triangle.confのトポロジ</div>
</div>
<div class="paragraph">
<p>これをトポロジコントローラで検出するには、次のように実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/topology_controller.rb -c triangle.conf
Topology started (text mode).
Port 0x1:1 added: 1
Port 0x1:2 added: 1, 2
Switch 0x1 added: 0x1
Port 0x3:1 added: 1
Port 0x3:2 added: 1, 2
Switch 0x3 added: 0x1, 0x3
Port 0x2:1 added: 1
Port 0x2:2 added: 1, 2
Switch 0x2 added: 0x1, 0x2, 0x3
Link 0x1-0x2 added: 0x1-0x2
Link 0x1-0x3 added: 0x1-0x2, 0x1-0x3
Link 0x2-0x3 added: 0x1-0x2, 0x1-0x3, 0x2-0x3</pre>
</div>
</div>
<div class="paragraph">
<p>先に説明したように、コントローラはまず Features Reply メッセージによってスイッチとポートの一覧を取得します。たとえば、<code>Port 0x1:1 added</code> の行はスイッチ 0x1 のポート 1 番をコントローラが検出したという意味です。<code>Switch 0x1 added</code> のメッセージも同じく Features Reply メッセージを返したスイッチのデータパス ID を表示しています。</p>
</div>
<div class="paragraph">
<p>リンクの検出は LLDP を使って一本ずつ行います。たとえば <code>Link 0x1-0x2 added</code> はスイッチ 0x1 から 0x2 に LLDP パケットが通り、コントローラに PacketIn したことからリンクを一本発見したという意味です。これを繰り返すことで最終的に三角形のトポロジ (<code>Link 0x2-0x3 added: 0x1-0x2, 0x1-0x3, 0x2-0x3</code> のメッセージ) を発見しています。</p>
</div>
<div class="paragraph">
<p>トポロジコントローラはトポロジの変化も検出できます。</p>
</div>
<div id="triangle_port_down" class="imageblock">
<div class="content">
<img src="images/topology/triangle_port_down.png" alt="triangle port down">
</div>
<div class="title">図 15-8: スイッチ 0x1 のポート 1 番を落としたときのトポロジ</div>
</div>
<div class="paragraph">
<p>たとえば<a href="#triangle_port_down">図 15-8</a>のようにスイッチ 0x1 のポート 1 番を落としてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema port_down --switch 0x1 --port 1</pre>
</div>
</div>
<div class="paragraph">
<p>すると、コントローラを実行したターミナルには次の表示が出ます。たしかに 0x1-0x2 間のリンクが消滅し、残りは 0x1-0x3 と 0x2-0x3 の二本になりました。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Link 0x1-0x2 deleted: 0x1-0x3, 0x2-0x3
Port 0x1:1 deleted: 2</pre>
</div>
</div>
<div class="paragraph">
<p>逆に再びポートを上げると、三角形トポロジが復活します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema port_up --switch 0x1 --port 1</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Port 0x1:1 added: 1, 2
Link 0x1-0x2 added: 0x1-0x2, 0x1-0x3, 0x2-0x3</pre>
</div>
</div>
<div class="paragraph">
<p>トポロジコントローラはトポロジを画像で表示することもできます。この機能を使うためには、システムに graphviz をあらかじめ <code>apt-get</code> でインストールしておきます。そして、<code>trema run</code> の引数に <code>--</code> と <code>graphviz トポロジ画像出力ファイル名</code> を指定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/topology_controller.rb -c triangle.conf -- graphviz /tmp/topology.png</pre>
</div>
</div>
<div class="paragraph">
<p>実行すると、<a href="#graphviz_triangle">図 15-9</a> のようにトポロジ画像が生成されます。</p>
</div>
<div id="graphviz_triangle" class="imageblock">
<div class="content">
<img src="images/topology/graphviz_triangle.png" alt="graphviz triangle">
</div>
<div class="title">図 15-9: トポロジコントローラで生成した三角形トポロジの画像</div>
</div>
</div>
<div class="sect2">
<h3 id="_トポロジコントローラのソースコード">15.4. トポロジコントローラのソースコード</h3>
<div class="paragraph">
<p>トポロジコントローラは大きく分けて 3 つの部品からなります (<a href="#topology_classes">図 15-10</a>)。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>TopologyController</code> クラス</dt>
<dd>
<p>コントローラの本体で、LLDPパケットの送信とトポロジに関する OpenFlow メッセージの処理をします</p>
</dd>
<dt class="hdlist1"><code>Topology</code> クラス</dt>
<dd>
<p>収集したトポロジ情報を管理し、トポロジの変化を View クラスへ通知します</p>
</dd>
<dt class="hdlist1"><code>View::Text</code>, <code>View::Graphviz</code> クラス</dt>
<dd>
<p>トポロジをテキストまたは画像で表示します</p>
</dd>
</dl>
</div>
<div id="topology_classes" class="imageblock">
<div class="content">
<img src="images/topology/topology_classes.png" alt="topology classes">
</div>
<div class="title">図 15-10: トポロジのクラス構成</div>
</div>
<div class="paragraph">
<p>このクラス分けは、いわゆる MVC モデル (Model-View-Controller) に従っています。<code>TopologyController</code> クラスは MVC の Controller にあたり、OpenFlow スイッチとメッセージをやりとりしたり他のクラスをセットアップしたりといった制御を担当します。<code>Topology</code> クラスは Model にあたり、ネットワークのモデルすなわちトポロジ情報を管理します。<code>View::Text</code> と <code>View::Graphviz</code> はその名の通り View にあたり、モデルである Topology を可視化します。</p>
</div>
<div class="paragraph">
<p>このようにクラスを MVC で構成するとそれぞれのクラスの役割りがすっきりし、拡張性も向上します。たとえばトポロジを HTML で表示したくなった場合には、新たに <code>View::Html</code> クラスを追加するだけで実現できます。しかも、<code>TopologyController</code> や <code>Topology</code> クラスへの変更はほとんど必要ありません。また、<a href="#routing_switch">次章</a>で紹介するルーティングスイッチでは、トポロジを部品として使うことで複雑なパケット制御を可能にしています。このように比較的複雑な機能を実現したい場合には、クラスを MVC で構成できるかどうか検討するとよいでしょう。</p>
</div>
<div class="sect3">
<h4 id="_モデルとビューのセットアップ">15.4.1. モデルとビューのセットアップ</h4>
<div class="paragraph">
<p><code>TopologyController</code> の仕事の1つは、MVC のモデルとビューのセットアップです。次の <code>start</code> ハンドラでは、起動時のコマンドライン引数をパースし、トポロジ表示をテキスト表示 (<code>View::Text</code>) にするかまたは画像表示 (<code>View::Graphviz</code>) にするかを決定します。そして、決定したビューをモデル (<code>Topology</code>) のオブザーバとして追加 (<code>@topology.add_observer</code>) します。</p>
</div>
<div class="listingblock">
<div class="title">TopologyController#start</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">start</span>(args)
  <span class="instance-variable">@command_line</span> = <span class="constant">CommandLine</span>.new(logger)
  <span class="instance-variable">@command_line</span>.parse(args)
  <span class="instance-variable">@topology</span> = <span class="constant">Topology</span>.new
  <span class="instance-variable">@topology</span>.add_observer <span class="instance-variable">@command_line</span>.view
  logger.info <span class="string"><span class="delimiter">&quot;</span><span class="content">Topology started (</span><span class="inline"><span class="inline-delimiter">#{</span><span class="instance-variable">@command_line</span>.view<span class="inline-delimiter">}</span></span><span class="content">).</span><span class="delimiter">&quot;</span></span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>このオブザーバは、デザインパターンにおけるいわゆるオブザーバ・パターンの一例です。<code>Topology</code> のオブザーバとして追加されたビューのクラス (<code>View::Text</code> または <code>View::Graphviz</code>) は、トポロジに変化があった場合に変化イベントを <code>Topology</code> から受け取ります。そして、それぞれのビューの方法でトポロジを表示します。</p>
</div>
<div class="paragraph">
<p>オブザーバが受け取れるトポロジの変化イベントは次の通りです:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>add_switch</code>: スイッチの追加イベント</p>
</li>
<li>
<p><code>delete_switch</code>: スイッチの削除イベント</p>
</li>
<li>
<p><code>add_port</code>: ポートの追加イベント</p>
</li>
<li>
<p><code>delete_port</code>: ポートの削除イベント</p>
</li>
<li>
<p><code>add_link</code>: リンクの追加イベント</p>
</li>
<li>
<p><code>delete_link</code>: リンクの削除イベント</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>オブザーバとして追加できるオブジェクトは、これらのイベントを受け取れば何でもかまいません。たとえば <code>View::Text</code> は次のように <code>add_switch</code> や <code>add_port</code> といったトポロジイベントハンドラを持っており、イベントに応じてトポロジをテキストベースで表示します。</p>
</div>
<div class="listingblock">
<div class="title">lib/view/text.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">module</span> <span class="class">View</span>
  <span class="comment"># Topology controller's CUI.</span>
  <span class="keyword">class</span> <span class="class">Text</span>
    <span class="keyword">def</span> <span class="function">initialize</span>(logger)
      <span class="instance-variable">@logger</span> = logger
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">add_switch</span>(dpid, topology)
      show_status(<span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> added</span><span class="delimiter">&quot;</span></span>,
                  topology.switches.map(&amp;<span class="symbol">:to_hex</span>))
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">delete_switch</span>(dpid, topology)
      show_status(<span class="string"><span class="delimiter">&quot;</span><span class="content">Switch </span><span class="inline"><span class="inline-delimiter">#{</span>dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content"> deleted</span><span class="delimiter">&quot;</span></span>,
                  topology.switches.map(&amp;<span class="symbol">:to_hex</span>))
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">add_port</span>(port, topology)
      add_or_delete_port <span class="symbol">:added</span>, port, topology
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">delete_port</span>(port, topology)
      add_or_delete_port <span class="symbol">:deleted</span>, port, topology
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">add_link</span>(port_a, port_b, topology)
      link = format(<span class="string"><span class="delimiter">'</span><span class="content">%#x-%#x</span><span class="delimiter">'</span></span>, *([port_a.dpid, port_b.dpid].sort))
      show_status <span class="string"><span class="delimiter">&quot;</span><span class="content">Link </span><span class="inline"><span class="inline-delimiter">#{</span>link<span class="inline-delimiter">}</span></span><span class="content"> added</span><span class="delimiter">&quot;</span></span>, topology.links
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">delete_link</span>(port_a, port_b, topology)
      link = format(<span class="string"><span class="delimiter">'</span><span class="content">%#x-%#x</span><span class="delimiter">'</span></span>, *([port_a.dpid, port_b.dpid].sort))
      show_status <span class="string"><span class="delimiter">&quot;</span><span class="content">Link </span><span class="inline"><span class="inline-delimiter">#{</span>link<span class="inline-delimiter">}</span></span><span class="content"> deleted</span><span class="delimiter">&quot;</span></span>, topology.links
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">to_s</span>
      <span class="string"><span class="delimiter">'</span><span class="content">text mode</span><span class="delimiter">'</span></span>
    <span class="keyword">end</span>

    private

    <span class="keyword">def</span> <span class="function">add_or_delete_port</span>(message, port, topology)
      ports = topology.ports[port.dpid].map(&amp;<span class="symbol">:number</span>).sort
      show_status <span class="string"><span class="delimiter">&quot;</span><span class="content">Port </span><span class="inline"><span class="inline-delimiter">#{</span>port.dpid.to_hex<span class="inline-delimiter">}</span></span><span class="content">:</span><span class="inline"><span class="inline-delimiter">#{</span>port.number<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">#{</span>message<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>, ports
    <span class="keyword">end</span>

    <span class="keyword">def</span> <span class="function">show_status</span>(message, objects)
      status = objects.sort.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string"><span class="delimiter">'</span><span class="content">, </span><span class="delimiter">'</span></span>)
      <span class="instance-variable">@logger</span>.info <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>message<span class="inline-delimiter">}</span></span><span class="content">: </span><span class="inline"><span class="inline-delimiter">#{</span>status<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>MVC で説明したように、未知の外部クラスと連携したい場合にオブザーバ・パターンは便利です。<code>Topology</code> からのイベントを受け取るには <code>Topology#add_observer</code> でオブザーバとして登録するだけで良く、<code>Topology</code> クラスにはオブザーバのクラスに依存するコードはありません。このため、ビューに限らずトポロジ情報を利用するクラスを自由にオブザーバとして追加できます。たとえば<a href="#routing_switch">次章</a>や<a href="#sliceable_switch">その次の章</a>で実装するコントローラでは、<code>Topology</code> にコントローラ自身をオブザーバとして登録することで、トポロジ情報を利用してパケットの転送を制御します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_openflow_メッセージの処理">15.4.2. OpenFlow メッセージの処理</h4>
<div class="paragraph">
<p><code>TopologyController</code> クラスはスイッチから届く OpenFlow メッセージに応じた処理をします。</p>
</div>
<div class="paragraph">
<p><code>switch_ready</code> ハンドラでは、新しく接続してきたスイッチのポート一覧をを知るために、Features Request メッセージをスイッチに投げます。そして、<code>features_reply</code> ハンドラでスイッチから届いた Features Reply が持つポート一覧情報のうち、物理ポートでポートが上がっているものを <code>@topology</code> に追加します。このポート一覧は、LLDP パケットを作って送る際に使います。</p>
</div>
<div class="listingblock">
<div class="title">TopologyController#switch_ready, TopologyController#features_reply</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_ready</span>(dpid)
  send_message dpid, <span class="constant">Features</span>::<span class="constant">Request</span>.new
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">features_reply</span>(dpid, features_reply)
  <span class="instance-variable">@topology</span>.add_switch dpid, features_reply.physical_ports.select(&amp;<span class="symbol">:up?</span>)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>そのほかのハンドラでは、届いたメッセージの種類に応じてトポロジ情報を更新します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>switch_disconnected</code>: コントローラとの接続が切れたスイッチをトポロジ情報 (<code>@topology</code>) から削除する</p>
</li>
<li>
<p><code>port_modify</code>:  ポート情報の変更 (ポートのUPとDOWN) を識別し、どちらの場合も <code>@topology</code> に反映する</p>
</li>
<li>
<p><code>packet_in</code>: 帰ってきた LLDP パケットから発見したリンク情報、または新規ホスト情報を <code>@topology</code> に登録する</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">TopologyController#switch_disconnected, TopologyController#port_modify, TopologyController#packet_in</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">switch_disconnected</span>(dpid)
  <span class="instance-variable">@topology</span>.delete_switch dpid
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">port_modify</span>(_dpid, port_status)
  updated_port = port_status.desc
  <span class="keyword">return</span> <span class="keyword">if</span> updated_port.local?
  <span class="keyword">if</span> updated_port.down?
    <span class="instance-variable">@topology</span>.delete_port updated_port
  <span class="keyword">elsif</span> updated_port.up?
    <span class="instance-variable">@topology</span>.add_port updated_port
  <span class="keyword">else</span>
    fail <span class="string"><span class="delimiter">'</span><span class="content">Unknown port status.</span><span class="delimiter">'</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">packet_in</span>(dpid, packet_in)
  <span class="keyword">if</span> packet_in.lldp?
    <span class="instance-variable">@topology</span>.maybe_add_link <span class="constant">Link</span>.new(dpid, packet_in)
  <span class="keyword">else</span>
    <span class="instance-variable">@topology</span>.maybe_add_host(packet_in.source_mac,
                             packet_in.source_ip_address,
                             dpid,
                             packet_in.in_port)
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lldp_パケットをスイッチへ送る">15.4.3. LLDP パケットをスイッチへ送る</h4>
<div class="paragraph">
<p>LLDP パケットの定期送信は、<code>flood_lldp_frames</code> メソッドをタイマで呼び出すことで行います。<code>@topology</code> が管理する発見済みポートすべて (<code>@topology.ports</code>) に対して、Packet Out で LLDP パケットを送信します。</p>
</div>
<div class="listingblock">
<div class="title">TopologyController#flood_lldp_frames</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">class</span> <span class="class">TopologyController</span> &lt; <span class="constant">Trema</span>::<span class="constant">Controller</span>
  timer_event <span class="symbol">:flood_lldp_frames</span>, <span class="key">interval</span>: <span class="integer">1</span>.sec

  <span class="keyword">def</span> <span class="function">flood_lldp_frames</span>
    <span class="instance-variable">@topology</span>.ports.each <span class="keyword">do</span> |dpid, ports|
      send_lldp dpid, ports
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  private

  <span class="keyword">def</span> <span class="function">send_lldp</span>(dpid, ports)
    ports.each <span class="keyword">do</span> |each|
      port_number = each.number
      send_packet_out(
        dpid,
        <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(port_number),
        <span class="key">raw_data</span>: lldp_binary_string(dpid, port_number)
      )
    <span class="keyword">end</span>
  <span class="keyword">end</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_トポロジ情報の管理">15.4.4. トポロジ情報の管理</h4>
<div class="paragraph">
<p><code>Topology</code> クラスはトポロジ情報のデータベースです。<code>TopologyController</code> が生の OpenFlow メッセージから解釈したトポロジの変化を、ポート一覧、スイッチ一覧などのデータ構造として保存します。そして、変化イベントをオブザーバへ通知します。たとえば <code>add_switch</code> メソッドでは、新しいスイッチとポート一覧を登録し、オブザーバの <code>add_switch</code> メソッドを呼びます。</p>
</div>
<div class="listingblock">
<div class="title">Topology#add_switch (lib/topology.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_switch</span>(dpid, ports)
  ports.each { |each| add_port(each) }
  maybe_send_handler <span class="symbol">:add_switch</span>, dpid, <span class="predefined-constant">self</span>
<span class="keyword">end</span>

private

<span class="keyword">def</span> <span class="function">maybe_send_handler</span>(method, *args)
  <span class="instance-variable">@observers</span>.each <span class="keyword">do</span> |each|
    <span class="keyword">if</span> each.respond_to?(<span class="symbol">:update</span>)
      each.__send__ <span class="symbol">:update</span>, method, args[<span class="integer">0</span>..<span class="integer">-2</span>], args.last
    <span class="keyword">end</span>
    each.__send__ method, *args <span class="keyword">if</span> each.respond_to?(method)
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>スイッチのポート、スイッチにつながっているリンクなど、関連するもの同士は自動的に処理します。たとえば <code>delete_switch</code> メソッドでは、スイッチを消すだけでなくスイッチのポートやスイッチとつながるリンクもすべて消します。</p>
</div>
<div class="listingblock">
<div class="title">Topology#add_switch (lib/topology.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">delete_switch</span>(dpid)
  delete_port(<span class="instance-variable">@ports</span>[dpid].pop) <span class="keyword">until</span> <span class="instance-variable">@ports</span>[dpid].empty?
  <span class="instance-variable">@ports</span>.delete dpid
  maybe_send_handler <span class="symbol">:delete_switch</span>, dpid, <span class="predefined-constant">self</span>
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">delete_port</span>(port)
  <span class="instance-variable">@ports</span>[port.dpid].delete_if { |each| each.number == port.number }
  maybe_send_handler <span class="symbol">:delete_port</span>, <span class="constant">Port</span>.new(port.dpid, port.number), <span class="predefined-constant">self</span>
  maybe_delete_link port
<span class="keyword">end</span>

private

<span class="keyword">def</span> <span class="function">maybe_delete_link</span>(port)
  <span class="instance-variable">@links</span>.each <span class="keyword">do</span> |each|
    <span class="keyword">next</span> <span class="keyword">unless</span> each.connect_to?(port)
    <span class="instance-variable">@links</span> -= [each]
    port_a = <span class="constant">Port</span>.new(each.dpid_a, each.port_a)
    port_b = <span class="constant">Port</span>.new(each.dpid_b, each.port_b)
    maybe_send_handler <span class="symbol">:delete_link</span>, port_a, port_b, <span class="predefined-constant">self</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_15">15.5. まとめ</h3>
<div class="paragraph">
<p>ネットワークトポロジをOpenFlowで検出できる、トポロジコントローラの仕組みを見てきました。この章で学んだことを簡単にまとめておきましょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LLDP でトポロジを検出する仕組み</p>
</li>
<li>
<p>トポロジの変化を検出する OpenFlow メッセージとその処理の実装方法</p>
</li>
<li>
<p>オブザーバーパターンを使った外部クラスとの連携方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次の章では、ネットワーク仮想化の最初の一歩として、たくさんのスイッチを一台の L2 スイッチとして仮想化できる、ルーティングスイッチコントローラを見ていきます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="routing_switch">16. たくさんのスイッチを制御する</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>大規模なネットワークを構成するたくさんのスイッチを連携させ、うまく制御する仕組みを見て行きましょう。</p>
</div>
<div class="sect2">
<h3 id="_複数のスイッチを制御する">16.1. 複数のスイッチを制御する</h3>
<div class="paragraph">
<p>たくさんの OpenFlow スイッチがつながった環境では、パケットを目的地まで転送するためにスイッチを連携させる必要があります。複数の OpenFlow スイッチを連携し 1 台の大きな仮想スイッチにするコントローラが、本章で紹介するルーティングスイッチです (<a href="#fig_routing_switch">図 16-1</a>)。同じスイッチ機能を提供するコントローラとしては、<a href="#learning_switch">7 章</a>や<a href="#learning_switch13">8 章</a>で紹介したラーニングスイッチがありました。ラーニングスイッチとルーティングスイッチの大きな違いは、連携できるスイッチの台数です。ラーニングスイッチは OpenFlow スイッチを独立した 1 台のスイッチとして扱います。一方で、ルーティングスイッチは複数の OpenFlow スイッチを連携させることで、仮想的な 1 台のスイッチとして扱います。</p>
</div>
<div id="fig_routing_switch" class="imageblock">
<div class="content">
<img src="images/routing_switch/routing_switch.png" alt="routing switch">
</div>
<div class="title">図 16-1: ルーティングスイッチはたくさんの OpenFlow スイッチを連携し 1 台の仮想スイッチとして動作させる</div>
</div>
<div class="paragraph">
<p>注意すべきは、ルーティングスイッチはルータではなく、あくまでスイッチであるという点です。<strong>ルーティング</strong>スイッチという名前は、複数のOpenFlowスイッチを経由し、まさにルーティングするようにパケットを転送することから来ています。このようにスイッチ機能を実現するという点では、ラーニングスイッチとの機能的な違いはありません。ただし制御できるネットワーク規模の面では、ルーティングスイッチは複数の OpenFlow スイッチを扱えるという違いがあります。</p>
</div>
<div class="sect3">
<h4 id="_ルーティングスイッチの動作">16.1.1. ルーティングスイッチの動作</h4>
<div class="paragraph">
<p>ルーティングスイッチではたくさんのスイッチを接続するため、パケットの転送が複雑になります。宛先のホストまでいくつものスイッチを経由してパケットを届けなくてはならないため、宛先までの道順をスイッチに指示してやる必要があります。</p>
</div>
<div id="routing_switch_flow_mod" class="imageblock">
<div class="content">
<img src="images/routing_switch/routing_switch_flow_mod.png" alt="routing switch flow mod">
</div>
<div class="title">図 16-2: 最短パスでパケットを転送するフローエントリを書き込む</div>
</div>
<div class="paragraph">
<p>たとえば<a href="#routing_switch_flow_mod">図 16-2</a>において、ホスト 1 からホスト 4 へとパケットを送信する場合を考えてみましょう。もしパケットを最短のパスで届けたい場合、ホスト 1 → スイッチ 1 → スイッチ 5 → スイッチ 6 → ホスト 4 の順にパケットを転送します。ルーティングスイッチはこの転送をするフローエントリを最短パス上のスイッチ 1, 5, 6 へそれぞれ書き込みます。</p>
</div>
<div class="paragraph">
<p>このとき、実際にルーティングスイッチとスイッチ間でやりとりする OpenFlow メッセージは<a href="#routing_switch_packetin_flowmod_packetout">図 16-3</a>のようになります:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ホスト 1 がホスト 4 宛てにパケットを送信すると、ルーティングスイッチはこのパケットを Packet In としてスイッチ 1 から受け取る (この Packet In の in_port をポート s とする)</p>
</li>
<li>
<p>ルーティングスイッチはあらかじめ収集しておいたトポロジ情報 (<a href="#topology">15章</a>) を検索し、宛先のホスト 4 が接続するスイッチ (スイッチ 6) とポート番号 (ポート g とする) を得る</p>
</li>
<li>
<p>ポート s から宛先のポート g までの最短パスをトポロジ情報から計算する。その結果、ポート s → スイッチ 1 → スイッチ 5 → スイッチ 6 → ポート g というパスを得る</p>
</li>
<li>
<p>この最短パスに沿ってパケットを転送するフローエントリを書き込むために、ルーティングスイッチはパス上のスイッチそれぞれに Flow Mod を送る</p>
</li>
<li>
<p>Packet In を起こしたパケットを宛先に送るために、ルーティングスイッチはスイッチ 6 のポート g に Packet Out を送る</p>
</li>
</ol>
</div>
<div id="routing_switch_packetin_flowmod_packetout" class="imageblock">
<div class="content">
<img src="images/routing_switch/routing_switch_packetin_flowmod_packetout.png" alt="routing switch packetin flowmod packetout">
</div>
<div class="title">図 16-3: ルーティングスイッチでパケットを送信したときの OpenFlow メッセージ</div>
</div>
<div class="paragraph">
<p>ここで使っている OpenFlow メッセージはいずれも、今まで使ってきた Packet In や Flow Mod, Packet Out などおなじみの物ばかりです。以下ではステップ 3 で新たに登場した、最短パスの計算方法を詳しく見て行きましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_最短パスを計算する">16.2. 最短パスを計算する</h3>
<div class="paragraph">
<p>最短パスの計算でよく登場するのがダイクストラ法というアルゴリズムです。これは、出発点から目的地までの最短パスを求める汎用アルゴリズムの 1 つで、カーナビの経路検索や鉄道の乗換案内などにも使われています。</p>
</div>
<div class="paragraph">
<p>ダイクストラ法を使った最短パス計算のアルゴリズムは、基本的には次のとおりです。まず、出発点から 1 ホップで到達できるスイッチをすべて探します。次に、見つかったスイッチから出発して 1 ホップで行けるスイッチ、つまり最初の出発点から 2 ホップで到達できるスイッチをすべて探します。これを繰り返して、出発点から 3 ホップ、 4 ホップ……というように距離を広げながら次々とスイッチを探していきます。途中で目的地のスイッチに到達したら探索完了で、そこまでのパスを最短パスとして返します。<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnote_25" title="View footnote.">25</a>]</sup></p>
</div>
<div id="dijkstra" class="imageblock">
<div class="content">
<img src="images/routing_switch/dijkstra.png" alt="dijkstra">
</div>
<div class="title">図 16-4: 最短パスをダイクストラ法で計算する</div>
</div>
<div class="paragraph">
<p>実際に<a href="#routing_switch_flow_mod">図 16-2</a> のネットワークでスイッチ 1 からスイッチ 6 までの最短パスをダイクストラ法で探索する手順は<a href="#dijkstra">図 16-4</a> のようになります:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>始点となるスイッチ 1 を 0 ホップとする</p>
</li>
<li>
<p>スイッチ 1 から 1 ホップで行けるすべてのスイッチを見つける。これはスイッチ 1 から出るリンクの先に繋がっているスイッチ 2, 4, 5 である</p>
</li>
<li>
<p>同様にステップ 2 で見つかったスイッチから 1 ホップで行けるすべてのスイッチを探し、スイッチ 3, 6 が見つかる。これらは始点からのホップ数が 2 のスイッチである</p>
</li>
<li>
<p>ステップ 3 でゴールのスイッチ 6 が見つかったので探索を終わる。最短パスは最終的にスイッチ 1 → スイッチ 5 → スイッチ 6 とわかる</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_実行してみよう_11">16.3. 実行してみよう</h3>
<div class="paragraph">
<p>動作原理がわかったところで、実際のトポロジ検出や最短パス計算の動作をルーティングスイッチを起動し確認してみましょう。ルーティングスイッチは他のサンプルと同様、GitHub で公開しています。次のコマンドでソースコードを取得してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/routing_switch.git</pre>
</div>
</div>
<div class="paragraph">
<p>依存する gem のインストールは、いつも通り <code>bundle install</code> コマンドです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd routing_switch
$ bundle install --binstubs</pre>
</div>
</div>
<div class="paragraph">
<p>これで準備は完了です。</p>
</div>
<div class="sect3">
<h4 id="_ルーティングスイッチを動かす">16.3.1. ルーティングスイッチを動かす</h4>
<div class="paragraph">
<p>それでは、ルーティングスイッチを動かしてみましょう。Trema のネットワークエミュレータ機能を用いて、<a href="#routing_switch_sample_network">図 16-5</a> のネットワークを作ります。</p>
</div>
<div id="routing_switch_sample_network" class="imageblock">
<div class="content">
<img src="images/routing_switch/routing_switch_sample_network.png" alt="routing switch sample network">
</div>
<div class="title">図 16-5: ホスト 4 台、スイッチ 6 台からなるネットワーク</div>
</div>
<div class="paragraph">
<p>この構成を実現する設定ファイルは、ルーティングスイッチのソースツリーに入っています (<code>trema.conf</code>)。この設定ファイルを指定して、次のようにルーティングスイッチを起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_最短パスを通すフローエントリを確認する">16.3.2. 最短パスを通すフローエントリを確認する</h4>
<div class="paragraph">
<p>次に host1 と host4 の間でパケットを送受信し、最短パスを通すフローエントリがうまく設定されることを確認しましょう。ルーティングスイッチ起動直後は、まだ MAC アドレスの学習を行っていないので、host1 から host4 へとパケットを送っただけではフローエントリは設定されません。ラーニングスイッチと同じく、次のように両方向でパケットを送った段階でフローエントリが設定されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source host1 --dest host4
$ ./bin/trema send_packets --source host4 --dest host1
$ ./bin/trema send_packets --source host1 --dest host4</pre>
</div>
</div>
<div class="paragraph">
<p>すると、ルーティングスイッチを起動したターミナルには host4 → host1 と host1 → host4 の 2 つの最短パスを発見した、というメッセージが表示されているはずです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Creating path: 44:44:44:44:44:44 -&gt; 0x6:1 -&gt; 0x6:2 -&gt; 0x5:5 -&gt; 0x5:2 -&gt; 0x1:4 -&gt; 0x1:1 -&gt; 11:11:11:11:11:11
Creating path: 11:11:11:11:11:11 -&gt; 0x1:1 -&gt; 0x1:4 -&gt; 0x5:2 -&gt; 0x5:5 -&gt; 0x6:2 -&gt; 0x6:1 -&gt; 44:44:44:44:44:44</pre>
</div>
</div>
<div class="paragraph">
<p>実際にどのようなフローエントリが設定されたか見てみましょう。フローエントリの確認は <code>trema dump_flows</code> コマンドです。まずは host1 から host4 への最短パスである switch1, switch5, switch6 のフローテーブルをそれぞれ見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema dump_flows switch1
cookie=0x0, duration=8.949s, table=0, n_packets=0, n_bytes=0, idle_age=8, priority=65535,udp,in_port=4,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1
cookie=0x0, duration=4.109s, table=0, n_packets=0, n_bytes=0, idle_age=4, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:4
$ ./bin/trema dump_flows switch5
cookie=0x0, duration=14.230s, table=0, n_packets=0, n_bytes=0, idle_age=14, priority=65535,udp,in_port=5,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
cookie=0x0, duration=9.320s, table=0, n_packets=0, n_bytes=0, idle_age=9, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:5
$ ./bin/trema dump_flows switch6
cookie=0x0, duration=18.688s, table=0, n_packets=0, n_bytes=0, idle_age=18, priority=65535,udp,in_port=1,vlan_tci=0x0000,dl_src=44:44:44:44:44:44,dl_dst=11:11:11:11:11:11,nw_src=192.168.0.4,nw_dst=192.168.0.1,nw_tos=0,tp_src=0,tp_dst=0 actions=output:2
cookie=0x0, duration=13.723s, table=0, n_packets=0, n_bytes=0, idle_age=13, priority=65535,udp,in_port=2,vlan_tci=0x0000,dl_src=11:11:11:11:11:11,dl_dst=44:44:44:44:44:44,nw_src=192.168.0.1,nw_dst=192.168.0.4,nw_tos=0,tp_src=0,tp_dst=0 actions=output:1</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに switch1, switch5, switch6 それぞれについて、host1 と host4 間の 2 つの最短パス用のフローエントリが設定されています。</p>
</div>
<div class="paragraph">
<p>一方で、最短パス上にない switch2, switch3, switch4 はパケットが通らないため、次のようにフローエントリがありません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema dump_flows switch2

$ ./bin/trema dump_flows switch3

$ ./bin/trema dump_flows switch4</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_最短パスの再計算を確認する">16.3.3. 最短パスの再計算を確認する</h4>
<div class="paragraph">
<p>トポロジ上のリンクが切れた場合、ルーティングスイッチは自動的に最短パスを作り直します。たとえば<a href="#routing_switch_sample_network">図 16-5</a> において、switch1 と switch5 の間のリンクが切れた場合を考えます。このときルーティングスイッチは古い最短パス (host1 ⇔ switch1 ⇔ switch5 ⇔ switch6 ⇔ host4) のフローエントリを消します。そして、再び host1 が host2 へパケットを送ったタイミングで、ルーティングスイッチは新しい最短パス (host1 → switch1 → switch4 → switch5 → switch6) を作ります (<a href="#routing_switch_update_shortest_path">図 16-6</a>)。</p>
</div>
<div id="routing_switch_update_shortest_path" class="imageblock">
<div class="content">
<img src="images/routing_switch/routing_switch_update_shortest_path.png" alt="routing switch update shortest path">
</div>
<div class="title">図 16-6: 最短パスの作り直し</div>
</div>
<div class="paragraph">
<p>この動作も実際に動かして確認してみましょう。リンクの削除は <code>trema delete_link</code> コマンドです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema delete_link switch1 switch5</pre>
</div>
</div>
<div class="paragraph">
<p>すると、ルーティングスイッチを起動したターミナルには host1 ⇔ host4 の 2 つの最短パスを削除したというメッセージが表示されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Deleting path: 44:44:44:44:44:44 -&gt; 0x6:1 -&gt; 0x6:2 -&gt; 0x5:5 -&gt; 0x5:2 -&gt; 0x1:4 -&gt; 0x1:1 -&gt; 11:11:11:11:11:11
Deleting path: 11:11:11:11:11:11 -&gt; 0x1:1 -&gt; 0x1:4 -&gt; 0x5:2 -&gt; 0x5:5 -&gt; 0x6:2 -&gt; 0x6:1 -&gt; 44:44:44:44:44:44</pre>
</div>
</div>
<div class="paragraph">
<p>再び host1 から host4 へパケットを送ってみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packets --source host1 --dest host4</pre>
</div>
</div>
<div class="paragraph">
<p>すると次のように、ルーティングスイッチを起動したターミナルには host1 → host4 の新たな最短パスが表示されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Creating path: 11:11:11:11:11:11 -&gt; 0x1:1 -&gt; 0x1:3 -&gt; 0x4:2 -&gt; 0x4:3 -&gt; 0x5:4 -&gt; 0x5:5 -&gt; 0x6:2 -&gt; 0x6:1 -&gt; 44:44:44:44:44:44</pre>
</div>
</div>
<div class="paragraph">
<p>以上でルーティングスイッチの最短パス計算と再計算の動作を見てきました。いよいよソースコードを読んでみましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ルーティングスイッチのソースコード">16.4. ルーティングスイッチのソースコード</h3>
<div class="paragraph">
<p>ルーティングスイッチは次の 4 つのクラスが協調して動作します (<a href="#routing_switch_classes">図 16-7</a>)。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">RoutingSwitch クラス</dt>
<dd>
<p>スイッチから届く OpenFlow メッセージを振り分けます。OpenFlow スイッチと接続し、スイッチから上がってくる OpenFlow メッセージをその種類に応じて Topology または PathManager へと振り分けます</p>
</dd>
<dt class="hdlist1">TopologyController, Topology クラス (<a href="#topology">15 章</a>で紹介)</dt>
<dd>
<p>トポロジの変化イベントを PathManager へ通知します。トポロジ情報の変化に関連する OpenFlow メッセージを RoutingSwitch から受け取り、ネットワークトポロジ上のイベントへ変換し PathManager へ渡します</p>
</dd>
<dt class="hdlist1">PathManager クラス</dt>
<dd>
<p>ルーティングスイッチの本体です。RoutingSwitch から Packet In メッセージを受け取ると、Topology から受け取るトポロジ情報を元に最短パスを計算し、Path クラスを通じて新しい最短パスをスイッチに反映します</p>
</dd>
<dt class="hdlist1">Path クラス</dt>
<dd>
<p>パスの生成と削除に必要なフローエントリの操作を一手に引き受けます。FlowMod や FlowModDelete といった OpenFlow メッセージの詳細を PathManager から隠蔽します</p>
</dd>
</dl>
</div>
<div id="routing_switch_classes" class="imageblock">
<div class="content">
<img src="images/routing_switch/routing_switch_classes.png" alt="routing switch classes">
</div>
<div class="title">図 16-7: ルーティングスイッチのクラス構成</div>
</div>
<div class="paragraph">
<p>複雑な機能を持つコントローラは、このように機能を小さなクラスに分割することでスッキリと書けます。LLDP の送受信といったトポロジ検出処理は Topology クラスに、FlowMod といったフローエントリの処理は Path クラスにそれぞれまかせ、そして PathManager クラスが全体をとりまとめることで見通しが良くなりテストもしやすくなります。もし新しく機能を追加したくなった場合にも、既存のコードは改造せず新機能に対応するクラスを追加するだけです<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnote_26" title="View footnote.">26</a>]</sup>。</p>
</div>
<div class="sect3">
<h4 id="_routingswitch_クラスのソースコード_routing_switch_rb">16.4.1. RoutingSwitch クラスのソースコード (routing_switch.rb)</h4>
<div class="paragraph">
<p>RoutingSwitch クラスは委譲パターンによって各 OpenFlow メッセージを他のクラスへと振り分けます。</p>
</div>
<div class="listingblock">
<div class="title">lib/routing_switch.rb</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby">delegate <span class="symbol">:switch_ready</span>, <span class="key">to</span>: <span class="symbol">:@topology</span>
delegate <span class="symbol">:features_reply</span>, <span class="key">to</span>: <span class="symbol">:@topology</span>
delegate <span class="symbol">:switch_disconnected</span>, <span class="key">to</span>: <span class="symbol">:@topology</span>
delegate <span class="symbol">:port_modify</span>, <span class="key">to</span>: <span class="symbol">:@topology</span>

<span class="keyword">def</span> <span class="function">packet_in</span>(dpid, packet_in)
  <span class="instance-variable">@topology</span>.packet_in(dpid, packet_in)
  <span class="instance-variable">@path_manager</span>.packet_in(dpid, packet_in) <span class="keyword">unless</span> packet_in.lldp?
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>たとえば Topology クラスへ switch_ready イベントを転送するには、<code>delegate</code> メソッドを使って Topology クラスのインスタンスへ <code>switch_ready</code> メソッドを委譲します。なお packet_in イベントは Topology と PathManager の両方に届ける必要があるため、packet_in ハンドラの中で明示的にそれぞれの packet_in メソッドを呼び出すことで転送しています。</p>
</div>
</div>
<div class="sect3">
<h4 id="_pathmanager_のソースコード_path_manager_rb">16.4.2. PathManager のソースコード (path_manager.rb)</h4>
<div class="paragraph">
<p>PathManager は、Topology クラスとObserverパターンで連携します。TopologyクラスはRoutingSwitchクラスから上がってくる生のOpenFlowメッセージをトポロジ上の変化イベント(スイッチ・ポート・リンクの追加/削除とホストの追加)へと変換し、オブザーバである PathManager クラスのトポロジイベントハンドラを呼び出します。</p>
</div>
<div class="listingblock">
<div class="title">PathManager クラスのトポロジイベントハンドラ (lib/path_manager.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">add_port</span>(port, _topology)
  <span class="instance-variable">@graph</span>.add_link port.dpid, port
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">delete_port</span>(port, _topology)
  <span class="instance-variable">@graph</span>.delete_node port
<span class="keyword">end</span>

<span class="comment"># TODO: update all paths</span>
<span class="keyword">def</span> <span class="function">add_link</span>(port_a, port_b, _topology)
  <span class="instance-variable">@graph</span>.add_link port_a, port_b
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">delete_link</span>(port_a, port_b, _topology)
  <span class="instance-variable">@graph</span>.delete_link port_a, port_b
  <span class="constant">Path</span>.find { |each| each.link?(port_a, port_b) }.each(&amp;<span class="symbol">:destroy</span>)
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">add_host</span>(mac_address, port, _topology)
  <span class="instance-variable">@graph</span>.add_link mac_address, port
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>PathManager はトポロジイベントを受け取ると、インスタンス変数 <code>@graph</code> として持つ現在のネットワークグラフを更新します。たとえばLLDPによって新しいリンクを発見すると、Topology はトポロジイベント <code>add_link</code> を PathManager へ送ります。そして PathManager は新しく見つかったリンクを <code>@graph</code> へ追加します。</p>
</div>
<div class="paragraph">
<p>PathManager は <code>packet_in</code> イベントに反応し、届いたパケットを宛先へと届けます。</p>
</div>
<div class="listingblock">
<div class="title">PathManager#packet_in</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(_dpid, packet_in)
  path = maybe_create_shortest_path(packet_in)
  ports = path ? [path.out_port] : <span class="instance-variable">@graph</span>.external_ports
  ports.each <span class="keyword">do</span> |each|
    send_packet_out(each.dpid,
                    <span class="key">raw_data</span>: packet_in.raw_data,
                    <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(each.number))
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">maybe_create_shortest_path</span>(packet_in)
  shortest_path =
    <span class="instance-variable">@graph</span>.dijkstra(packet_in.source_mac, packet_in.destination_mac)
  <span class="keyword">return</span> <span class="keyword">unless</span> shortest_path
  <span class="constant">Path</span>.create shortest_path, packet_in
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>packet_in</code> ハンドラの動作は<a href="#path_manager_internals">図 16-6</a> の通りです:</p>
</div>
<div id="path_manager_internals" class="imageblock">
<div class="content">
<img src="images/routing_switch/path_manager_internals.png" alt="path manager internals">
</div>
<div class="title">図 16-6: PathManager の仕組み</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>グラフ情報から送信元→宛先への最短パスを計算する。もし最短パスが見つかった場合には、最短パス上のスイッチにフローエントリを <code>Path.create</code> で打つ</p>
</li>
<li>
<p>最短パスが見つかった場合には、宛先ポートにPacketOutすることでPacketInを起こしたパケットを宛先へ届ける。見つからなかった場合には、パケットをすべての外部ポート (外部と接続しているポート) へPacketOutする</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_path_のソースコード_path_rb">16.4.3. Path のソースコード (path.rb)</h4>
<div class="paragraph">
<p>Path クラスはパスの生成と削除に必要なフローエントリの操作を一手に引き受けます。たとえば、パスを生成するメソッド <code>Path.create</code> の実装は次のようになっています:</p>
</div>
<div class="listingblock">
<div class="title">Path.create (lib/path.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="predefined-constant">self</span>.<span class="function">create</span>(shortest_path, packet_in)
  new.save(shortest_path, packet_in).tap { |new_path| all &lt;&lt; new_path }
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">save</span>(full_path, packet_in)
  <span class="instance-variable">@full_path</span> = full_path
  <span class="instance-variable">@packet_in</span> = packet_in
  logger.info <span class="string"><span class="delimiter">'</span><span class="content">Creating path: </span><span class="delimiter">'</span></span> + <span class="instance-variable">@full_path</span>.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string"><span class="delimiter">'</span><span class="content"> -&gt; </span><span class="delimiter">'</span></span>)
  flow_mod_add_to_each_switch
  <span class="predefined-constant">self</span>
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">flow_mod_add_to_each_switch</span>
  path.each_slice(<span class="integer">2</span>) <span class="keyword">do</span> |in_port, out_port|
    send_flow_mod_add(out_port.dpid,
                      <span class="key">match</span>: exact_match(in_port.number),
                      <span class="key">actions</span>: <span class="constant">SendOutPort</span>.new(out_port.number))
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>PathManager が <code>Path.create</code> を呼び出すと、<code>Path</code> クラスのインスタンスメソッド <code>save</code> を呼び出します。<code>save</code> メソッドでは最短パスに沿ってフローエントリを <code>flow_mod_add_to_each_switch</code> メソッドでスイッチに書き込みます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_openflow_を使う利点">16.5. OpenFlow を使う利点</h3>
<div class="paragraph">
<p>本章のはじめで説明したように、ルーティングスイッチは OpenFlow ネットワークを 1 台の仮想的なスイッチとして動作させるコントローラです。普通のスイッチを真似るだけならば、わざわざ OpenFlow を使わなくてもよいのでは? と思うかもしれません。ここでは、OpenFlow を使った場合の利点について考えてみたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_リンク帯域を有効活用できる">16.5.1. リンク帯域を有効活用できる</h4>
<div class="paragraph">
<p>通常のスイッチで構成されたネットワークでは、パケットのループを防ぐためにスパニングツリープロトコルでリンクの一部を遮断します。たとえば、<a href="#spt1">図 16-7</a>のようなループを含むネットワークでスパニングツリープロトコルを使うと、スイッチ2とスイッチ3間のリンクが遮断されループが解消します。このとき、たとえばホスト2からホスト3へのパケットは、この遮断されたリンクを通過できないため、スイッチ1を経由して転送します。これは明かに無駄な回り道で、せっかくのリンク帯域が無駄になっています。</p>
</div>
<div id="spt1" class="imageblock">
<div class="content">
<img src="images/routing_switch/spt1.png" alt="spt1">
</div>
<div class="title">図 16-7: スパニングツリーではループを避けるために一部のリンクを遮断する</div>
</div>
<div class="paragraph">
<p>一方、ルーティングスイッチではコントローラがトポロジ全体を把握しているため、ループを防ぐためのリンク遮断は必要ありません。パケットの転送経路を各スイッチにフローエントリとして明示的に指示するため、ループを含むトポロジであっても問題なく動作します。このためスパニングツリーを使う場合と比べて、ネットワーク中のリンクを有効に使えます（<a href="#spt2">図 16-8</a>）。</p>
</div>
<div id="spt2" class="imageblock">
<div class="content">
<img src="images/routing_switch/spt2.png" alt="spt2">
</div>
<div class="title">図 16-8: ルーティングスイッチではネットワーク中のリンクを有効に使える</div>
</div>
</div>
<div class="sect3">
<h4 id="_いろいろなパス選択アルゴリズムを使える">16.5.2. いろいろなパス選択アルゴリズムを使える</h4>
<div class="paragraph">
<p>パスの決定はコントローラで一括して行なうため、パス決定アルゴリズムを入れ替えるだけで、さまざまなパス選択を実現できます。今回、ルーティングスイッチではダイクストラ法による最短パスを使いましたが、たとえば<a href="#multipath">図 16-9</a>のようにフロー毎に異なるパスを設定することで、帯域確保のためのマルチパスを作ることも簡単にできます。</p>
</div>
<div id="multipath" class="imageblock">
<div class="content">
<img src="images/routing_switch/multipath.png" alt="multipath">
</div>
<div class="title">図 16-9: OpenFlowでは最短でないパスを含んだマルチパスを自由に作れる</div>
</div>
<div class="paragraph">
<p>このようなマルチパスは従来の自律分散型でも実現できますが、厳しい制限があります。IETFが標準化を行うTRILL（Transparent Interconnect of Lots of Links）や IEEE が標準化を行う SPB（Shortest Path Bridges）は、マルチパス転送に対応しています。しかし、マルチパス転送を使えるのは、最短パスが複数ある場合<sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnote_27" title="View footnote.">27</a>]</sup>だけです。最短ではないパスは、ループを起こす可能性があるため使えません。また最短パスが1本だけの場合にもマルチパスにできません。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_16">16.6. まとめ</h3>
<div class="paragraph">
<p>いくつものスイッチからなるネットワークを扱える、ルーティングスイッチの動作を見てきました。この章で学んだことを簡単にまとめておきましょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>パケットを最短パスで宛先まで届ける方法。ダイクストラ法を使って最短パスを求め、最短パス上のスイッチにフローエントリを書き込む</p>
</li>
<li>
<p>複数のクラスを連携しコントローラを実装する方法。メソッドの移譲やオブザーバーパターンを使い、機能ごとに分割したクラスを組み合わせる</p>
</li>
<li>
<p>OpenFlowを使う場合の利点。すべてのリンクを使うことで帯域を有効活用できるほか、マルチパスなどのパス選択アルゴリズムを自由に使える</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次の章では、ネットワーク仮想化を実現する本格的なコントローラの一例として、ルーティングスイッチを発展させたスライス機能付きスイッチを見ていきます。</p>
</div>
<div class="sect3">
<h4 id="_参考文献_3">16.6.1. 参考文献</h4>
<div class="ulist">
<ul>
<li>
<p>『最短経路の本——レナのふしぎな数学の旅』（Peter Gritzmann、Rene Brandenberg 著／シュプリンガー・ジャパン） 最短経路を題材にしたストーリ仕立てのグラフ理論入門書です。本章ではネットワーク上での最短パスを求める場合のダイクストラ法を紹介しましたが、リンクに重みがある場合の一般的なダイクストラ法についてはこの本がおすすめです。</p>
</li>
<li>
<p>『マスタリングTCP/IP 応用編』（Philip Miller 著／オーム社 とくにレイヤ3の経路制御プロトコルについて詳しく説明した本です。ダイクストラ法を用いた経路制御プロトコルの1つであるOSPFについても説明しているので、ルーティングスイッチとの違いを比べてみるのもおもしろいでしょう。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sliceable_switch">17. ネットワークを仮想化する</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>IaaS (Infrastructure as a Service) の構築に必要な大規模ネットワークを OpenFlow で実現しましょう。<a href="#routing_switch">16 章</a>で紹介したルーティングスイッチの応用です。</p>
</div>
<div class="sect2">
<h3 id="_ネットワークをスライスに分ける">17.1. ネットワークをスライスに分ける</h3>
<div class="paragraph">
<p>クラウドサービスの核となる機能は仮想化です。たとえばクラウドサービスの一種である IaaS は、サーバやネットワークといった物理リソースを仮想化し、まるで雲 (クラウド) のように大きな仮想リソースとしてユーザに提供します。ユーザは自分専用のリソースをこの仮想リソースプールからいつでも好きなときに借り出せます。</p>
</div>
<div class="paragraph">
<p>クラウドサービスが制御する物理リソースのうち、ネットワークの仮想化は OpenFlow の得意分野です。物理リソースのうちサーバの仮想化は、Xen などの仮想マシンモニタを使えば、一台のサーバ上に何台もの仮想マシンを起動することで多数のユーザを集約できます。もう1つの物理リソースであるネットワークの仮想化については、後に説明するように OpenFlow コントローラで同様の仕組みを実現できます。この 2 つの組み合わせにより、クラウドサービスは「仮想マシン + 仮想ネットワーク」という専用環境をユーザごとに提供します。</p>
</div>
<div class="paragraph">
<p>本章で取り上げる「スライス機能付きスイッチ」は、ネットワークを仮想化するコントローラです (<a href="#slice">図 17-1</a>)。1つの物理ネットワークをたくさんのスライス、つまりユーザごとの論理的なネットワークに分割することで、たくさんのユーザを1つの物理ネットワーク上に集約できます。</p>
</div>
<div id="slice" class="imageblock">
<div class="content">
<img src="images/sliceable_switch/slice.png" alt="slice">
</div>
<div class="title">図 17-1: スライス機能付きスイッチは 1 つの物理ネットワークをたくさんの独立した仮想ネットワークに分割できる</div>
</div>
</div>
<div class="sect2">
<h3 id="_スライスの実現方法">17.2. スライスの実現方法</h3>
<div class="paragraph">
<p>スライスを実現する代表的な既存技術が VLANです。VLAN はスイッチをポート単位や MAC アドレス単位でスライスに分割できます。また VLAN タグと呼ばれる ID をパケットにつけることでスイッチをまたがったスライスも作れます。</p>
</div>
<div class="paragraph">
<p>ただし、VLAN にはスライス数の上限が 4094 個というプロトコル上の制約があります。このため、オフィスなどといった中小規模ネットワークではともかく、IaaS のようにユーザ数がゆうに数万を越える場合には使えません。</p>
</div>
<div class="paragraph">
<p>一方 OpenFlow によるスライスではこの制約はありません。フローエントリをうまく使えば、既存の VLAN の仕組みを使わなくてもスライスを実現できるからです。つまり OpenFlow を使えば、「スライス数に制限のない仮想ネットワーク」を作れます。</p>
</div>
<div class="paragraph">
<p>スライス機能付きスイッチは OpenFlow によるスライスの実装です。これは<a href="#routing_switch">15章</a>で紹介したルーティングスイッチを改造することにより、上限なくたくさんのスライスを作れるようにしたものです。また、実際に OpenStack などのクラウド構築ミドルウェアの一部として使うことも考慮しており、REST API を通じてスライスの作成/削除などの操作ができます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_インストール_3">17.3. インストール</h3>
<div class="paragraph">
<p>スライス機能付きスイッチを使って、ネットワーク仮想化を実際に試してみましょう。スライス機能付きスイッチのソースコードはルーティングスイッチのリポジトリに入っています。もしルーティングスイッチをまだインストールしていなければ、次のコマンドでインストールしてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git clone https://github.com/trema/routing_switch.git
$ cd routing_switch
$ bundle install --binstubs</pre>
</div>
</div>
<div class="sect3">
<h4 id="_スライス機能付きスイッチを起動する">17.3.1. スライス機能付きスイッチを起動する</h4>
<div class="paragraph">
<p>スライス機能付きスイッチの動作を確認してみましょう。これまで通り Trema のネットワークエミュレータを用いて、<a href="#sliceable_switch_network">図 17-2</a> のネットワークを作ります。ルーティングスイッチのソースコードに含まれる設定ファイル (<code>trema.conf</code>) を使えば、このネットワーク構成を実現できます。</p>
</div>
<div id="sliceable_switch_network" class="imageblock">
<div class="content">
<img src="images/sliceable_switch/sliceable_switch_network.png" alt="sliceable switch network">
</div>
<div class="title">図 17-2: スライス機能付きスイッチを実行するネットワーク</div>
</div>
<div class="paragraph">
<p>スライス機能を有効にするには、ルーティングスイッチの <code>trema run</code> に <code>-- --slicing</code> オプションを付けてください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf -- --slicing</pre>
</div>
</div>
<div class="paragraph">
<p>それでは起動したスライス機能付きスイッチを使って、さっそくいくつかスライスを作ってみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_スライスを作る">17.3.2. スライスを作る</h4>
<div class="paragraph">
<p>スライスの作成には <code>slice</code> コマンドを使います。2 枚のスライス <code>slice1</code>、 <code>slice2</code> を作り、それぞれに 2 台ずつホストを追加してみましょう (<a href="#creating_slices">図 17-3</a>)。</p>
</div>
<div id="creating_slices" class="imageblock">
<div class="content">
<img src="images/sliceable_switch/creating_slices.png" alt="creating slices">
</div>
<div class="title">図 17-3: スライスの作成例</div>
</div>
<div class="paragraph">
<p>スライスの追加は <code>slice add</code> コマンドです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/slice add slice1
$ ./bin/slice add slice2</pre>
</div>
</div>
<div class="paragraph">
<p><code>slice add_host</code> コマンドでスライスにホストを追加します。<code>host1</code>、<code>host4</code> のポートと MAC アドレスを <code>slice1</code> に、<code>host2</code> と <code>host3</code> を <code>slice2</code> に、それぞれ追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/slice add_host --port 0x1:1 --mac 11:11:11:11:11:11 --slice slice1
$ ./bin/slice add_host --port 0x6:1 --mac 44:44:44:44:44:44 --slice slice1
$ ./bin/slice add_host --port 0x4:1 --mac 22:22:22:22:22:22 --slice slice2
$ ./bin/slice add_host --port 0x5:1 --mac 33:33:33:33:33:33 --slice slice2</pre>
</div>
</div>
<div class="paragraph">
<p>ネットワークがスライスにうまく分割できているか、パケットを送って確認してみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_スライスを確認する">17.3.3. スライスを確認する</h4>
<div class="paragraph">
<p>スライスが正しく動作しているか確認するには、次の 2 つを試せば OK です。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>同じスライスに属するホスト間で通信できること</p>
</li>
<li>
<p>異なるスライスに属するホスト間で通信できないこと</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>これは今までやってきた通り、<code>trema send_packet</code> と <code>trema show_stats</code> コマンドで簡単に確認できます。たとえば同じスライス <code>slice1</code> に属するホスト <code>host1</code> と <code>host4</code> で通信できることを確認するには、お互いにパケットを 1 つずつ送信し、それぞれのホストでパケットを 1 つずつ受信できているかどうかを見ます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema send_packet --source host1 --dest host4
$ ./bin/trema send_packet --source host4 --dest host1
$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.4 = 1 packet
Packets received:
  192.168.0.4 -&gt; 192.168.0.1 = 1 packet
$ ./bin/trema show_stats host4
Packets sent:
  192.168.0.4 -&gt; 192.168.0.1 = 1 packet
Packets received:
  192.168.0.1 -&gt; 192.168.0.4 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに問題なく通信できています。それでは異なるスライス間での通信はどうでしょう。同様に調べてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema reset_stats host1
$ ./bin/trema send_packet --source host1 --dest host2
$ ./bin/trema send_packet --source host2 --dest host1
$ ./bin/trema show_stats host1
Packets sent:
  192.168.0.1 -&gt; 192.168.0.2 = 1 packet
$ ./bin/trema show_stats host2
Packets sent:
  192.168.0.2 -&gt; 192.168.0.1 = 1 packet</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに、<code>slice1</code> の <code>host1</code> から <code>slice2</code> の <code>host2</code> へのパケットは届いていません。以上から、1 つのネットワークが 2 つの独立したスライスにうまく分割できていることが確認できました。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rest_api_を使う">17.4. REST API を使う</h3>
<div class="paragraph">
<p>スライス機能付きスイッチは OpenStack などのミドルウェアと連携するための REST API を提供しています。REST API はプログラミング言語を問わず使えるため、スライス機能付きスイッチの持つ仮想ネットワーク機能をさまざまなミドルウェアに簡単に組込めます。</p>
</div>
<div class="paragraph">
<p>スライス機能付きスイッチの REST API は Ruby の HTTP サーバ実装である WEBrick で動作します （<a href="#rest_overview">図17-4</a>)。WEBrick に「スライスの作成」や「ホストの追加」といったリクエストを HTTP で送ると、WEBrick はリクエスト内容をスライス機能付きスイッチ経由でネットワークへと反映します。また、現在のスライスやホストの状態も同様に REST API 経由で取得できます。</p>
</div>
<div id="rest_overview" class="imageblock">
<div class="content">
<img src="images/sliceable_switch/rest_overview.png" alt="rest overview">
</div>
<div class="title">図17-4: スライス機能付きスイッチの REST API 構成</div>
</div>
<div class="paragraph">
<p>REST API の起動は次のコマンドです。スライス機能付きスイッチを起動した後に <code>rackup</code> コマンドで WEBrick を起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./bin/trema run ./lib/routing_switch.rb -c trema.conf -d -- --slicing
$ ./bin/rackup</pre>
</div>
</div>
<div class="paragraph">
<p>それでは実際にいくつか REST API を試してみましょう。</p>
</div>
<div class="sect3">
<h4 id="_rest_api_でスライスを作る">17.4.1. REST API でスライスを作る</h4>
<div class="paragraph">
<p>REST API 経由でスライスを作るには、スライスの情報が入った JSON を HTTP POST で REST サーバに送ります。たとえば yutaro_slice という名前のスライスを作る JSON は次の通りです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{"name": "yutaro_slice"}</pre>
</div>
</div>
<div class="paragraph">
<p>次にこの JSON を /slices という URI に HTTP POST メソッドで送ります。<code>curl</code> コマンドを使えば、次のように手軽に REST サーバとやりとりできます。なお REST サーバである WEBrick のデフォルト待ち受けポートは 9292 です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -sS -X POST -d ’{"name": "yutaro_slice"}’ 'http://localhost:9292/slices' -H Content-Type:application/json -v</pre>
</div>
</div>
<div class="paragraph">
<p>成功すると次のようにスライスの作成成功を示す HTTP ステータスコード 201 が返ってきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9292 (#0)
&gt; POST /slices HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:9292
&gt; Accept: */*
&gt; Content-Type:application/json
&gt; Content-Length: 21
&gt;
* upload completely sent off: 21 out of 21 bytes
&lt; HTTP/1.1 201 Created <i class="conum" data-value="1"></i><b>(1)</b>
&lt; Content-Type: application/json
&lt; Content-Length: 21
* Server WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27) is not blacklisted
&lt; Server: WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27)
&lt; Date: Mon, 30 Mar 2015 08:15:22 GMT
&lt; Connection: Keep-Alive
&lt;
* Connection #0 to host localhost left intact
{"name": "yutaro_slice"}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>スライス作成成功を示す HTTP ステータスコード 201</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_スライスにホストを追加する">17.4.2. スライスにホストを追加する</h4>
<div class="paragraph">
<p>作ったスライスにはホストを追加できます。追加するホストを指定するには、ホストのつながっているスイッチの dpid とポート番号、そしてホストの MAC アドレスを使います。これをホスト追加の URI である <code>/slices/:slice_id/ports/:port_id/mac_addresses</code> に HTTP POST メソッドで送ります。たとえば、スライス <code>yutaro_slice</code> に dpid = 0x1, ポート番号 = 1, MAC アドレス = 11:11:11:11:11:11 のホストを追加するコマンドは次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -sS -X POST -d ’{"name": "11:11:11:11:11:11"}’ 'http://localhost:9292/slices/yutaro_slice/ports/0x1:1/mac_addresses' -H Content-Type:application/json -v</pre>
</div>
</div>
<div class="paragraph">
<p>次のようにホスト追加の成功を示す HTTP ステータスコード 201 が返ってくれば成功です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>[{"name": "11:11:11:11:11:11"}]
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9292 (#0)
&gt; POST /slices/foo/ports/0x1:1/mac_addresses HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:9292
&gt; Accept: */*
&gt; Content-Type:application/json
&gt; Content-Length: 29
&gt;
} [data not shown]
* upload completely sent off: 29 out of 29 bytes
&lt; HTTP/1.1 201 Created <i class="conum" data-value="1"></i><b>(1)</b>
&lt; Content-Type: application/json
&lt; Content-Length: 31
* Server WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27) is not blacklisted
&lt; Server: WEBrick/1.3.1 (Ruby/2.0.0/2014-10-27)
&lt; Date: Tue, 31 Mar 2015 00:20:45 GMT
&lt; Connection: Keep-Alive
&lt;
{ [data not shown]
* Connection #0 to host localhost left intact</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ホスト追加成功を示す HTTP ステータスコード 201</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_スライスの構成を見る">17.4.3. スライスの構成を見る</h4>
<div class="paragraph">
<p>これまでの設定がきちんと反映されているか確認してみましょう。<code>/slices/:slice_id/ports</code> に HTTP GET メソッドでアクセスすることで、スライスに追加したポート一覧を取得できます。先ほど作った <code>slice_yutaro</code> スライスの情報を取得してみましょう<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnote_28" title="View footnote.">28</a>]</sup>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -sS -X GET 'http://localhost:9292/slices/yutaro_slice/ports'
[{"name": "0x1:1", "dpid": 1, "port_no": 1}]</pre>
</div>
</div>
<div class="paragraph">
<p>たしかに、スライス <code>yutaro_slice</code> にはスイッチ <code>0x1</code> のポート 1 番が追加されています。このポートに接続した <code>host1</code> の情報は <code>/slices/:slice_id/ports/:port_id/mac_addresses</code> で取得できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -sS -X GET 'http://localhost:9292/slices/yutaro_slice/ports/0x1:1/mac_addresses'
[{"name": "11:11:11:11:11:11"}]</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rest_api_一覧">17.5. REST API 一覧</h3>
<div class="paragraph">
<p>REST API は今回紹介した以外にも API を提供しています (<a href="#rest_api_table">表 17-1</a>)。やりとりする JSON データ等の詳しい仕様は <a href="https://relishapp.com/trema/routing-switch/docs/rest-api" class="bare">https://relishapp.com/trema/routing-switch/docs/rest-api</a> で公開していますので、本格的に使いたい人はこちらも参照してください。</p>
</div>
<table id="rest_api_table" class="tableblock frame-all grid-all spread">
<caption class="title">Table 21. 表 17-1: REST API 一覧</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">動作</th>
<th class="tableblock halign-left valign-top">メソッド</th>
<th class="tableblock halign-left valign-top">URI</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">スライスの作成</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">スライスの削除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">スライスの一覧</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">スライス情報の取得</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ポートの追加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ポートの削除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports/:port_id</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ポートの一覧</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ポート情報の取得</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports/:port_id</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAC アドレスの追加</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports/:port_id/mac_addresses</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAC アドレスの削除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports/:port_id/mac_addresses/:mac_address_id</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAC アドレスの一覧</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/slices/:slice_id/ports/:port_id/mac_addresses</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_スライス機能付きスイッチの実装">17.6. スライス機能付きスイッチの実装</h3>
<div class="paragraph">
<p>実はスライス機能は、<a href="#routing_switch">15章</a>で説明したルーティングスイッチへのほんの少しの改造だけで実現しています。コントローラとOpenFlowスイッチの視点で見ると、スライス機能付きスイッチは次のように動作します（<a href="#sliceable_switch_internals">図17-5</a>）。</p>
</div>
<div id="sliceable_switch_internals" class="imageblock">
<div class="content">
<img src="images/sliceable_switch/sliceable_switch_internals.png" alt="sliceable switch internals">
</div>
<div class="title">図 17-5: スライス機能付きスイッチの動作</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ホスト 1 がホスト 4 宛てにパケットを送信すると、ルーティングスイッチはこのパケットを Packet In としてスイッチ 1 から受け取る (この Packet In の in_port をポート s とする)</p>
</li>
<li>
<p>ルーティングスイッチはあらかじめ収集しておいたトポロジ情報 (<a href="#topology">14章</a>) を検索し、宛先のホスト 4 が接続するスイッチ (スイッチ 6) とポート番号 (ポート g とする) を得る</p>
</li>
<li>
<p>ポート s とポート g が同じスライスに属するか判定する。もし同じスライスではない場合にはパケットを捨て、以降の処理は行わない</p>
</li>
<li>
<p>ポート s から宛先のポート g までの最短パスをトポロジ情報から計算する。その結果、ポート s → スイッチ 1 → スイッチ 5 → スイッチ 6 → ポート g というパスを得る</p>
</li>
<li>
<p>この最短パスに沿ってパケットを転送するフローエントリを書き込むために、ルーティングスイッチはパス上のスイッチそれぞれに Flow Mod を送る</p>
</li>
<li>
<p>Packet In を起こしたパケットを宛先に送るために、ルーティングスイッチはスイッチ 6 に Packet Out (ポート g) を送る</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>スライス機能付きスイッチがルーティングスイッチと異なるのは、ステップ 3 を追加した点だけです。ステップ 3 では送信元と宛先ホストがそれぞれ同じスライスに属しているかを判定し、同じスライスに所属している場合のみパケットを転送します。それ以外はルーティングスイッチとまったく同じです。</p>
</div>
</div>
<div class="sect2">
<h3 id="_スライス機能付きスイッチのソースコード">17.7. スライス機能付きスイッチのソースコード</h3>
<div class="paragraph">
<p>スライス機能は、ルーティングスイッチに次の新たなクラス 2 個を追加することで実現しています (<a href="#sliceable_switch_classes">図 17-6</a>)。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">PathInSliceManager クラス</dt>
<dd>
<p>スライス内のパスを管理するコントローラの本体</p>
</dd>
<dt class="hdlist1">Slice クラス</dt>
<dd>
<p>スライスを管理する</p>
</dd>
</dl>
</div>
<div id="sliceable_switch_classes" class="imageblock">
<div class="content">
<img src="images/sliceable_switch/sliceable_switch_classes.png" alt="sliceable switch classes">
</div>
<div class="title">図 17-6: スライス機能付きスイッチを構成するクラス</div>
</div>
<div class="sect3">
<h4 id="_pathinslicemanager_クラス">17.7.1. PathInSliceManager クラス</h4>
<div class="paragraph">
<p>PathInSliceManager クラスは <code>packet_in</code> ハンドラでパケットの送信元と宛先が同じスライスに属するかどうかを判定します。それ以外の動作は PathManager クラスと同じなので、PathInSliceManager は PathManager を継承し <code>packet_in</code> ハンドラだけをオーバーライドします。</p>
</div>
<div class="listingblock">
<div class="title">PathInSliceManager#packet_in</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="function">packet_in</span>(_dpid, packet_in)
  slice = <span class="constant">Slice</span>.find <span class="keyword">do</span> |each|
    each.member?(packet_in.slice_source) &amp;&amp;
    each.member?(packet_in.slice_destination(<span class="instance-variable">@graph</span>))
  <span class="keyword">end</span>
  ports = <span class="keyword">if</span> slice
            path = maybe_create_shortest_path_in_slice(slice.name, packet_in)
            path ? [path.out_port] : []
          <span class="keyword">else</span>
            external_ports(packet_in)
          <span class="keyword">end</span>
  packet_out(packet_in.raw_data, ports)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Packet In メッセージが PathInSliceManager へ到着すると、PathInSliceManager は次の方法でパケットを宛先へと届けます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>パケットの送信元 MAC アドレスと宛先 MAC アドレスが同じスライスに属するかどうか判定する。もし同じスライスだった場合には、PathManager と同様に最短パスを作り宛先ホストへパケットを届ける</p>
</li>
<li>
<p>もし同じスライスでなかった場合、パケットをすべての外部ポート (スライス機能付きスイッチが管理するスイッチ以外と接続した全てのポート) へ PacketOut する。つまり、スライスに属していないホストへとばらまく<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnote_29" title="View footnote.">29</a>]</sup></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>ステップ 1 で使っている <code>Slice.find</code> メソッド (パケットの送信元と宛先が同じスライスに属するかどうか) といったスライスに関わる処理は、次の <code>Slice</code> クラスが行います。</p>
</div>
</div>
<div class="sect3">
<h4 id="_slice_クラス">17.7.2. Slice クラス</h4>
<div class="paragraph">
<p>Slice クラスはスライスの管理クラスです。スライスの追加・削除や検索といったクラスメソッドのほか、スライスへのポートやホストの追加・削除といった機能を提供します。</p>
</div>
<div class="paragraph">
<p>たとえば先ほど使った <code>Slice.find</code> メソッドは、スライスの一覧 (<code>all</code>) に対して同じ <code>find</code> メソッドを呼び出すだけです。</p>
</div>
<div class="listingblock">
<div class="title">スライスの検索 (lib/slice.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="predefined-constant">self</span>.<span class="function">find</span>(&amp;block)
  all.find(&amp;block)
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>スライスの追加メソッド <code>Slice.create</code> は指定した名前でスライスを作成します。最初に、すでに同じ名前のスライスがないかどうかを <code>Slice.find_by</code> で確認します。そして、スライスオブジェクトを <code>Slice.new</code> で作ります。作ったスライスはスライス一覧 (<code>all</code>) に追加します。</p>
</div>
<div class="listingblock">
<div class="title">スライスの追加 (lib/slice.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="predefined-constant">self</span>.<span class="function">create</span>(name)
  <span class="keyword">if</span> find_by(<span class="key">name</span>: name)
    fail <span class="constant">SliceAlreadyExistsError</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Slice </span><span class="inline"><span class="inline-delimiter">#{</span>name<span class="inline-delimiter">}</span></span><span class="content"> already exists</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
  new(name).tap { |slice| all &lt;&lt; slice }
<span class="keyword">end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Slice.destroy</code> は <code>create</code> の逆で、スライスの削除メソッドです。最初に、削除しようとした名前のスライスがあるかどうかを <code>Slice.find_by!</code> で確認します。そして、削除するスライスに属する最短パス (<code>Path</code> オブジェクト) を削除します。最後に、そのスライスをスライス一覧 <code>all</code> から消します。</p>
</div>
<div class="listingblock">
<div class="title">スライスの削除 (lib/slice.rb)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="ruby"><span class="keyword">def</span> <span class="predefined-constant">self</span>.<span class="function">destroy</span>(name)
  find_by!(<span class="key">name</span>: name)
  <span class="constant">Path</span>.find { |each| each.slice == name }.each(&amp;<span class="symbol">:destroy</span>)
  all.delete_if { |each| each.name == name }
<span class="keyword">end</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_17">17.8. まとめ</h3>
<div class="paragraph">
<p>Hello Trema から始めた Trema プログラミングも、いつの間にか本格的なクラウド用ネットワークを作れるまでになりました！</p>
</div>
<div class="ulist">
<ul>
<li>
<p>スライス機能付きスイッチが同一のスライス内の通信のみを許可する仕組み</p>
</li>
<li>
<p>クラウド構築ミドルウェアからスライスを設定するためのREST APIの使い方</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次章では、Trema を使った仮想ネットワークソフトウェアであり、商用クラウドにも使われている OpenVnet を紹介します。本章で解説したスライス機能付きスイッチとはまったく異なる「分散 Trema」とも言えるスライスの実現方法は、商用クラウドの作り方として参考になります。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="openvnet">18. OpenVNetで本格的な仮想ネットワーク</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>OpenVNetはTremaで構築された本格的な仮想ネットワーク基盤です。実際のデータセンターでも使える仮想ネットワークを体験しましょう。</p>
</div>
<div class="sect2">
<h3 id="_openvnetとは">18.1. OpenVNetとは</h3>
<div class="paragraph">
<p>OpenVNetはOpenFlowで仮想ネットワークを構築するためのフリーソフトウェアです。Tremaを使ってあらゆるパケットの挙動を自由に制御することで、既存のネットワーク上にあたかもユーザ専用のネットワークがあるかのような環境を作り出すことができます。開発はWSF(Wakame Software Foundation)が中心となっており、筆者の一人である山崎の所属する株式会社あくしゅの開発者がメインコミッターを務めています。ソフトウェアライセンスにLGPLv3を採用し、組織の枠を越えたオープンソースでの開発を行っています。</p>
</div>
<div class="paragraph">
<p>OpenVNetはもともと、WSFのプロジェクトの 1 つであるWakame-vdcからネットワーク機能を切り出したものです。Wakame-vdcはデータセンター全体を仮想化するためのソフトウェアで、すでにいくつもの企業や研究機関で商業化や実用化が進んでいます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>国立情報学研究所 (NII): 分散処理の実証実験、クラウド教育教材として活用</p>
</li>
<li>
<p>九州電力: 大規模データの分散処理基盤として</p>
</li>
<li>
<p>NTT PCコミュニケーションズ: パブリッククラウド WebARENA VPSクラウド</p>
</li>
<li>
<p>京セラコミュニケーションシステム: パブリッククラウド GreenOffice Unified Cloud</p>
</li>
<li>
<p>TIS株式会社: OpenVNetのDocker対応とクラウド間連携の実証プロジェクト (後述)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_エッジ仮想化による仮想ネットワーク">18.1.1. エッジ仮想化による仮想ネットワーク</h4>
<div class="paragraph">
<p>OpenVNetによるネットワーク仮想化の特長は、<strong>エッジ仮想化</strong>である点です。エッジ仮想化では、仮想マシンと既存のネットワークとの間にソフトウェアOpenFlowスイッチ(エッジスイッチ)を設置し、ここで全てのパケットを制御します。これによって、仮想マシンからは、あたかも独立したネットワークがあるかのように見えます。</p>
</div>
<div class="paragraph">
<p>エッジスイッチの主な仕事は、物理ネットワークと仮想ネットワーク間でのパケットの相互書き換えです。</p>
</div>
<div id="edge_network_virtualization" class="imageblock">
<div class="content">
<img src="images/openvnet/edge_translation.png" alt="edge translation">
</div>
<div class="title">図 18-1: エッジ仮想化によるネットワークの仮想化</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>仮想マシンから仮想ネットワークに送信したパケットは、エッジスイッチが物理ネットワークを通るように書き換え、宛先のサーバへ送出する</p>
</li>
<li>
<p>宛先のサーバに届く直前のエッジスイッチで逆の書き換えを行う。つまり、物理ネットワークを通ってきたパケットを仮想ネットワーク内のパケットに見えるように書き換える</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>こうしたエッジスイッチによるパケットの書き換えは仮想マシンからは見えません。OpenVNetの作り出した仮想ネットワークが、仮想マシンからは物理ネットワークであるかのように見えます。</p>
</div>
<div class="paragraph">
<p>エッジ仮想化のもう一つの大きな利点は、OpenFlow化されていない既存のネットワーク上で動作することです。たとえば <a href="#sliceable_switch">第17章「ネットワークを仮想化する」</a> で紹介したスライサブルスイッチには、ネットワークスイッチがすべてOpenFlowに対応しているという前提がありました。一方エッジ仮想化では、この制御を物理サーバ上に起動したエッジスイッチだけで行います。こうすることで、既に構築されたネットワークの上で仮想ネットワークを実現できます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_エッジ仮想化の利点">18.2. エッジ仮想化の利点</h3>
<div class="paragraph">
<p>OpenVNetのようなエッジ仮想化は、次の2つの場面で特に威力を発揮します。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>既存ネットワークの活用</p>
</li>
<li>
<p>ダウンサイジング</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_既存ネットワークの活用">18.2.1. 既存ネットワークの活用</h4>
<div class="paragraph">
<p>最小の変更だけで既存データセンター上に仮想ネットワークサービスを構築できます。エッジ仮想化によるネットワーク仮想化はほぼ物理サーバの追加だけで実現できます。このため、物理ネットワークの新たな敷設や再設定をできるだけ抑えながら、その上に新しく仮想ネットワークを構築して提供できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ダウンサイジング">18.2.2. ダウンサイジング</h4>
<div class="paragraph">
<p>古い大量の物理スイッチを仮想ネットワーク化することで一掃できます。近年のネットワーク帯域向上により、物理ネットワークの仮想環境への詰め込みが一般的になってきました。たとえば単純計算しただけでも、10Gbpsの物理ネットワークには10Mbpsの仮想ネットワークを100個ほど詰め込めます。さらに、ネットワーク利用率のばらつきを考慮し効率的に設計すれば、より多くを集約できます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_openvnetの全体アーキテクチャ">18.3. OpenVNetの全体アーキテクチャ</h3>
<div class="paragraph">
<p>OpenVNetのアーキテクチャは非常にシンプルです。データセンタ全体のネットワークの構成を管理するのが、vnmgr(Virtual Network Manager)です。vnmgrはグローバルな仮想ネットワーク設定情報を元に、分散するvna(Virtual Network Agent)に対して、エッジスイッチを設定するよう指示します。個々の vna は Trema を使ったコントローラとして実装しており、それぞれが担当するエッジスイッチへとフローエントリを書き込みます。</p>
</div>
<div id="openvnet_architecture" class="imageblock">
<div class="content">
<img src="images/openvnet/openvnet_architecture.png" alt="openvnet architecture">
</div>
<div class="title">図 18-2: OpenVNetの全体アーキテクチャ</div>
</div>
<div class="paragraph">
<p>OpenVNetはTrema以外にも、定評のあるフリーソフトウェアをコンポーネントとして利用しています。エッジスイッチとして動作するソフトウェアスイッチ、グローバルな仮想ネットワーク設定情報を管理するデータベース、そして vnmgr と vna 間のメッセージングには、それぞれ次のソフトウェアを採用しています。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">コンポーネント</th>
<th class="tableblock halign-left valign-top">実装</th>
<th class="tableblock halign-left valign-top">URL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenFlow スイッチ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Open vSwitch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openvswitch.org/" class="bare">http://openvswitch.org/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">設定情報データベース</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.mysql.com/" class="bare">http://www.mysql.com/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">メッセージング</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZeroMQ &amp; Redis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://zeromq.org/" class="bare">http://zeromq.org/</a> <a href="http://redis.io/" class="bare">http://redis.io/</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_openvnetの主な機能">18.4. OpenVNetの主な機能</h3>
<div class="paragraph">
<p>OpenVNetは仮想ネットワーク以外にも、次の 4 つの強力な機能を持っています。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>仮想ルータによる仮想ネットワーク接続</p>
</li>
<li>
<p>セキュリティグループによる仮想ファイアウォール機能</p>
</li>
<li>
<p>DHCPとDNSサービス</p>
</li>
<li>
<p>仮想ネットワークと既存ネットワークの接続</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_仮想ルータによる仮想ネットワーク間接続">18.4.1. 仮想ルータによる仮想ネットワーク間接続</h4>
<div class="paragraph">
<p>OpenVNet上に作成した２つ以上の仮想ネットワークの間を自由に相互接続できます。これにより、２つの異なる仮想ネットワークに接続する仮想マシン同士が通信できるようになります。これはちょうど、仮想ネットワークの間にルータを仮想的に配置するようなものです。</p>
</div>
<div id="route_between_vnets" class="imageblock">
<div class="content">
<img src="images/openvnet/route_between_vnets.png" alt="route between vnets">
</div>
<div class="title">図 18-3: 仮想ルータによる仮想ネットワーク間接続</div>
</div>
<div class="paragraph">
<p>この仮想ルータ機能は、すべてエッジスイッチのフローによって実現しています。仮想マシン間のパケットは余計なネットワーク経路を辿らず、エッジスイッチ間で最適な通信をします。</p>
</div>
</div>
<div class="sect3">
<h4 id="_セキュリティグループによる仮想ファイアウォール機能">18.4.2. セキュリティグループによる仮想ファイアウォール機能</h4>
<div class="paragraph">
<p>エッジスイッチは各仮想マシンのトラフィック全ての関所でもあります。セキュリティグループは、この関所にパケットの受け入れ許可ルールを指定し、仮想マシンのファイアウォールとして機能させるものです。</p>
</div>
<div id="sequrity_groups" class="imageblock">
<div class="content">
<img src="images/openvnet/sequrity_groups.png" alt="sequrity groups">
</div>
<div class="title">図 18-4: セキュリティグループ間の仮想ファイアウォール機能</div>
</div>
<div class="paragraph">
<p>セキュリティグループは、このファイアウォール設定を仮想的なグループ間の通信に設定できます。仮想ファイアウォールの設定をエッジスイッチのフローエントリへと自動変換することで、グループ間の適切な通信ルールを制御します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_dhcpとdnsサービス">18.4.3. DHCPとDNSサービス</h4>
<div class="paragraph">
<p>DHCPやDNSなどのサービスをエッジスイッチとコントローラだけで処理できます。これにより、新たにDHCPサーバなどを立てなくてもソフトウェア的に各種ネットワークサービスを提供できます。</p>
</div>
<div id="dhcp" class="imageblock">
<div class="content">
<img src="images/openvnet/dhcp.png" alt="dhcp">
</div>
<div class="title">図 18-5: DHCPサービスをエッジスイッチとvnaで実現</div>
</div>
<div class="paragraph">
<p>たとえばDHCPの場合、DHCP関係のパケットはエッジスイッチでマッチさせ、vnaにエスカレーションします。vnaはDHCPの返信パケットを生成し仮想マシンへ直接返答します。この機能は、仮想マシンに割り振るIPアドレスが自明である場合に利用できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_仮想ネットワークと外部ネットワークとの接続">18.4.4. 仮想ネットワークと外部ネットワークとの接続</h4>
<div class="paragraph">
<p>OpenVNetで作った仮想ネットワークを、外部のネットワークと接続する機能を VNetEdge と呼びます。2つのネットワーク境界にあるエッジスイッチ上のフローを使って、ネットワーク間でパケットの相互転送を行います。</p>
</div>
<div class="paragraph">
<p>VNetEdgeでは、トランスレーションと呼ぶルールに従ってパケットの相互転送を行います。例えば、特定のVLANタグを持ったパケットを任意の仮想ネットワークへ転送したり、特定のIPアドレス宛のパケットを仮想ネットワーク内の任意のIPアドレスへ変換したりできます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使ってみる">18.5. 使ってみる</h3>
<div class="paragraph">
<p>OpenVNetの利用はとても簡単です。実行に必要なものは次の2つだけです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CentOS 6.6以上(CentOS6系)が稼働する物理または仮想マシン</p>
</li>
<li>
<p>インターネット接続</p>
</li>
</ul>
</div>
<div id="openvnet_installation_overview" class="imageblock">
<div class="content">
<img src="images/openvnet/openvnet_installation_overview.png" alt="openvnet installation overview">
</div>
<div class="title">図 18-6: 1台のマシンで動作するOpenVNet環境</div>
</div>
<div class="sect3">
<h4 id="_インストールしてみる">18.5.1. インストールしてみる</h4>
<div class="paragraph">
<p>OpenVNetのインストールと初期設定は、以下の手順で進めます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>OpenVNetのインストール</p>
</li>
<li>
<p>RedisとMySQLのインストール</p>
</li>
<li>
<p>エッジスイッチの設定</p>
</li>
<li>
<p>各種サービスの起動</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_openvnetのインストール">OpenVNetのインストール</h5>
<div class="paragraph">
<p>OpenVNetは <code>yum</code> パッケージとして提供されています。リポジトリの設定ファイルである <code>openvnet.repo</code> を <code>/etc/yum/repos.d/</code> ディレクトリに次のようにダウンロードします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo curl -o /etc/yum.repos.d/openvnet.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet.repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、OpenVNetで利用するミドルウェアパッケージをまとめらたリポジトリ設定ファイル <code>openvnet-third-party.repo</code> を <code>/etc/yum.repos.d/</code> ディレクトリにダウンロードします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo curl -o /etc/yum.repos.d/openvnet-third-party.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet-third-party.repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>加えて、OpenVNetのインストールに必要なエンタープライズLinux用の拡張パッケージである <code>epel-release</code> パッケージをインストールしておきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo yum install -y epel-release</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここまで完了したら、OpenVNetパッケージをインストールします。<code>openvnet</code> パッケージはメタパッケージで、OpenVNetの動作に必要なパッケージを一度に全てインストールできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo yum install -y openvnet</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_redisとmysqlのインストール">RedisとMySQLのインストール</h5>
<div class="paragraph">
<p>RedisおよびMySQL serverパッケージをインストールします。OpenVNetは、Redisをプロセス間通信ミドルウェアとして、またMySQLをネットワーク構成情報のデータベースとして利用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo yum install -y mysql-server redis</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_エッジスイッチの設定">エッジスイッチの設定</h5>
<div class="paragraph">
<p><code>br0</code> という名前のエッジスイッチを作成します。後の疎通確認では、 <code>inst1</code> および <code>inst2</code> という2つの仮想マシンをこのエッジスイッチに接続します。 <code>br0</code> の設定ファイルとして、 <code>/etc/sysconfig/network-scripts/ifcfg-br0</code> を、以下の内容で作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>DEVICE=br0
DEVICETYPE=ovs
TYPE=OVSBridge
ONBOOT=yes
BOOTPROTO=static
HOTPLUG=no
OVS_EXTRA="
 set bridge     ${DEVICE} protocols=OpenFlow10,OpenFlow12,OpenFlow13 --
 set bridge     ${DEVICE} other_config:disable-in-band=true --
 set bridge     ${DEVICE} other-config:datapath-id=0000aaaaaaaaaaaa --
 set bridge     ${DEVICE} other-config:hwaddr=02:01:00:00:00:01 --
 set-fail-mode  ${DEVICE} standalone --
 set-controller ${DEVICE} tcp:127.0.0.1:6633
"</code></pre>
</div>
</div>
<div class="paragraph">
<p>なお、この設定では <code>datapath-id</code> を <code>0000aaaaaaaaaaaa</code> という値に設定しています。この値はOpenVNetがエッジスイッチを認識するための一意な識別子で、16進数の値を設定できます。後ほど利用する値ですので、覚えておいて下さい。</p>
</div>
</div>
<div class="sect4">
<h5 id="_各種サービスの起動">各種サービスの起動</h5>
<div class="paragraph">
<p>次のコマンドで <code>openvswitch</code> サービスとエッジスイッチを起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo service openvswitch start
$ sudo ifup br0</code></pre>
</div>
</div>
<div class="paragraph">
<p>ネットワーク構成情報を保持するデータベースとして、MySQL serverを起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo service mysqld start</code></pre>
</div>
</div>
<div class="paragraph">
<p>OpenVNetは、OpenVNetと同時にインストールされるRubyを利用しますので、環境変数PATHにそのパスを設定しておきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ PATH=/opt/axsh/openvnet/ruby/bin:${PATH}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、構成情報のためのデータベースの作成を行います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ cd /opt/axsh/openvnet/vnet
$ bundle exec rake db:create
$ bundle exec rake db:init</code></pre>
</div>
</div>
<div class="paragraph">
<p>OpenVNetの各サービス間の通信に使うRedisを起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ service redis start</code></pre>
</div>
</div>
<div class="paragraph">
<p>OpenVNetのサービス群 (<code>vnmgr</code> 、 <code>webapi</code> 、 <code>vna</code>) を起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo initctl start vnet-vnmgr
$ sudo initctl start vnet-webapi</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>vnctl</code> ユーティリティで構成情報データベースを作成します。次のコマンドで、<code>vna</code> が管理するエッジスイッチの Datapath ID をOpenVNetに教えます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ vnctl datapaths add --uuid dp-test1 --display-name test1 --dpid 0x0000aaaaaaaaaaaa --node-id vna</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>vna</code> と Datapath ID の紐付けができたので、 <code>vna</code> を起動してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo initctl start vnet-vna</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ovs-vsctl</code> コマンドで、 <code>vna</code> が正しく動作しているかを確認できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ovs-vsctl show
fbe23184-7f14-46cb-857b-3abf6153a6d6
    Bridge "br0"
        Controller "tcp:127.0.0.1:6633"
            is_connected: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで、 <code>is_connected: true</code> の文字列が見えていれば、 <code>vna</code> は正しく動作しています。</p>
</div>
<div class="paragraph">
<p>次に仮想マシンとして2つの仮想マシン( <code>inst1</code> と <code>inst2</code> )を作成し、OpenVNetの仮想ネットワークに接続してみます。起動する仮想マシンの種類として、今回は軽量なコンテナの一種であるLXCを使います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo yum -y install lxc lxc-templates</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lxc</code> および <code>lxc-templates</code> パッケージのインストールが完了したら、コンテナのリソース制御を行う <code>cgroup</code> を設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo mkdir /cgroup
$ echo "cgroup /cgroup cgroup defaults 0 0" &gt;&gt; /etc/fstab
$ sudo mount /cgroup</code></pre>
</div>
</div>
<div class="paragraph">
<p>仮想マシン作成コマンドである <code>lxc-create</code> が利用する <code>rsync</code> をインストールします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo yum install -y rsync</code></pre>
</div>
</div>
<div class="paragraph">
<p>LXCの動作の準備が出来ましたので、いよいよ仮想マシン <code>inst1</code>、<code>inst2</code> を作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo lxc-create -t centos -n inst1
$ sudo lxc-create -t centos -n inst2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lxc-create</code> を実行すると、それぞれの仮想マシンの <code>root</code> ユーザのパスワードが入ったファイル名を出力します。このパスワードは後で仮想マシンにログインする際に利用しますので、覚えておいて下さい。</p>
</div>
<div class="paragraph">
<p>次に、仮想マシンのネットワークインタフェースの設定を行います。 <code>/var/lib/lxc/inst1/config</code> ファイルを開き、内容を以下で置き換えて下さい。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>lxc.network.type = veth
lxc.network.flags = up
lxc.network.veth.pair = inst1
lxc.network.hwaddr = 10:54:FF:00:00:01
lxc.rootfs = /var/lib/lxc/inst1/rootfs
lxc.include = /usr/share/lxc/config/centos.common.conf
lxc.arch = x86_64
lxc.utsname = inst1
lxc.autodev = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>同様に、 <code>/var/lib/lxc/inst2/config</code> ファイルを開き、内容を以下で置き換えます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>lxc.network.type = veth
lxc.network.flags = up
lxc.network.veth.pair = inst2
lxc.network.hwaddr = 10:54:FF:00:00:02
lxc.rootfs = /var/lib/lxc/inst2/rootfs
lxc.include = /usr/share/lxc/config/centos.common.conf
lxc.arch = x86_64
lxc.utsname = inst2
lxc.autodev = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定ファイルの内容を置き換えたら、仮想マシンを起動します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo lxc-start -d -n inst1
$ sudo lxc-start -d -n inst2</code></pre>
</div>
</div>
<div class="paragraph">
<p>仮想マシンが起動したら、その仮想マシンのネットワークインタフェースを先程設定したエッジスイッチに手動で接続します。これは、ちょうどネットワークケーブルを物理スイッチに挿入する操作に対応します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo ovs-vsctl add-port br0 inst1
$ sudo ovs-vsctl add-port br0 inst2</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、OpenVNetのインストールと、OpenVNetの仮想ネットワークを体験する準備が整いました。ここまでの操作では、何もない物理ネットワークと繋がるエッジスイッチに仮想マシンが接続しただけの状態です。</p>
</div>
<div id="openvnet_connected" class="imageblock">
<div class="content">
<img src="images/openvnet/openvnet_connected.png" alt="openvnet connected">
</div>
<div class="title">図 18-7: 仮想マシンがエッジスイッチに接続した状態</div>
</div>
<div class="paragraph">
<p>では、最も基本的な仮想ネットワークを1つ作成をしてみましょう。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cliで仮想ネットワークを操作する">18.5.2. CLIで仮想ネットワークを操作する</h4>
<div class="paragraph">
<p>仮想ネットワークの操作はすべて <code>vnctl</code> コマンドで行います。まずは、1つの仮想ネットワークを作成してみましょう。</p>
</div>
<div class="paragraph">
<p>作成する仮想ネットワークのアドレスを <code>10.100.0.0/24</code> とし、 <code>inst1</code> のIPアドレスを <code>10.100.0.10</code>、<code>inst2</code> のIPアドレスを <code>10.100.0.11</code> とします。次の <code>vnctl networks</code> コマンドでこのネットワークを作成できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ vnctl networks add \
  --uuid nw-test1 \
  --display-name testnet1 \
  --ipv4-network 10.100.0.0 \
  --ipv4-prefix 24 \
  --network-mode virtual</code></pre>
</div>
</div>
<div id="openvnet_cli_simplenetwork_1" class="imageblock">
<div class="content">
<img src="images/openvnet/openvnet_cli_simplenetwork_1.png" alt="openvnet cli simplenetwork 1">
</div>
<div class="title">図 18-8: 仮想ネットワークの作成</div>
</div>
<div class="paragraph">
<p>次に、どのネットワークインタフェースがどの仮想ネットワークに所属しているのかを <code>vnctl</code> コマンドでOpenVNetに教えます。 これは、 <code>vnctl interfaces</code> コマンドで実行できます。まずは、 <code>inst1</code> の持つネットワークインタフェースを仮想ネットワークに設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ vnctl interfaces add \
  --uuid if-inst1 \
  --mode vif \
  --owner-datapath-uuid dp-test1 \
  --mac-address 10:54:ff:00:00:01 \
  --network-uuid nw-test1 \
  --ipv4-address 10.100.0.10 \
  --port-name inst1</code></pre>
</div>
</div>
<div class="paragraph">
<p>同様に、 <code>inst2</code> の持つネットワークインタフェースを仮想ネットワークに設定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>vnctl interfaces add \
  --uuid if-inst2 \
  --mode vif \
  --owner-datapath-uuid dp-test1 \
  --mac-address 10:54:ff:00:00:02 \
  --network-uuid nw-test1 \
  --ipv4-address 10.100.0.11 \
  --port-name inst2</code></pre>
</div>
</div>
<div class="paragraph">
<p>この操作により、OpenVNetは <code>10.100.0.0/24</code> の仮想ネットワークを作成し、そこにそれぞれ <code>10.100.0.10</code> 、 <code>10.100.0.11</code> のIPアドレスを持つネットワークインタフェースを接続します。</p>
</div>
<div id="openvnet_cli_simplenetwork_2" class="imageblock">
<div class="content">
<img src="images/openvnet/openvnet_cli_simplenetwork_2.png" alt="openvnet cli simplenetwork 2">
</div>
<div class="title">図 18-9: ネットワークインタフェースにIPアドレスを設定した状態</div>
</div>
</div>
<div class="sect3">
<h4 id="_疎通確認をする">18.5.3. 疎通確認をする</h4>
<div class="paragraph">
<p>作成した2つの仮想マシンが仮想ネットワークを通じて疎通できることを確認します。まず <code>inst1</code> にログインし、IPアドレスを確認してみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ lxc-console -n inst1
$ ip addr show</code></pre>
</div>
</div>
<div class="paragraph">
<p>この時点ではまだ <code>inst1</code> の <code>eth0</code> にIPアドレスを設定していないため、IPアドレスが表示されません。作った仮想ネットワークではDHCPサービスを有効にしていないため、IPアドレスは手動で設定する必要があります。</p>
</div>
<div class="paragraph">
<p><code>inst1</code> のコンソールにて次のコマンドを実行し、 <code>eth0</code> にIPアドレス <code>10.100.0.10</code> を設定します。これは、 <code>vnctl</code> で設定した <code>inst1</code> のネットワークインタフェースのIPアドレスと同じにする必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ip addr add 10.100.0.10/24 dev eth0</code></pre>
</div>
</div>
<div class="paragraph">
<p>もう1つ端末を開き、 <code>inst2</code> に対し同じ操作を行います。<code>inst2</code> の <code>eth0</code> に設定するIPアドレスは、 <code>10.100.0.11</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ lxc-console -n inst2
$ ip addr add 10.100.0.11/24 dev eth0</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで2つの仮想マシンそれぞれに仮想ネットワーク内のIPアドレスを設定できました。</p>
</div>
<div id="openvnet_cli_simplenetwork_3" class="imageblock">
<div class="content">
<img src="images/openvnet/openvnet_cli_simplenetwork_3.png" alt="openvnet cli simplenetwork 3">
</div>
<div class="title">図 18-10: ネットワークインタフェースにIPアドレスを設定</div>
</div>
<div class="paragraph">
<p>それでは、お互いに <code>ping</code> を実行してみます。まずは、 <code>inst2</code> から <code>inst1</code> に <code>ping</code> を実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ping 10.100.0.10</code></pre>
</div>
</div>
<div class="paragraph">
<p>うまく行った場合、pingは正しく動作し、疎通が確認できるはずです。もしうまく動作しない場合は、ここまでの手順を確認してみて下さい。</p>
</div>
<div class="paragraph">
<p>疎通できるようになったところで、従来のネットワークとOpenVNetの仮想ネットワークとの興味深い違いを1つ紹介しておきましょう。先ほど <code>inst2</code> の <code>eth0</code> に設定したIPアドレスを、 <code>10.100.0.11/24</code> から <code>10.100.0.15/24</code> に変更してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ sudo ip addr del 10.100.0.11/24 dev eth0
$ sudo ip addr add 10.100.0.15/24 dev eth0</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定が終わったら、再び <code>inst1</code> に対して <code>ping</code> を実行してみます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ ping 10.100.0.10</code></pre>
</div>
</div>
<div class="paragraph">
<p>先程とは異なり、疎通ができなくなったはずです。これがもし従来のネットワークだった場合、 <code>10.100.0.0/24</code> の範囲内のIPアドレスであれば疎通できます。しかしOpenVNetは設定情報に従って厳格に通信制限を行うため、<code>inst2</code> のIPアドレスが <code>10.100.0.11</code> でない限り、通信を許可しません。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_openvnetを応用した実用例">18.6. OpenVNetを応用した実用例</h3>
<div class="paragraph">
<p>最後にOpenVNetの高度な応用事例として、OpenVNetのDockerコンテナ対応、および複数クラウド間の仮想ネットワークによる連携機能を紹介します。いずれも、著者の所属するTIS株式会社が実証実験を行い、それぞれの成果はフリーソフトウェアとして配布しています。</p>
</div>
<div class="sect3">
<h4 id="_複数サーバ上のdockerコンテナを仮想ネットワークで接続する">18.6.1. 複数サーバ上のDockerコンテナを仮想ネットワークで接続する</h4>
<div class="paragraph">
<p>Docker <sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnote_30" title="View footnote.">30</a>]</sup> とは、dotCloud社（現Docker社）が自社のパブリックPaaSを実現するために開発したコンテナの一種です。アプリケーションの実行環境を容易に素早く、かつ他の影響を受けないようにして立ち上げるために、Dockerは他から隔離された環境（＝コンテナ）を作り出します。</p>
</div>
<div class="paragraph">
<p>Dockerは様々なリソースを隔離しますが、ネットワークもその隔離すべきリソースの一つです。そのためDockerは、ネットワークネームスペースや仮想ネットワークインタフェースを用いて、サーバ内部に他から隔離された仮想ネットワークを作ります。さらに Docker は iptables を使って、この仮想ネットワークを外部と通信できるようにします。</p>
</div>
<div class="paragraph">
<p>この方式は、複数のサーバ上でDockerを動作させる場合に問題が生じます。Dockerが作り出す仮想ネットワークはサーバ内に閉じており、異なるサーバで動作しているDockerコンテナ同士が通信できないためです。</p>
</div>
<div class="paragraph">
<p>この問題は、DockerにOpenVNetを組み合わせれば、解決できます。Dockerコンテナ同士をOpenVNetの仮想ネットワークで接続すれば、サーバをまたいだDockerコンテナ間が通信できるようになります。さらに、OpenVNetを使うことで、Docker コンテナを繋ぐネットワークに対して、セキュリティグループの機能が使えます。</p>
</div>
<div class="paragraph">
<p>例えばある物理ネットワーク上のサーバ2台と、ルータで接続された別の物理ネットワーク上のサーバ1台の合計3つのサーバがあるとします。これらのサーバ上でDockerコンテナを動作させ、それらをOpenVNetの仮想ネットワークで接続することを考えてみましょう。</p>
</div>
<div class="paragraph">
<p>まず最初に、各サーバ上にエッジスイッチを立ち上げます。次に、各サーバ上でDockerコンテナを立ち上げ、それらをエッジスイッチに接続します。</p>
</div>
<div class="paragraph">
<p>さらに以下の手順でOpenVNetを設定します。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>各エッジスイッチのDatapath IDをOpenVNetに設定する</p>
</li>
<li>
<p>各サーバが所属する物理ネットワークの情報をOpenVNetに設定する</p>
</li>
<li>
<p>OpenVNetが敷設する仮想ネットワークを定義する</p>
</li>
<li>
<p>各サーバの物理ネットワークインタフェースの情報をOpenVNetに設定する</p>
</li>
<li>
<p>立ち上げたDockerコンテナの仮想ネットワークインタフェースの情報をOpenVNetに設定する</p>
</li>
<li>
<p>OpenVNetが制御するセキュリティグループを定義する</p>
</li>
<li>
<p>各仮想ネットワークインタフェースに望みのセキュリティグループを割り当てる</p>
</li>
<li>
<p>OpenVNet上に仮想ルータを構成して、物理ネットワークと仮想ネットワーク間のルーティングを定義する</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>最後に各サーバとDockerコンテナにスタティックルートを設定すれば、OpenVNetを用いたDockerネットワーキングが完成します。</p>
</div>
<div class="paragraph">
<p>各サーバ上のDockerコンテナは、OpenVNetが作った一つの仮想ネットワークに接続していますので、異なるサーバのDockerコンテナ同士が通信できます。またセキュリティグループの機能を使えば、OpenVNet が到達すべきでないパケットを遮断するため、個々のDockerコンテナにパケットフィルタルールを定義する必要がなくなります。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/openvnet/docker_openvnet_1.png" alt="docker openvnet 1">
</div>
<div class="title">図 18-11: OpenVNetを用いたDockerネットワーキング</div>
</div>
<div class="paragraph">
<p>なお、ここで説明した手順を実行するツールキットを、walfisch <sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnote_31" title="View footnote.">31</a>]</sup> というフリーソフトウェアとして公開しています。実際に実行したコマンドが標準出力に表示されますので、興味がある方は一度動作させてみると良いでしょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_複数のクラウドを仮想ネットワークで連結する">18.6.2. 複数のクラウドを仮想ネットワークで連結する</h4>
<div class="paragraph">
<p>OpenVNetはDockerコンテナ間を連結するというミクロな機能だけでなく、複数のクラウド間を連結するというマクロな機能も提供します。</p>
</div>
<div class="paragraph">
<p>現在様々なクラウドが利用可能ですが、提供されるネットワーク機能やその利用方法はクラウドごとに大きく異なります。このため複数のクラウド間を連結したい場合、それぞれのクラウドのネットワーク機能を強く意識したネットワーク設計を行う必要があります。</p>
</div>
<div class="paragraph">
<p>OpenVNetは、OpenVNetの仮想ネットワークと外部のネットワークの間をシームレスに接続するVNetEdge機能を持っています。そのためOpenVNetを利用することで、クラウドごとに異なるネットワーク機能に依存せず、複数のクラウドをシームレスに連携できます。</p>
</div>
<div class="paragraph">
<p>例えば、プライベートクラウドとしてWakame-vdc、パブリッククラウドとしてAmazon Web Servicesのネットワークを連結するケースを考えます。</p>
</div>
<div id="narukozaka_tools" class="imageblock">
<div class="content">
<img src="images/openvnet/narukozaka_tools.png" alt="narukozaka tools">
</div>
<div class="title">図 18-12: プライベートIaaSとパブリックIaaSの連結構成</div>
</div>
<div class="paragraph">
<p>VNetEdgeはこの連結を次のように実現しています。まず、仮想ネットワークIDとVLAN IDの変換規則をOpenVNetに登録します。そして、Wakame-vdcの仮想ネットワークと、Amazon Web ServicesのVirtual Private Cloudで構築されたネットワークの間を流れるパケットがVNetEdgeのエッジスイッチを通過する際に、この２つのネットワークが同一のネットワークであるかのようにパケット転送を制御します。</p>
</div>
<div class="paragraph">
<p>このツールキットはフリーソフトウェアとして公開しており <sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnote_32" title="View footnote.">32</a>]</sup>、複数のクラウド間を連結する以外にも多くの機能を持ちます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>wakame-vdcとパブリックIaaSの間を自動的に連結する機能</p>
</li>
<li>
<p>IaaSのネットワーク上に、VNetEdgeをスイッチとしたスター型のネットワークトポロジを構築する機能</p>
</li>
<li>
<p>Wakame-vdc側のインスタンスとAmazon Web Services側のインスタンスのVNetEdge間の通信の暗号化</p>
</li>
<li>
<p>IaaSのインスタンスイメージの作成と起動</p>
</li>
<li>
<p>IaaSのインスタンスにインストールするミドルウェアの自動設定</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_まとめ_18">18.7. まとめ</h3>
<div class="paragraph">
<p>Tremaで構築された本格的な仮想ネットワーク基盤である OpenVNet を紹介しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OpenVNet はエッジ仮想化であるため、既存の物理ネットワークをほぼそのまま活用して、仮想ネットワークを実現できる</p>
</li>
<li>
<p>オンプレミス環境以外にも、AWSに代表されるパブリッククラウドでも利用できる</p>
</li>
<li>
<p>仮想マシンだけでなく、Dockerに代表されるコンテナ主体の基盤とも組み合わせて利用できる</p>
</li>
<li>
<p>LGPL3ライセンスに基づくフリーソフトウェアであり、オープンな開発コミュニティを持っている</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>OpenVNetは、Tremaと同じく開発者を広く募集しています。腕に覚えのある方は、ぜひOpenVNetのホームページ (<a href="http://openvnet.org/" class="bare">http://openvnet.org/</a>) から開発にご参加ください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright_and_license">Appendix A: Copyright and License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This book is released under the GNU General Public License version 3.0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.gnu.org/licenses/gpl-3.0.html" class="bare">http://www.gnu.org/licenses/gpl-3.0.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. MIT の <code>xpizza</code> コマンドのマニュアル: <a href="https://stuff.mit.edu/afs/sipb/project/lnf/other/CONTRIB/ai-info" class="bare">https://stuff.mit.edu/afs/sipb/project/lnf/other/CONTRIB/ai-info</a>
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. カーネギーメロン大学のコーク・マシンのサイト: <a href="http://www.cs.cmu.edu/~coke/" class="bare">http://www.cs.cmu.edu/~coke/</a>
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. RFC 2324: <a href="https://www.ietf.org/rfc/rfc2324.txt" class="bare">https://www.ietf.org/rfc/rfc2324.txt</a>
</div>
<div class="footnote" id="_footnote_4">
<a href="#_footnoteref_4">4</a>. 実際にはアクションはインストラクションという要素の一部です。アクションとインストラクションの関係について、詳しくは<a href="#openflow_spec">2章「OpenFlow の仕様」</a>で詳しく説明します
</div>
<div class="footnote" id="_footnote_5">
<a href="#_footnoteref_5">5</a>. 指定できるアクション数の上限は OpenFlow スイッチとコントローラの実装に依存します。普通に使う分にはまず問題は起こらないでしょう
</div>
<div class="footnote" id="_footnote_6">
<a href="#_footnoteref_6">6</a>. Web プログラミングフレームワークの一つ。http://rubyonrails.org/
</div>
<div class="footnote" id="_footnote_7">
<a href="#_footnoteref_7">7</a>. <a href="https://bundler.io/" class="bare">https://bundler.io/</a>
</div>
<div class="footnote" id="_footnote_8">
<a href="#_footnoteref_8">8</a>. <a href="http://openvswitch.org/" class="bare">http://openvswitch.org/</a>
</div>
<div class="footnote" id="_footnote_9">
<a href="#_footnoteref_9">9</a>. <a href="https://www.rdoproject.org/Main_Page" class="bare">https://www.rdoproject.org/Main_Page</a>
</div>
<div class="footnote" id="_footnote_10">
<a href="#_footnoteref_10">10</a>. 日本語版は <a href="http://www.aoky.net/articles/why_poignant_guide_to_ruby/" class="bare">http://www.aoky.net/articles/why_poignant_guide_to_ruby/</a>
</div>
<div class="footnote" id="_footnote_11">
<a href="#_footnoteref_11">11</a>. <a href="http://archive.openflow.org/" class="bare">http://archive.openflow.org/</a>
</div>
<div class="footnote" id="_footnote_12">
<a href="#_footnoteref_12">12</a>. cbench コマンドの初回実行時には、自動的に cbench コマンドのコンパイルが始まります。二回目以降の実行ではコンパイルは起こりません
</div>
<div class="footnote" id="_footnote_13">
<a href="#_footnoteref_13">13</a>. OpenFlow1.0 にはインストラクションはありません。そのかわりパケットに適用したいアクションを、このように Flow Mod に直接指定します
</div>
<div class="footnote" id="_footnote_14">
<a href="#_footnoteref_14">14</a>. <a href="http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests" class="bare">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a>
</div>
<div class="footnote" id="_footnote_15">
<a href="#_footnoteref_15">15</a>. <a href="https://signalvnoise.com/posts/3159-testing-like-the-tsa" class="bare">https://signalvnoise.com/posts/3159-testing-like-the-tsa</a>
</div>
<div class="footnote" id="_footnote_16">
<a href="#_footnoteref_16">16</a>. <a href="https://cucumber.io" class="bare">https://cucumber.io</a>
</div>
<div class="footnote" id="_footnote_17">
<a href="#_footnoteref_17">17</a>. <a href="https://github.com/cucumber/aruba" class="bare">https://github.com/cucumber/aruba</a>
</div>
<div class="footnote" id="_footnote_18">
<a href="#_footnoteref_18">18</a>. <a href="https://github.com/trema/cucumber_step_definitions" class="bare">https://github.com/trema/cucumber_step_definitions</a>
</div>
<div class="footnote" id="_footnote_19">
<a href="#_footnoteref_19">19</a>. <a href="https://github.com/troessner/reek" class="bare">https://github.com/troessner/reek</a>
</div>
<div class="footnote" id="_footnote_20">
<a href="#_footnoteref_20">20</a>. <a href="http://ruby.sadi.st/Flog.html" class="bare">http://ruby.sadi.st/Flog.html</a>
</div>
<div class="footnote" id="_footnote_21">
<a href="#_footnoteref_21">21</a>. <a href="http://ruby.sadi.st/Flay.html" class="bare">http://ruby.sadi.st/Flay.html</a>
</div>
<div class="footnote" id="_footnote_22">
<a href="#_footnoteref_22">22</a>. <a href="https://github.com/bbatsov/rubocop" class="bare">https://github.com/bbatsov/rubocop</a>
</div>
<div class="footnote" id="_footnote_23">
<a href="#_footnoteref_23">23</a>. 厳密に言うと以下のステップが発生するには、レガシーネットワークスイッチのエージアウト間隔よりも OpenFlow スイッチのエージアウト間隔が長い、という前提条件があります
</div>
<div class="footnote" id="_footnote_24">
<a href="#_footnoteref_24">24</a>. ここでは、ルータに直接接続したネットワークへのルーティング (いわゆる connected ルーティング) の動作のみを説明しています。ルータに直接接続していないネットワークへのルーティング (いわゆるスタティックルーティング) の実装については、<code>lib/simple_router13.rb</code> の <code>SimpleRouter13#add_routing_table_flow_entries</code> メソッドを参照してください。
</div>
<div class="footnote" id="_footnote_25">
<a href="#_footnoteref_25">25</a>. ダイクストラ法はリンクに重み（距離）がある場合の最短パスを求められるので、実際にはもう少し複雑な手順になります。ネットワーク上の最短パスではそれぞれのリンクは“重み1”として考えるので、このように単純化できます。
</div>
<div class="footnote" id="_footnote_26">
<a href="#_footnoteref_26">26</a>. <a href="#sliceable_switch">16 章</a>ではルーティングスイッチにクラスを追加することで仮想ネットワーク機能を実装する例を紹介します。
</div>
<div class="footnote" id="_footnote_27">
<a href="#_footnoteref_27">27</a>. このようなパスを、イコールコストマルチパス（Equal Cost Multipath）と呼びます。
</div>
<div class="footnote" id="_footnote_28">
<a href="#_footnoteref_28">28</a>. <code>curl</code> の出力を短くするために、冗長オプション (<code>-v</code>) は省略しています
</div>
<div class="footnote" id="_footnote_29">
<a href="#_footnoteref_29">29</a>. この処理からわかるように、スライスに属していないホスト同士はデフォルトで通信できる仕様になっています
</div>
<div class="footnote" id="_footnote_30">
<a href="#_footnoteref_30">30</a>. Dockerの詳細は、Dockerの公式ドキュメント(<a href="https://docs.docker.com/)を参照ください" class="bare">https://docs.docker.com/)を参照ください</a>
</div>
<div class="footnote" id="_footnote_31">
<a href="#_footnoteref_31">31</a>. <a href="https://github.com/tech-sketch/walfisch" class="bare">https://github.com/tech-sketch/walfisch</a>
</div>
<div class="footnote" id="_footnote_32">
<a href="#_footnoteref_32">32</a>. <a href="https://github.com/cloudconductor-incubator/narukozaka-tools" class="bare">https://github.com/cloudconductor-incubator/narukozaka-tools</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.46.0<br>
Last updated 2016-10-18 00:23:30 UTC
</div>
</div>
</body>
</html>